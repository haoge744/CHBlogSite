{"meta":{"title":"cch‘s blog","subtitle":"JUST DO IT","description":null,"author":"cch","url":"https://haoge744.github.io","root":"/haoge744.github.io/"},"pages":[{"title":"关于","date":"2019-07-31T02:13:18.000Z","updated":"2020-03-14T03:40:13.363Z","comments":true,"path":"about/index.html","permalink":"https://haoge744.github.io/about/index.html","excerpt":"","text":"关于hi,你好欢迎来到我的博客。 搭建本博客的目的主要为了是记录和总结日常工作时出现的问题，以及学习新知识做笔记、总结以及转载。有时候也会写一些书评或者人文生活(仅包含个人观点)。文章质量可能参差不齐，有些文章可能为临时记录，有些为用心打磨，主要看自己费的心思吧。 希望自己能看到自己的不足，尽快提升自己。目标是想要成为大前端。 本人的邮箱: cch_it@sina.com 或者 cch_it@163.com 技术栈 h5+css3、jQuery、bootstrap vue node.js java 写过一年java 爱好: 看书，喜欢自己买实体书看，喜欢书的味道，还有把自己看完的书摆满书架的那种自豪感。喜欢的书的类型也没有太固定的，人物传记、嫌疑小说、短篇小说都挺喜欢。买书也没有特别挑，基本看到新出的书和感兴趣的或者书评不错的话都会想买。目前比较喜欢的作家是东野圭吾，我看他的第一部作品是《解忧杂货店》，然后陆陆续续看了他的成名作《嫌疑人x的献身》《白夜行》《放学后》《恶意》等等。他的最新作我也有在留意，有兴趣的话会考虑再入。 看电影，很平常也很普通的爱好，喜欢科幻片和喜剧片。 音乐。是周杰伦的歌迷。 玩游戏，大部分男同志都有的爱好。 喜欢唱、跳、rap((^▽^))。 技术领域:目前从事前端&amp;移动的开发工作，致力于web和移动端解决方案，对前端领域有浓厚的兴趣，喜欢尝试新技术。 本博客内文章可能总结于网络内容，如有侵权，请邮件联系本人删除。"},{"title":"categories","date":"2019-08-01T09:36:25.000Z","updated":"2019-08-01T15:18:57.562Z","comments":false,"path":"categories/index.html","permalink":"https://haoge744.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-01T15:21:15.000Z","updated":"2019-08-01T15:21:28.550Z","comments":false,"path":"tags/index.html","permalink":"https://haoge744.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue缓存问题","slug":"vue缓存问题","date":"2020-03-14T03:55:42.000Z","updated":"2020-01-27T12:32:02.000Z","comments":true,"path":"2020/03/14/vue缓存问题/","link":"","permalink":"https://haoge744.github.io/2020/03/14/vue%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"关于vue路由缓存问题之前在工作中遇到了个关于页面跳转相关的缓存问题，没想到解决起来意外的挺简单的。 需求是这样的，有个移动webApp，下面有4个tab可以切换，然后其中有个页面有个列表，在列表页点击某些功能可以跳转至页面B、页面C,页面C返回的时候列表不能刷新，滚动条需要在原来的位置，然而在C页面做了一些操作的时候是会影响列表项的值的，做了这些操作的话，返回列表页需要刷新数据。 我的解决方案当然是用keep-alive了，然后把他的includes绑定到状态中去，这样可以方便的进行增加、删除。然后在列表页面中添加路由守卫，当判断要跳转到B、C页面的时候，把当前页面添加到缓存中，如果在二级页面需要删除缓存，则在状态管理里把缓存删掉，这样回到列表页之后就会刷新了。 需要注意的是includes中使用的是组件的名称进行缓存的，所以组件的命名要规范，有语义，最好不要重复。","text":"关于vue路由缓存问题之前在工作中遇到了个关于页面跳转相关的缓存问题，没想到解决起来意外的挺简单的。 需求是这样的，有个移动webApp，下面有4个tab可以切换，然后其中有个页面有个列表，在列表页点击某些功能可以跳转至页面B、页面C,页面C返回的时候列表不能刷新，滚动条需要在原来的位置，然而在C页面做了一些操作的时候是会影响列表项的值的，做了这些操作的话，返回列表页需要刷新数据。 我的解决方案当然是用keep-alive了，然后把他的includes绑定到状态中去，这样可以方便的进行增加、删除。然后在列表页面中添加路由守卫，当判断要跳转到B、C页面的时候，把当前页面添加到缓存中，如果在二级页面需要删除缓存，则在状态管理里把缓存删掉，这样回到列表页之后就会刷新了。 需要注意的是includes中使用的是组件的名称进行缓存的，所以组件的命名要规范，有语义，最好不要重复。 在状态管理中添加缓存的状态和一些动作新建cache.js 12345678910111213141516171819202122import Vue from 'vue'const cache = &#123; state: &#123; cacheComps: [] // 缓存组件 &#125;, mutations: &#123; addCacheComp: (state, name) =&gt; &#123; if (!state.cacheComps.includes(name)) &#123; state.cacheComps.push(name) &#125; &#125;, removeCacheComp: (state, name) =&gt; &#123; const index = state.cacheComps.indexOf(name) console.log('index:' + index) if (index &gt; -1) &#123; Vue.set(state, 'cacheComps', state.cacheComps.splice(index, 1)) &#125; &#125; &#125;&#125;export default cache 添加路由守卫1234567891011121314beforeRouteLeave (to, from, next) &#123; // 缓存策略，当页面离开前判断 是不是以下几个路由，如果是，添加至状态，不是则清空 console.log(to) const cachePath = ['a','b'] const needCache = cachePath.some(item =&gt; to.path.indexOf(item) &gt;= 0) if (needCache) &#123; // 由于我是嵌套路由实现的tab 所以需要缓存父子的组件 this.$store.commit('addCacheComp', 'layout') this.$store.commit('addCacheComp','list') &#125; else &#123; this.$store.commit('removeCacheComp', 'layout') this.$store.commit('removeCacheComp','list') &#125; next()&#125; 适当情况下清空缓存在B或C页面做了某些提交操作，影响列表数据时需要删除缓存： 1234567commit()&#123; doCommit().then(() =&gt; &#123; // ... this.$store.commit('removeCacheComp', 'layout') this.$store.commit('removeCacheComp','list') &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vueTips","slug":"vueTips","date":"2020-01-25T12:42:02.000Z","updated":"2020-01-27T12:32:02.000Z","comments":true,"path":"2020/01/25/vueTips/","link":"","permalink":"https://haoge744.github.io/2020/01/25/vueTips/","excerpt":"前面发过一篇javascript的tips这次发布一些vue相关的,如果以后还有相关的会更新。 生命周期Tip:beforeCreate和created触发时，dom还不存在。服务端渲染时，beforeMount和mounted不会触发，因为服务端不会创建节点。renderError 渲染错误时触发 测试和正式环境可以使用errorCaptured来收集错误, 子组件会向父组件冒泡，一直冒到最上层(App.vue)。 watch深入观察对象/数组变化watch: { ‘obj.a’: // 监听对象中某个属性的变化。。 firstName: { handler(newName, oldNme){ this.fullName = newName + “ “ + this.lastName }, immediate: true, // 初始化就执行一次 deep: true // 深入观察，会观察对象或数组的变化 比如想监听对象中某一个属性的变化,开销大不推荐 }}","text":"前面发过一篇javascript的tips这次发布一些vue相关的,如果以后还有相关的会更新。 生命周期Tip:beforeCreate和created触发时，dom还不存在。服务端渲染时，beforeMount和mounted不会触发，因为服务端不会创建节点。renderError 渲染错误时触发 测试和正式环境可以使用errorCaptured来收集错误, 子组件会向父组件冒泡，一直冒到最上层(App.vue)。 watch深入观察对象/数组变化watch: { ‘obj.a’: // 监听对象中某个属性的变化。。 firstName: { handler(newName, oldNme){ this.fullName = newName + “ “ + this.lastName }, immediate: true, // 初始化就执行一次 deep: true // 深入观察，会观察对象或数组的变化 比如想监听对象中某一个属性的变化,开销大不推荐 }} 父组件和子/孙组件共享值provide的用法，本人不是很常用。 // 父组件export default { provide () { return { yeye: this } }} // 子组件export default { inject: [‘yeye’] mounted () { console.log(this.yeye) }} v-bind父组件 子组件this.$attrs 模板语法绑定属性时也可以使用模板语法:placeholder=”$attrs.disabled?’’:placeholder || 请输入${label}“事件传递 @change=”handler($event, 2)” Vue强制渲染this.$forceUpdate();进行强制渲染 Object.freeze()冻结对象如果你有一个巨大的数组或Object，并且确信数据不会修改，使用Object.freeze()可以让性能大幅提升。new Vue({ data: { // vue不会对list里的object做getter、setter绑定 list: Object.freeze([ { value: 1 }, { value: 2 } ]) }, mounted () { // 界面不会有响应 this.list[0].value = 100; // 下面两种做法，界面都会响应 this.list = [ { value: 100 }, { value: 200 } ]; this.list = Object.freeze([ { value: 100 }, { value: 200 } ]); }}) 跳转相同路由页面不刷新 (需要判断跳转其它路由的情况)watch: { ‘$route’: (to, from) { this.$router.go(0); }}, 事件绑定使用计算属性123456789101112131415161718&lt;template&gt; &lt;componentA v-bind&#x3D;&quot;$attrs&quot; :value&#x3D;&quot;value&quot; v-on&#x3D;&quot;bindListeners&quot;&gt; &lt;&#x2F;componentA&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123; computed: &#123; bindListeners() &#123; const events &#x3D; this.$attrs.listeners if (events &amp;&amp; Object.keys(events).includes(&#39;input&#39;)) &#123; this.$delete(events,&#39;input&#39;) &#125; return Object.assign(this.$listeners,events) &#125; &#125;&#125;&lt;&#x2F;script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"jsTips","slug":"jsTips","date":"2020-01-18T10:38:32.000Z","updated":"2020-01-18T10:38:32.000Z","comments":true,"path":"2020/01/18/jsTips/","link":"","permalink":"https://haoge744.github.io/2020/01/18/jsTips/","excerpt":"","text":"小本本记录了一些关于js的小tips，下面整理一下发出来，内容可能会有过时。 打印变量类型判断是否是对象 1Object.prototype.toString.call(obj) === '[object Object]' 判断变量是不是无穷的 1isFinite(val) 删除数组元素 12345678function remove (arr, item) &#123; if (arr.length) &#123; var index = arr.indexOf(item); if (index &gt; -1) &#123; return arr.splice(index, 1) &#125; &#125;&#125; replace高级应用及占位符_ 12345678910111213141516171819202122232425262728str.replace(/-(\\w)/g, function (_, c) &#123; return c ? c.toUpperCase() : ''; &#125;) str.replace(hyphenateRE, '-$1').toLowerCase(// 1.$i (i:1-99) : 表示从左到右正则子表达式所匹配的文本。 // 2.$&amp;:表示与正则表达式匹配的全文本。 // 3.$`(`:切换技能键)：表示匹配字符串的左边文本。 // 4.$'(‘:单引号)：表示匹配字符串的右边文本。// 5.$$：表示$转移。``` 5. // Firefox has a \"watch\" function on Object.prototype...火狐浏览器对象的原型链上都有watch函数6. void 0 得到纯正的undefined7. 常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate。而常见的 micro task 有 MutationObsever 和 Promise.then。8. DocumentFragment documentFragment的作用是创建临时的dom节点，当append的时候才真正渲染dom从而可以提升效率``` javascriptwindow.requestAnimationFrame(function()&#123; let fragment = document.createDocumentFragment(); for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement('li'); li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) loop(curTotal - pageCount,curIndex + pageCount) &#125;) 获取元素离顶部的距离 1document.getElementById('aa').getBoundingClientRect().top window.scrollY 页面滚动y距离 获取对象类型属性 12345const _toString = Object.prototype.toString function toRawType(value) &#123; return _toString.call(value).slice(8, -1) &#125;console.log(toRawType(&#123;&#125;))//Object 字符串占位符 12345678910111213141516171819202122232425262728String.prototype.format = function() &#123; if(arguments.length == 0) return this; var param = arguments[0]; var s = this; if(typeof(param) == 'object') &#123; for(var key in param) s = s.replace(new RegExp(\"\\\\&#123;\" + key + \"\\\\&#125;\", \"g\"), param[key]); return s; &#125; else &#123; for(var i = 0; i &lt; arguments.length; i++) s = s.replace(new RegExp(\"\\\\&#123;\" + i + \"\\\\&#125;\", \"g\"), arguments[i]); return s; &#125;&#125; var str = \"&#123;one&#125;&#123;two&#125;&#123;three&#125;\".format(&#123;one: \"1\",two: \"2\",three: \"3\"&#125;); //123var str2 = \"&#123;0&#125; &#123;1&#125; &#123;2&#125;\".format(\"how\",\"are\",\"you\"); //how are you``` 13. 如果需要在数组循环时跳出循环 推荐使用every函数而不是forEacth14. !! 的妙用如果需要判断一个对象是否是空 可以使用``` javascriptlet required = !!obj// 而不是if (obj) &#123; let required = true&#125; map使用await异步函数 123456789101112131415161718async onGetLocation(datas)&#123; let res = await Promise.all(datas.map(async (item) =&gt; &#123; return await this.convertFrom( [item.lon, item.lat]) &#125;)) this.setState(&#123; pathSimplifierData: res &#125;)&#125;convertFrom(point, type = 'gps') &#123; return new Promise((resolve, reject) =&gt; &#123; window.AMap.convertFrom(point,type, (status,result) =&gt; &#123; if(result.info === 'ok') &#123; resolve ( [result.locations[0].lng,result.locations[0].lat]) &#125; &#125;) &#125;)&#125; 是否js原生方法123function isNative(Ctor) &#123; return typeof Ctor === 'function' &amp;&amp; /native code/.test(Ctor.toString())&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"},{"name":"tips","slug":"tips","permalink":"https://haoge744.github.io/tags/tips/"}]},{"title":"css选择器的命名是一个哲学问题","slug":"css选择器的命名是一个哲学问题","date":"2020-01-05T13:56:03.000Z","updated":"2020-03-14T01:37:26.436Z","comments":true,"path":"2020/01/05/css选择器的命名是一个哲学问题/","link":"","permalink":"https://haoge744.github.io/2020/01/05/css%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%93%B2%E5%AD%A6%E9%97%AE%E9%A2%98/","excerpt":"以下内容摘抄、总结于《CSS选择器世界》 不推荐的命名方法根据单词命名:12345.title &#123;&#125;.red &#123;&#125;.box &#123;&#125;.success &#123;&#125;.red &#123;&#125; 以上命名虽然简短，语义也更易懂，但是重名频率太高，不推荐。 使用拼音命名12.cs-tou &#123;&#125;.cs-hezi &#123;&#125; 试用拼音虽然胜利，对功能也没有影响，但却是一个比较傻的行为，因为他会让人感觉你比较业余。你自己命名是省力了，但这样的命名对其他同事而言却苦不堪言，因为可读性较差。 使用id选择器1#box &#123;&#125; id选择器虽然性能很不错，可以和类选择器分庭抗礼，但是他存在以下两个巨大缺陷","text":"以下内容摘抄、总结于《CSS选择器世界》 不推荐的命名方法根据单词命名:12345.title &#123;&#125;.red &#123;&#125;.box &#123;&#125;.success &#123;&#125;.red &#123;&#125; 以上命名虽然简短，语义也更易懂，但是重名频率太高，不推荐。 使用拼音命名12.cs-tou &#123;&#125;.cs-hezi &#123;&#125; 试用拼音虽然胜利，对功能也没有影响，但却是一个比较傻的行为，因为他会让人感觉你比较业余。你自己命名是省力了，但这样的命名对其他同事而言却苦不堪言，因为可读性较差。 使用id选择器1#box &#123;&#125; id选择器虽然性能很不错，可以和类选择器分庭抗礼，但是他存在以下两个巨大缺陷 - 优先级太高，如果需要重置某些样式，必须要对id选择器选择覆盖，再多的类名都没有用，这会使得项目选择器的优先级变得非常混乱。如果非要使用元素的id选择器作为标识，可以用属性选择器替代:`[id=&quot;box&quot;]` - 和Javascript耦合,实际开发时，元素的ID主要用在Javascript中，以方便Dom元素快速获取它，如果ID同时和样式关联，它的可维护性会大打折扣，一旦ID变化，需要同时修改CSS和Javascript，然而实际上开发只会修改一处，这就是很多后期bug产生的原因。使用嵌套选择器以下选择器在项目中经常出现的: 12345.nav a &#123;&#125;.box &gt; div &#123;&#125;.avatar img &#123;&#125;.box .pic .icon &#123;&#125; 特别是在有了Scss、Less、Stylus之类的预编译工具出现后，5、6层嵌套的css选择器也大量出现，这太糟糕了！他们都是特别差的代码，其性质比Javascript使用全局变量还要糟。除了在书写时省电力其他全是缺点，包括: 渲染性能糟糕 优先级混乱 样式布局脆弱 1. 渲染性能糟糕过深的嵌套会对性能产生影响，因为每加深一层嵌套，浏览器在进行选择器匹配的时候回多一层计算，一两个嵌套对性能自然毫无影响，但是，如果数千行CSS都才用了多层嵌套，量变引起质变，此时，光CSS样式的解析就可以到达百毫秒级别。 2. 优先级混乱书写选择器尽量遵循一个原则，那就是尽可能保持比较低的优先级，这样方便以后以较低的成本重置一些样式。然而，一旦选择器开始嵌套，优先级规则就会变得复杂，当我们想要重置某些样式的时候，你会发现一个类名不管用，两个类名也不管用，打开控制台一看，你希望重置的样式居然有6个选择器依次嵌套。如: 1.layer_send_video_v3 .video_upbox dd .dd_succ .pic_default img &#123;&#125; 此时如果想要重置img的样式，只有这几种方法：1.使用同一优先级的选择器，但这个选择器的位置在需要重置的CSS代码后面；2.使用更深的层级，例如 使用7层选择器 这是最常用的方法 3. 使用Id选择器或者!important。他们都是很糟糕的解决方法。 3. 样式布局脆弱1.layer_end_video_v3 .video_upbox dd .dd_succ .pic_default img &#123;&#125; 在实际开发维护的过程中，调整HTML标签是非常常见的事情，例如，将元素换成语义更好的。但是如果使用的是dd和img选择器,HTML标签是不能换的,因为如果标签换了，整个样式都会无效，你必须去CSS文件中找到对应的标签选择器进行同步修改，维护成本巨大。 推荐的命名方法使用类选择器不要使用以下的嵌套选择器和标签选择器了: 1234567&lt;nav class=\"nav\"&gt; &lt;a&gt;链接1&lt;/a&gt; &lt;a&gt;链接2&lt;/a&gt; &lt;a&gt;链接3&lt;/a&gt;&lt;/nav&gt;.nav &#123;&#125;.nav a &#123;&#125; 请换成: 1234567&lt;nav class=\"cs-nav\"&gt; &lt;a class=\"cs-nav-a\"&gt;链接1&lt;/a&gt; &lt;a class=\"cs-nav-a\"&gt;链接2&lt;/a&gt; &lt;a class=\"cs-nav-a\"&gt;链接3&lt;/a&gt;&lt;/nav&gt;.cs-nav &#123;&#125;.cs-nav-a &#123;&#125; 好的命名方法CSS命名结构我们使用一些第三方UI时可以看到别人会以项目名开头去命名css，比如element-ui以el开头,vant-ui使用van开头等等，这种命名方式有效的防止了和我们自己书写的css命名冲突的问题。所以我们也可以效仿。以项目名或者公司名来开头。比如以下格式: 12projectname-module-titlebusiness-module-footer 示例: 1234.cs-shop-panel-header&#123;&#125;.cs-shop-panel-header-title&#123;&#125;.cs-dialog-header&#123;&#125;.cs-dialog-footer&#123;&#125; 不要歧视使用面向属性的命名不少开发者是不认可下面这种基于css属性本身的命名方式的，尤其是Web标准刚兴起的那段时期。 123456789.dn &#123;display: none;&#125;.db &#123;display: block;&#125;.dib &#123;display: inline-block;&#125;....ml20 &#123;margin-left:20px;&#125;....vt &#123;vertial-align: top;&#125;.text-ell &#123;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;&#125;... 为什么呢?因为这类命名本质上和html元素上写style属性没有什么不同。 1&lt;span style=\"display:inline-block;margin-left:20px\"&gt;文字&lt;/span&gt; 效果是一样的，只是前者在书写上更为简洁，优先级更低。 但是我们需要调整样式的时候，改动的是HTML，而非CSS，这不等于HTML和CSS耦合在一起了吗。于是很多人就接受不了了，尤其在推崇内容和样式分离的年代。我们做技术，一定要保持理性，要有自己的思考，最合适的才是最好的。技术的发展也想流行趋势一样是一个圈，转了一圈又回来了。随着React等框架的星期，”CSS in JavaScript”的概念居然也出现了(类似styled-components)。 在某个很深的角落里里有一张图片，你希望这张图片的display设置为block,就算你专门给他命名一个语义化的CSS也没有意义。 1.pic_default_img &#123;display:block;&#125; 类名的意义在于重复利用，如果他只是为了解决某一个单独的问题，那么还不如写style内联样式。 正确使用状态类名页面的交互总是伴随着各种状态变化，包括禁用状态、选中状态、激活状态等 123.cs-content.active&#123;&#125;.cs-check-item.checked&#123;&#125;.cs-input-item.disabled&#123;&#125; .active类名本身没有样式，就是一个状态标识符，用来与其他类名发生关系，让其他类名的样式发生变化。并且与JavaScript代码逻辑分离，可以有效降低日后维护成本。可读性强。 最佳实践1. 命名书写(1) 命名建议小写，使用英文单词或缩写，对于专有名词，可以使用拼音，例如: 1.cs-logo-youku &#123;&#125; 不建议使用驼峰命名，驼峰命名建议专门给JavaScript DOM用，以便和CSS样式类名区分开。 1.csLogoYouku&#123;&#125; /* 不建议 */ (2) 对于组合命名，可以短横线或下划线连接，可以组合使用短横线和下划线，也可以连续短横线或下划线连接，任何方式都可以，只要在项目中保持一致就可以: 1234.cs-logo-youku &#123;&#125;.cs_logo_youku &#123;&#125;.cs-logo--youku &#123;&#125;.cs-logo__youku &#123;&#125; 组合格式没有必要超过5个，5个是极限。 (3) 设置统一前缀，强化品牌同时避免样式冲突: 123.cs-header &#123;&#125;.cs-log &#123;&#125;.cs-logo-a &#123;&#125; 这样，CSS代码的美观度也会提升很多 2. 选择器类型根据选择器的使用类型，我将网站CSS分成3个部分，分别是CSS重置样式，CSS基础样式和CSS交互变化样式。 无论那种样式都不推荐使用ID选择器，实在要用，使用属性选择器代替，他的优先级和类选择器一模一样。 1[id=\"someId\"] &#123;&#125; CSS样式的重置可以使用标签选择器或者属性选择器: 1234567body,p &#123;margin:0;&#125;[type=\"radio\"],[type=\"checkbox\"] &#123; position:absolute; clip: rect(0 0 0 0)&#125; 所有CSS基础样式全部使用类选择器，没有层级，没有标签。 12.cs-module .img &#123;&#125; /* 不推荐*/.cs-module-ul &gt; li &#123;&#125; /* 不推荐*/ 在所有HTML的标签上都写上不会冲突的类名 12.cs-module-img &#123;&#125;.cs-module-li &#123;&#125; 所有HTML都需要重新命名的问题可以通过面向属性命名的CSS样式库得到解决。 所有选择器嵌套或者级联，所有的伪类全部都在CSS交互样式发生变化的时候使用。例如: 123456.cs-content.active&#123; height: auto;&#125;.active &gt; .cs-content-more&#123; display: none;&#125; 例如 123456.cs-button:active&#123; filter: hue-rotate(5deg);&#125;.cs-input:focus &#123; border-color: var(--blue);&#125; 状态类名本身不包含任何CSS样式，他就是一个标识符。 如果我们无法修改HTML。例如无法通过修改class属性添加新的类名，则级联、嵌套，以及各种高级伪类的使用都不受上面使用规则的限制。 再和目前很多人的实现对比一下，最佳实践的不同之处在于： 无标签，无层级； 状态类名标识符； 面向属性命名的CSS样式库。","categories":[{"name":"css","slug":"css","permalink":"https://haoge744.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://haoge744.github.io/tags/css/"}]},{"title":"nginx部署vue项目及配置路由模式","slug":"nginx部署vue项目及配置路由模式","date":"2020-01-02T15:10:31.000Z","updated":"2020-01-27T15:32:49.181Z","comments":true,"path":"2020/01/02/nginx部署vue项目及配置路由模式/","link":"","permalink":"https://haoge744.github.io/2020/01/02/nginx%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"vue的默认路由模式采用的是hash模式，使用URL的hash值来模拟路径，于是url改变时，页面不会重载。如果不想要很丑的#号，可以使用路由的history模式,但是部署至服务器后，刷新页面会404找不到页面。原因是浏览器刷新后根据路由的地址是找不到相关资源的，所以我们要给服务器设置相关配置。 警告正确的做法是给服务器设置把所有相关请求都转发到对应的index.html页面就可以了，但是也有个注意的地方，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。 123456const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;)","categories":[{"name":"nginx","slug":"nginx","permalink":"https://haoge744.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://haoge744.github.io/tags/nginx/"}]},{"title":"vue cli2.x及3.x多环境打包配置","slug":"vue-cli2-x及3-x多环境打包配置","date":"2019-12-28T09:23:38.000Z","updated":"2019-12-28T15:52:07.056Z","comments":true,"path":"2019/12/28/vue-cli2-x及3-x多环境打包配置/","link":"","permalink":"https://haoge744.github.io/2019/12/28/vue-cli2-x%E5%8F%8A3-x%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/","excerpt":"前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。 俗话说懒是程序员三大美德之一，我们不希望每次切换环境都修改参数,我们希望的效果是:每次构建时传入不同的参数来访问不同环境的全局变量。","text":"前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。 俗话说懒是程序员三大美德之一，我们不希望每次切换环境都修改参数,我们希望的效果是:每次构建时传入不同的参数来访问不同环境的全局变量。 vue cli2.x的配置vue cli2.x的配置对比3.x来说复杂一点，因为2.x中默认使用的是webpack3.x,配置项比较多。没有webpack4那么简洁。如果你当前的项目没有安装cross-env需要安装一下: 1npm install cross-env --save-dev 假设我们除了生产环境还需要增加一个测试环境test和预生产环境pre-prod。并且每种环境的后台调用的api接口地址不一样。 一. config目录中复制两个prod.env.js 分别修改为test.env.js和pre.prod.env.js1234567// test.env.js'use strict'module.exports = &#123; NODE_ENV: '\"production\"', BASE_API: '\"http://test.api.com\"', ENV_CONFIG: '\"test\"'&#125; 1234567// pre.prod.env.js'use strict'module.exports = &#123; NODE_ENV: '\"production\"', BASE_API: '\"http://pd.api.com\"', ENV_CONFIG: '\"pre-prod\"'&#125; 修改prod.env.js: 123456'use strict'module.exports = &#123; NODE_ENV: '\"production\"', BASE_API: '\"http://prod.api.com\"', ENV_CONFIG: '\"prod\"' // 设置这个参数对打包没有影响，它的作用是方便访问当前是什么环境&#125; 二. 修改 build/webpack.prod.conf.js12345678const envConfigMap = &#123; 'prod': require('../config/prod.env'), 'test': require('../config/test.env'), 'pre-prod': require('../config/pre.prod.env')&#125;// const env = require('../config/prod.env')const env = envConfigMap[process.env.ENV_CONFIG] || require('../config/prod.env') 三. 修改package.json中的脚本命令12345678910&#123; //... \"scripts\": &#123; // ... // ENV_CONFIG的变量要和上面map中的一致 \"build\": \"cross-env ENV_CONFIG=prod node build/build.js\", \"build--test\": \"cross-env ENV_CONFIG=test node build/build.js\", \"build--pre-prod\": \"cross-env ENV_CONFIG=pre-prod node build/build.js\" &#125;,&#125; 四. 修改build/build.js 添加打包环境提示1const spinner = ora('正在打包...' + process.env.ENV_CONFIG + '环境') 五. 运行命令实现打包123npm run buildnpm run build--testnpm run build--pre-prod 六. 测试运行 npm run build--pre-prod在初始化时打印process.env环境变量,可以看到读取到的配置文件是匹配上的。 vue cli3.x的配置vue-cli3.0之后默认没有提供开发和生产环境的全局变量，需要自己新建。 配置开发、生产环境变量 123// 项目根目录新建 '.env.development' 文件# api地址VUE_APP_BASE_API = '/development/api' 123// 项目根目录新建 '.env.production' 文件# api地址VUE_APP_BASE_API = '/production/api' 代码中使用process.env.VUE_APP_BASE_API去访问它们 注意: 只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。 自定义模式假如我们要创建一个预演的环境需要另外一套参数配置,比如说叫做staging。 在package.json中添加一个命令(也可以在启动时添加 —mode参数) 12345678910\"scripts\": &#123; \"scripts\": &#123; \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", // 启动本地环境 \"staging\": \"vue-cli-service serve --mode staging\" // 打包 \"build-staging\": \"vue-cli-service build --mode staging\" &#125;, 注意:创建 .env.staging, 文件后缀需要与 --mode 后面跟的值一样 12NODE_ENV &#x3D; &#39;production&#39;VUE_APP_BASE_API &#x3D; &#39;&#x2F;staging&#x2F;api&#39; 如果需要再增加配置的话只需要增加一行命令，然后新建一个.env.xxx的文件就ok了，是不是比老版本方便很多呢。 关于环境变量和模式的更多配置信息可以访问官方介绍文档","categories":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/categories/webpack/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/tags/webpack/"},{"name":"前端构建化","slug":"前端构建化","permalink":"https://haoge744.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%8C%96/"}]},{"title":"Notification的使用","slug":"Notification的使用","date":"2019-12-22T13:12:53.000Z","updated":"2019-12-22T14:52:12.040Z","comments":true,"path":"2019/12/22/Notification的使用/","link":"","permalink":"https://haoge744.github.io/2019/12/22/Notification%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"最近注意到一些网站上渐渐会弹出一个框，提示你是否显示通知，这也意味着这项功能以后会越来越普遍了，像微博、邮箱、爱奇艺等网站已经开始用起来了，如果点击同意显示通知的话，那么前台可能会开启MQ或者使用轮询的方式，去获取你关注的人或者视频有没有更新，如果有则弹起通知，更加提高了用户的体验性。其实有关于通知的相关api之前也有了解过，但是并不深入，今天学习后总结一下，以便自己加深影响。","text":"最近注意到一些网站上渐渐会弹出一个框，提示你是否显示通知，这也意味着这项功能以后会越来越普遍了，像微博、邮箱、爱奇艺等网站已经开始用起来了，如果点击同意显示通知的话，那么前台可能会开启MQ或者使用轮询的方式，去获取你关注的人或者视频有没有更新，如果有则弹起通知，更加提高了用户的体验性。其实有关于通知的相关api之前也有了解过，但是并不深入，今天学习后总结一下，以便自己加深影响。 基础介绍构造方法1let notification = new Notification(title, options) 调用new Notification()之后windows就会弹出一个框，他的参数有以下这些: title通知的标题。 options 可选 dir: 文字的方向.它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左） lang: 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。 body: 通知中额外显示的字符串 tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。 icon: 一个图片的URL，将被用于显示通知的图标。 属性 Notification.permission 只读属性，用于读取用户是否授权显示通知，可能的值包括: denied (用户拒绝显示);granted(用户允许显示通知);default(未询问过用户，这种状态浏览器也会拒绝显示通知). Notification.title只读属性, 在构造方法中传入的title参数 notification.dir 只读属性,文本显示方向 notification.lang 只读属性,通知的语言 notification.body只读属性,通知中额外显示的字符串 Notification.icon 显示的图标图片的url地址 事件处理 Notification.onclick 处理 click 事件的处理。每当用户点击通知时被触发。 Notification.onshow 处理 show 事件的处理。当通知显示的时候被触发。 Notification.onerror 处理 error 事件的处理。每当通知遇到错误时被触发。 Notification.onclose 处理 close 事件的处理。当用户关闭通知时被触发。 方法静态方法 Notification.requestPermission(callback) 请求用户是否显示通知,传入一个回调函数，回调函数参数的值为denied 和granted 实例方法 Notification.close() 用于手动关闭通知 Notification.addEventListener() 添加事件监听 Notification.removeEventListener() 移除事件监听 EventTarget.DispatchEvent 手动触发事件 案例12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt;window.onload = () =&gt; &#123; showNotify(\"Hello 你好\", &#123; dir: 'auto', lang: 'zh_CN', data: &#123;a: 'ss'&#125;, body: '你的xxx更新了,快去瞧瞧吧！', icon: 'https://developer.mozilla.org/static/img/favicon32.7f3da72dcea1.png' &#125;).then( notifyInstance =&gt; &#123; notifyInstance.onclick = (e) =&gt; &#123; console.log('通知被点击了' + e.target) &#125; notifyInstance.onshow = (e) =&gt; &#123; console.log('通知被显示了' + e.target.data) &#125; notifyInstance.onerror = (e) =&gt; &#123; console.log('通知异常' + e) &#125; notifyInstance.onclose = (e) =&gt; &#123; console.log('通知被关闭' + e) &#125; &#125;)&#125;// 发送通知function showNotify (title, options) &#123; return new Promise((resolve, reject) =&gt; &#123; if (!(\"Notification\" in window)) &#123; reject('Your browser does not support desktop Notification') &#125; if (Notification.permission === 'granted') &#123; // 如果用户已经同意显示通知，直接显示 resolve(new Notification(title, options)) &#125; else if (Notification.permission === 'default') &#123; Notification.requestPermission((permission) =&gt; &#123; if (permission === 'granted') // 用户同意 resolve(new Notification(title, options)) else reject() &#125;) &#125; &#125;) &#125;&lt;/script&gt; 在调试中发现options还可以传入一个参数data,有了这个data属性可以方便我们做点击通知后的处理事件了。不知道为什么MDN中的api并没有说这个参数。MDN文档还有一点就是Notifiction在服务器下的页面才有用,像file:///这样双击打开的是不能弹出通知来的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"}]},{"title":"vue使用jsx","slug":"vue使用jsx","date":"2019-12-14T04:05:31.000Z","updated":"2020-03-14T05:30:42.172Z","comments":true,"path":"2019/12/14/vue使用jsx/","link":"","permalink":"https://haoge744.github.io/2019/12/14/vue%E4%BD%BF%E7%94%A8jsx/","excerpt":"实际上，如果是要编写一些复杂和好用的组件，vue的render会经常出现,例如element的el-tree和el-tabs里面就用到了。有时间想写一些关于element的源码解析的文章，他们的组件写的很出色。之前写过一篇关于vue render函数的相关文章,今天写一篇关于jsx在vue的应用场景及实战。","text":"实际上，如果是要编写一些复杂和好用的组件，vue的render会经常出现,例如element的el-tree和el-tabs里面就用到了。有时间想写一些关于element的源码解析的文章，他们的组件写的很出色。之前写过一篇关于vue render函数的相关文章,今天写一篇关于jsx在vue的应用场景及实战。 使用场景目前vue-cli3.0构建的项目是默认支持jsx语法的，如果是2.x的项目，可能需要调整下.babelrc,jsx的使用场景，目前我知道的只有两个，一个是当组件参数传过去，一个就是写render方法。 例如使用el-tree的时候可以传一个render-content参数来手动渲染，或者其他渲染比较复杂的时候，jsx是扩展性更好的方案。 如果在写render函数的时候,组件、参数比较多的情况下，会发现整个函数写的很长，并且很难维护，这时候使用jsx更加简单直观，并且更利于维护 实际运用参数使用jsx上期我写了一篇文章封装了一个菜单栏，其中有一个参数使用了render函数,接下来把它改为jsx的写法我的上期文章 1234567891011121314151617181920212223export default &#123; data() &#123; return &#123; menuList: [&#123; key: 'home', name: '首页', content_render: (h,item) =&gt; &#123; // console.log(h,item) // return h('span', [ // 使用函数的写法 // h('span', &#123;class: 'el-icon-location'&#125;), // item.name // ]) return &lt;span&gt; &lt;span class=\"el-icon-location\"&gt;&lt;/span&gt; &lt;span&gt;&#123;item.name&#125;&lt;/span&gt; &lt;/span&gt; &#125; // ... ] &#125; &#125;&#125; 实战中使用之前在项目中根据el-table再封装了一下，把分页给封装了进去，并且会自动计算屏幕剩余高度，避免出现屏幕滚动条。这个组件的难点在于如何适配多表头，如果没有多表头的情况下，使用template封装就可以满足,如果要适配多表头,那么要不使用组件递归，要么使用render函数，在函数里面递归，我自然是不想使用组件递归的了，是使用jsx完成了render函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144export default &#123; name: 'dataTable', props: &#123; head: &#123; type: Array, required: true &#125;, tableData: &#123; // 表格数据 type: Array, default: () =&gt; [] &#125;, showNumber: &#123; type: Boolean, default: () =&gt; true &#125;, paging: &#123; // 是否显示分页 type: Boolean, default: () =&gt; true &#125;, pageProps: &#123; type: Object, default: () =&gt; &#123; return &#123; pageNum: 1, pageSize: 10, total: 0&#125; &#125; &#125;, height: &#123; type: String, default: 'auto' &#125; &#125;, data() &#123; return &#123; tableHeight: 500 &#125; &#125;, render(h) &#123; const _this = this // 渲染表格列 function renderCol(cols) &#123; return ( cols.map((item, index) =&gt; &#123; &#123;/* 是否有子节点， 有的话递归渲染 el-table-column组件 */&#125; return !item.hasOwnProperty('children') || item.children.length === 0 ? &lt;el-table-column prop=&#123;item.prop&#125; &#123;/* v-bind=\"item\" 代替成 &#123;...&#123;attrs: item&#125;&#125; */&#125; &#123;...&#123;attrs: item&#125;&#125; label=&#123;item.label || item.prop&#125; &#123;/* 这一点有点复杂 渲染一个作用域插槽，如果列的type属性不为'slot'或者没有传递item.prop的作用域具名插槽那么直接渲染当前表格的值 否则渲染具名作用域插槽 */&#125; scopedSlots = &#123;&#123;default: (scope) =&gt; ( item.type !== 'slot' || !_this.$scopedSlots[item.prop] ? &lt;span&gt;&#123;scope.row[scope.column.property]&#125;&lt;/span&gt; : _this.$scopedSlots[item.prop](&#123; data: scope.row &#125;) ) &#125;&#125; &gt; &lt;/el-table-column&gt; : &#123;/* 渲染多表头 */&#125; &lt;el-table-column align=\"center\" label=&#123;item.label || item.prop&#125;&gt; &#123; renderCol(item.children)&#125; &lt;/el-table-column&gt; &#125;) ) &#125; return ( &lt;div&gt; &lt;el-table height=&#123;this.getTableHeight&#125; ref=\"dataTable\" &#123;...&#123;attrs: this.$attrs&#125;&#125; data=&#123;this.tableData&#125; style=\"width: 100%\" border&gt; &#123; this.showNumber ? &lt;el-table-column type=\"index\" align=\"center\" label=\"序号\" width=\"50\"&gt; &lt;/el-table-column&gt; : '' &#125; &#123; /* 把传过来的head参数用上面定的方法进行渲染 */ renderCol(this.head) &#125; &lt;/el-table&gt; &#123; this.paging ? &lt;el-pagination class=\"pagin-wrapper\" ref=\"pagination\" current-page=&#123;this.pageProps.pageNum&#125; page-size=&#123;this.pageProps.pageSize&#125; total=&#123;this.pageProps.total&#125; pager-count=&#123;5&#125; page-sizes=&#123;[5,10,20,50]&#125; layout=\"total, sizes, prev, pager, next, jumper\" on-size-change=&#123;this.pageSizeChangHandler&#125; on-current-change=&#123;this.pageChangeHandler&#125;/&gt; : '' &#125; &lt;/div&gt; ) &#125;, methods: &#123; pageSizeChangHandler (val) &#123; this.$emit('sizeChanged', val) &#125;, pageChangeHandler (val) &#123; this.$emit('pageChanged', val) &#125;, doLayout () &#123; this.$refs.dataTable.doLayout() &#125;, computedHeight () &#123; if (this.$refs.dataTable.$el) &#123; const top = this.$refs.dataTable.$el.getBoundingClientRect().top const pageHeight = this.paging ? this.$refs.pagination.$el.offsetHeight : 0 this.tableHeight = document.body.clientHeight - top - pageHeight - 48 + 'px' &#125; &#125; &#125;, updated() &#123; this.$nextTick(() =&gt; &#123; this.doLayout() &#125;) &#125;, computed: &#123; getTableHeight() &#123; if (this.height === 'auto') &#123; return this.tableHeight &#125; else if (this.height) &#123; return this.height &#125; else &#123; return null &#125; &#125;, &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this.computedHeight() &#125;) &#125;&#125; 比较难的一部分，在renderCol方法那里，至于jsx绑定数据和绑定事件都是用花括号比较简单。使用组件: 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;!-- ... --&gt; &lt;dataTable :head&#x3D;&quot;head&quot; :tableData&#x3D;&quot;tableData&quot; @sizeChanged&#x3D;&quot;sizeChanged&quot; @pageChanged&#x3D;&quot;pageChanged&quot; :pageProps&#x3D;&quot;pageForm&quot;&gt; &lt;template v-slot:rate&#x3D;&quot;&#123;data&#125;&quot;&gt; &#123;&#123; data.rate ? (data.rate * 100).toFixed(2) + &#39;%&#39; : &#39;-&#39; &#125;&#125; &lt;&#x2F;template&gt; &lt;&#x2F;dataTable&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;ffff&#39;, mixins: [dataTableMixin], components: &#123; dataTable, card &#125;, data() &#123; return &#123; tableData: [], head: [&#123; prop: &#39;name&#39;, label: &#39;xxx&#39;, align: &#39;center&#39;, &#125;, &#123; prop: &#39;rate&#39;, label: &#39;占比&#39;, align: &#39;center&#39;, type: &#39;slot&#39; &#125; ] &#125;&#125;&lt;&#x2F;script&gt; 至此已经对jsx封装组件有一定经验了，以后封装组件更有自己的想法。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"},{"name":"jsx","slug":"jsx","permalink":"https://haoge744.github.io/tags/jsx/"}]},{"title":"vue全局注册filters骚操作","slug":"vue全局注册filters骚操作","date":"2019-12-07T11:22:03.000Z","updated":"2019-12-07T11:22:03.000Z","comments":true,"path":"2019/12/07/vue全局注册filters骚操作/","link":"","permalink":"https://haoge744.github.io/2019/12/07/vue%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8Cfilters%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"注册全局Filters骚操作123456789101112131415161718192021222324252627282930313233// 新建 src/filters/index.jsconst filtersMap = &#123; dateFormatter: function (date, fmtExp) &#123; if (!date) return '-' var date = new Date(date) var o = &#123; \"M+\": date.getMonth() + 1, //月份 \"D+\": date.getDate(), //日 \"h+\": date.getHours(), //小时 \"m+\": date.getMinutes(), //分 \"s+\": date.getSeconds(), //秒 \"q+\": Math.floor((date.getMonth() + 3) / 3), //季度 \"S\": date.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmtExp))&#123; fmtExp = fmtExp.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length)); console.log(fmtExp); &#125; for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmtExp)) fmtExp = fmtExp.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmtExp; &#125;&#125;export default (Vue) =&gt; &#123; for(key in filtersMap) &#123; Vue.filter(key, filtersMap[key]) &#125;&#125;","text":"注册全局Filters骚操作123456789101112131415161718192021222324252627282930313233// 新建 src/filters/index.jsconst filtersMap = &#123; dateFormatter: function (date, fmtExp) &#123; if (!date) return '-' var date = new Date(date) var o = &#123; \"M+\": date.getMonth() + 1, //月份 \"D+\": date.getDate(), //日 \"h+\": date.getHours(), //小时 \"m+\": date.getMinutes(), //分 \"s+\": date.getSeconds(), //秒 \"q+\": Math.floor((date.getMonth() + 3) / 3), //季度 \"S\": date.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmtExp))&#123; fmtExp = fmtExp.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length)); console.log(fmtExp); &#125; for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmtExp)) fmtExp = fmtExp.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmtExp; &#125;&#125;export default (Vue) =&gt; &#123; for(key in filtersMap) &#123; Vue.filter(key, filtersMap[key]) &#125;&#125; 在main.js中使用: 123import Vue from Vueimport filters from './filters'Vue.use(filters) 使用require.context动态注册上面的方法有个缺点就是如果filter方法数量太多的话，js代码会很长，不易于维护，如果多的话也可以用js来划分不同的模块，然后使用webpack的require.contextapi自动导入，而不需要手动的import。首先在filters文件夹下创建modules文件夹然后根据需要创建对应的js文件，比如这样: 里面的js都导出一个对象 index.js写好自动导出的代码: 1234567891011const modules = require.context('./modules', true, /\\.js$/)let filters = modules.keys().reduce((prev, key) =&gt; &#123; return Object.assign(prev,modules(key).default)&#125;, &#123;&#125;)export default (Vue) =&gt; &#123; for(let key in filters) &#123; Vue.filter(key, filters[key]) &#125;&#125; 使用方法直接Vue.use即可 关于require.context()目前了解的不深，不作太多讲解。以后会专门写一篇文章总结它。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue渲染函数render","slug":"vue渲染函数render","date":"2019-12-04T12:24:03.000Z","updated":"2019-12-04T12:24:03.000Z","comments":true,"path":"2019/12/04/vue渲染函数render/","link":"","permalink":"https://haoge744.github.io/2019/12/04/vue%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0render/","excerpt":"Vue Render函数基础render函数即渲染函数，它的的参数为createElement，也是个函数，它的返回值为VNode, render函数必须返回一个VNode对象。 createElement的参数: 标签名、组件选项对象。必填。类型:{String | Object | Function} 为node添加属性的数据对象。非必填。类型:{Object} 子级虚拟节点，由 createElement()构建而成，也可以直接使用字符串。类型: {String | Array} createElement()的返回值是VNode对象，而且render()需要返回的正是VNode对象。","text":"Vue Render函数基础render函数即渲染函数，它的的参数为createElement，也是个函数，它的返回值为VNode, render函数必须返回一个VNode对象。 createElement的参数: 标签名、组件选项对象。必填。类型:{String | Object | Function} 为node添加属性的数据对象。非必填。类型:{Object} 子级虚拟节点，由 createElement()构建而成，也可以直接使用字符串。类型: {String | Array} createElement()的返回值是VNode对象，而且render()需要返回的正是VNode对象。 深入数据对象在模板中我们给组件设置一些参数、响应事件 一般使用的是 v-bind:或者v-on开头的语法,但在render函数中它们都变成了一个个的属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; // 与 `v-bind:class` 的 API 相同， // 接受一个字符串、对象或字符串和对象组成的数组 'class': &#123; foo: true, bar: false &#125;, // 与 `v-bind:style` 的 API 相同， // 接受一个字符串、对象，或对象组成的数组 style: &#123; color: 'red', fontSize: '14px' &#125;, // 普通的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 prop props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器在 `on` 属性内， // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。 // 需要在处理函数中手动检查 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽的格式为 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其它组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其它特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中给多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 官方示例如果封装一个组件，根据传入的level来决定渲染h1~h6的标题元素，那么用模板代码太冗余，尝试使用render函数效果会好很多: 1234567891011121314export default &#123; props: &#123; level: &#123; type: Number, default: () =&gt; 1 &#125; &#125;, render (h) &#123; return h( 'h'+ this.level, // 标签名称 this.$slots.default // 子节点数据 ) &#125;&#125; 实际运用比如我们要在element-ui基础上封装一个导航组件，根据传入的菜单数据生成菜单像这样: 如果说没有子菜单还好，有子菜单的话就必须要拆成两个组件了，然后递归循环了，可是我并不像那样，这个时候使用render函数就可以避免。 直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 新建 /components/navMenu/index.jsexport default &#123; name: 'navMenu', props: &#123; menuList: &#123; type: Array, required: true &#125; &#125;, created() &#123; &#125;, render (h) &#123; const _this = this // 渲染子菜单的方法 function renderSubItem(list, h) &#123; return list.map(item =&gt; &#123; // 判断有没有children属性 如果没有直接渲染el-menu-item组件 if (!item.hasOwnProperty('children') || item.children.length === 0) &#123; return h('el-menu-item', &#123; props: &#123; index: item.key, ...item &#125;, key: item.key &#125;, item.name ) &#125; else &#123; // 有子节点的情况渲染el-submenu节点 并且给一个具名插值'title' return h('el-submenu', &#123; props: &#123; index: item.key, ...item // 属性扩展符可以把属性自动设置成组件的参数 &#125;, key: item.key &#125;, [ h('template', &#123; slot: 'title' &#125;,item.name), // 递归渲染子节点 ...renderSubItem(item.children, h) ] ) &#125; &#125;) &#125; // 首先渲染外部的el-menu节点 参数和事件使用$attrs和$listeners传递 return h('el-menu', &#123; props: &#123; ...this.$attrs &#125;, on: &#123; ...this.$listeners &#125; &#125;, [ ...renderSubItem(this.menuList, h) ]) &#125;&#125; 使用: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;navMenu background-color&#x3D;&quot;#545c64&quot; text-color&#x3D;&quot;#fff&quot; active-text-color&#x3D;&quot;#ffd04b&quot; mode&#x3D;&quot;horizontal&quot; :menuList&#x3D;&quot;menuList&quot;&gt;&lt;&#x2F;navMenu&gt;&lt;&#x2F;template&gt;&lt;script&gt;import navMenu from &#39;@&#x2F;components&#x2F;navMenu&#x2F;index.js&#39;export default &#123; name: &#39;home&#39;, components: &#123; navMenu &#125;, data() &#123; return &#123; menuList: [&#123; key: &#39;home&#39;, name: &#39;首页&#39;, content_render: (h,item) &#x3D;&gt; &#123; &#x2F;&#x2F; console.log(h,item) return &lt;span&gt;&#123;item.name&#125;&lt;&#x2F;span&gt; &#125;, &#125;,&#123; key: &#39;categories&#39;, name: &#39;web前端&#39;, children: [&#123; key: &#39;book&#39;, name: &#39;书籍&#39;, &#125;,&#123; key: &#39;tools&#39;, name: &#39;工具&#39;, &#125;,&#123; key: &#39;javascript&#39;, name: &#39;javascript&#39;, &#125;,&#123; key: &#39;vue&#39;, name: &#39;vue&#39;, &#125;,&#123; key: &#39;css&#39;, name: &#39;css&#39;, children: [&#123; key: &#39;css3&#39;, name: &#39;css3&#39;, &#125;,&#123; key: &#39;stylus&#39;, name: &#39;stylus&#39;, &#125;,&#123; key: &#39;scss&#39;, name: &#39;scss&#39;, &#125;] &#125;] &#125;,&#123; key: &#39;dashboard&#39;, name: &#39;控制面板&#39;, children: [&#123; key: &#39;ip&#39;, name: &#39;域名管理&#39; &#125;,&#123; key: &#39;server&#39;, name: &#39;服务器管理&#39; &#125;] &#125;,&#123; key: &#39;about&#39;, name: &#39;关于&#39; &#125;] &#125; &#125;&#125;&lt;&#x2F;script&gt; 使用效果: 还是有点瑕疵，菜单没有图标，我理想的状态是能够使用插槽并且设置图标。所以需要把这个功能加上。我的想法是每个菜单item可以提供一个content_render方法，这个方法的参数为(h,item)，这个方法的返回值需要为VNode。这样就可以实现相同的效果辣。 修改一下renderSubItem()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function renderSubItem(list, h) &#123; return list.map(item =&gt; &#123; if (item.hasOwnProperty('content_render') &amp;&amp; item.content_render) &#123; console.log(item.content_render(h,item)) &#125; if (!item.hasOwnProperty('children') || item.children.length === 0) &#123; return h('el-menu-item', &#123; props: &#123; index: item.key, ...item &#125;, key: item.key &#125;, // 使用三目运算符判断菜单项是否有渲染函数 [item.content_render ? h('template', &#123; slot: 'title', &#125;, [item.content_render(h,item)]) : h('template', &#123; slot: 'title', &#125;, [item.name]) ] ) &#125; else &#123; return h('el-submenu', &#123; props: &#123; index: item.key, ...item &#125;, key: item.key &#125;, [ // 使用三目运算符判断菜单项是否有渲染函数 item.content_render ? h('template', &#123; slot: 'title', &#125;, [item.content_render(h,item)]) : h('template', &#123; slot: 'title', &#125;, [item.name]), ...renderSubItem(item.children, h) ] ) &#125; &#125;) &#125; 然后修改data中绑定的值: 123456789101112131415161718export default &#123; data() &#123; return &#123; menuList: [&#123; key: 'home', name: '首页', content_render: (h,item) =&gt; &#123; // console.log(h,item) return h('span', [ h('span', &#123;class: 'el-icon-location'&#125;), item.name ]) &#125; // ... ] &#125; &#125;&#125; 效果: 如果觉得上面content_render写法太复杂也可以改成下面jsx的方法实现: 12345678content_render: (h, item) =&gt; &#123; return ( &lt;span&gt; &lt;span class=\"el-icon-location\"&gt;&lt;/span&gt; &lt;span&gt;&#123;item.name&#125;&lt;/span&gt; &lt;/span&gt; )&#125; 修改完后的效果和上图是一致的。 实际上上面的navMenu组件也可以使用jsx来重构，使用jsx的话代码更简洁和易维护一点，但是有关在vue中使用jsx的内容太多，打算再另外写一篇文章进行总结。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue插件总结","slug":"vue插件总结","date":"2019-11-30T15:40:44.000Z","updated":"2019-11-30T15:40:44.000Z","comments":true,"path":"2019/11/30/vue插件总结/","link":"","permalink":"https://haoge744.github.io/2019/11/30/vue%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93/","excerpt":"Vue三方插件集合前几天在网上看到一个vue插件列表，觉得还不错分享一下。找不到插件的时候可以回来看下哦。","text":"Vue三方插件集合前几天在网上看到一个vue插件列表，觉得还不错分享一下。找不到插件的时候可以回来看下哦。 UI件框架 element - 饿了么出品的Vue2的web UI工具套件 mint-ui - Vue 2的移动UI元素 iview - 基于 Vuejs 的开源 UI 组件库 Keen-UI - 轻量级的基本UI组件合集 vue-material - 通过Vue Material和Vue 2建立精美的app应用 muse-ui - 三端样式一致的响应式 UI 库 vuetify - 为移动而生的Vue JS 2组件框架 vonic - 快速构建移动端单页应用 vue-blu - 帮助你轻松创建web应用 vue-multiselect - Vue.js选择框解决方案 VueCircleMenu - 漂亮的vue圆环菜单 vue-chat - vuejs和vuex及webpack的聊天示例 radon-ui - 快速开发产品的Vue组件库 vue-waterfall - Vue.js的瀑布布局组件 vue-carbon - 基于 vue 开发MD风格的移动端 vue-beauty - 由vue和ant design创建的优美UI组件 bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件 vueAdmin - 基于vuejs2和element的简单的管理员模板 vue-ztree - 用 vue 写的树层级组件 vue-tree - vue树视图组件 vue-tabs - 多tab页轻型框架 编辑器 markcook - 好看的markdown编辑器 eme - 优雅的Markdown编辑器 vue-syntax-highlight - Sublime Text语法高亮 vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器 Vueditor - 所见即所得的编辑器 vue-html5-editor - html5所见即所得编辑器 vue2-editor - HTML编辑器 vue-simplemde - VueJS的Markdown编辑器组件 vue-quill - vue组件构建quill编辑器 slider vue-awesome-swiper - vue.js触摸滑动组件 vue-slick - 实现流畅轮播框的vue组件 vue-swipe - VueJS触摸滑块 vue-swiper - 易于使用的滑块组件 vue-images - 显示一组图片的lightbox组件 vue-carousel-3d - VueJS的3D轮播组件 vue-slide - vue轻量级滑动组件 vue-slider - vue 滑动组件 vue-m-carousel - vue 移动端轮播组件 dd-vue-component - 订单来了的公共组件库 vue-easy-slider - Vue 2.x的滑块组件 图表 vue-table - 简化数据表格 vue-chartjs - vue中的Chartjs的封装 vue-charts - 轻松渲染一个图表 vue-chart - 强大的高速的vue图表解析 vue-highcharts - HighCharts组件 chartjs - Vue Bulma的chartjs组件 vue-chartkick - VueJS一行代码实现优美图表 日历 vue-calendar - 日期选择插件 vue-datepicker - 日历和日期选择组件 vue-datetime-picker - 日期时间选择控件 vue2-calendar - 支持lunar和日期事件的日期选择器 vue-fullcalendar - 基于vue.js的全日历组件 vue-datepicker - 漂亮的Vue日期选择器组件 datepicker - 基于flatpickr的时间选择组件 vue2-timepicker - 下拉时间选择器 vue-date-picker - VueJS日期选择器组件 vue-datepicker-simple - 基于vue的日期选择器 地址选择 vue-city - 城市选择器 vue-region-picker - 选择中国的省份市和地区 地图 vue-amap - 基于Vue 2和高德地图的地图组件 vue-google-maps - 带有双向数据绑定Google地图组件 vue-baidu-map- 基于 Vue 2的百度地图组件库 vue-cmap - Vue China map可视化组件 播放器 vue-video-player - VueJS视频及直播播放器 vue-video - Vue.js的HTML5视频播放器 vue-music-master - vue手机端网页音乐播放器 滚动scroll vue-scroller - Vonic UI的功能性组件 vue-mugen-scroll - 无限滚动组件 vue-infinite-loading - VueJS的无限滚动插件 vue-virtual-scroller - 带任意数目数据的顺畅的滚动 vue-infinite-scroll - VueJS的无限滚动指令 vue-scrollbar - 最简单的滚动区域组件 vue-scroll - vue滚动 vue-pull-to-refresh - Vue2的上拉下拉 mint-loadmore - VueJS的双向下拉刷新组件 vue-smoothscroll - smoothscroll的VueJS版本 文件上传 vue-upload-component - Vuejs文件上传组件 vue-core-image-upload - 轻量级的vue上传插件 vue-dropzone - 用于文件上传的Vue组件 图片处理 vue-lazyload-img - 移动优化的vue图片懒加载插件 vue-image-crop-upload - vue图片剪裁上传组件 vue-svgicon - 创建svg图标组件的工具 vue-img-loader - 图片加载UI组件 vue-image-clip- 基于vue的图像剪辑组件 vue-progressive-image - Vue的渐进图像加载插件 提示 vue-toast-mobile - VueJS的toast插件 vue-msgbox - vuejs的消息框 vue-tooltip - 带绑定信息提示的提示工具 vue-verify-pop - 带气泡提示的vue校验插件 进度条 vue-radial-progress - Vue.js放射性进度条组件 vue-progressbar - vue轻量级进度条 vue2-loading-bar - 最简单的仿Youtube加载条视图 其他 vue-dragging- 使元素可以拖拽 Vue.Draggable- 实现拖放和视图模型数组同步 vue-picture-input- 移动友好的图片文件输入组件 rubik- 基于Vuejs2的开源 UI 组件库 VueStar- 带星星动画的vue点赞按钮 vue-tables-2- 显示数据的bootstrap样式网格 DataVisualization- 数据可视化 vue-drag-and-drop-list- 创建排序列表的Vue指令 vuwe- 基于微信WeUI所开发的专用于Vue2的组件库 vue-typer- 模拟用户输入选择和删除文本的Vue组件 vue-impression- 移动Vuejs2 UI元素 vue-datatable- 使用Vuejs创建的DataTableView vue-instant- 轻松创建自动提示的自定义搜索控件 vue-slider-component- 在vue1和vue2中使用滑块 vue-touch-ripple- vuejs的触摸ripple组件 coffeebreak- 实时编辑CSS组件工具 vue-datasource- 创建VueJS动态表格 handsontable- 网页表格组件 vue-bootstrap-table- 可排序可检索的表格 vue-google-signin-button- 导入谷歌登录按钮 vue-float-label- VueJS浮动标签模式 vue-tagsinput- 基于VueJS的标签组件 vue-social-sharing- 社交分享组件 vue-popup-mixin- 用于管理弹出框的遮盖层 cubeex- 包含一套完整的移动UI vue-fullcalendar- vue FullCalendar封装 vue-material-design- Vue MD风格组件 vue-morris- Vuejs组件封装Morrisjs库 we-vue- Vue2及weui1开发的组件 vue-form-2- 全面的HTML表单管理的解决方案 vue-side-nav- 响应式的侧边导航 mint-indicator- VueJS移动加载指示器插件 vue-ripple- 制作谷歌MD风格涟漪效果的Vue组件 vue-touch-keyboard- VueJS虚拟键盘组件 vue-parallax- 整洁的视觉效果 vue-typewriter- vue组件类型 vue-ios-alertview- iOS7+ 风格的alertview服务 paco-ui-vue- PACOUI的vue组件 vue-button- Vue按钮组件 开发框架 vue.js - 流行的轻量高效的前端组件化方案 vue-admin - Vue管理面板框架 electron-vue - Electron及VueJS快速启动样板 vue-2.0-boilerplate - Vue2单页应用样板 vue-webgulp - 仿VueJS Vue loader示例 vue-bulma - 轻量级高性能MVVM Admin UI框架 vue-spa-template - 前后端分离后的单页应用开发 Framework7-Vue - VueJS与Framework7结合 vue-element-starter - vue启动页 实用库 vuelidate - 简单轻量级的基于模块的Vue.js验证 qingcheng - qingcheng主题 vuex - 专为 Vue.js 应用程序开发的状态管理模式 vue-axios - 将axios整合到VueJS的封装 vue-desktop - 创建管理面板网站的UI库 vue-meta - 管理app的meta信息 avoriaz - VueJS测试实用工具库 vue-framework7 - 结合VueJS使用的Framework7组件 vue-lazy-render - 用于Vue组件的延迟渲染 vue-svg-icon - vue2的可变彩色svg图标方案 vue-online - reactive的在线和离线组件 vue-password-strength-meter - 交互式密码强度计 vuep - 用实时编辑和预览来渲染Vue组件 vue-bootstrap-modal - vue的Bootstrap样式组件 element-admin - 支持 vuecli 的 Element UI 的后台模板 vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件 cleave - 基于cleave.js的Cleave组件 vue-events - 简化事件的VueJS插件 http-vue-loader - 从html及js环境加载vue文件 vue-electron - 将选择的API封装到Vue对象中的插件 vue-router-transition - 页面过渡插件 vuemit - 处理VueJS事件 vue-cordova - Cordova的VueJS插件 vue-qart - 用于qartjs的Vue2指令 vue-websocket - VueJS的Websocket插件 vue-gesture - VueJS的手势事件插件 vue-local-storage - 具有类型支持的Vuejs本地储存插件 lazy-vue - 懒加载图片 vue-lazyloadImg - 图片懒加载插件 vue-bus - VueJS的事件总线 vue-observe-visibility - 当元素在页面上可见或隐藏时检测 vue-notifications - 非阻塞通知库 v-media-query - vue中添加用于配合媒体查询的方法 vuex-shared-mutations - 分享某种Vuex mutations vue-lazy-component - 懒加载组件或者元素的Vue指令 vue-reactive-storage - vue插件的Reactive层 vue-ts-loader - 在Vue装载机检查脚本 vue-pagination-2 - 简单通用的分页组件 vuex-i18n - 定位插件 Vue.resize - 检测HTML调整大小事件的vue指令 vue-zoombox - 一个高级zoombox leo-vue-validator - 异步的表单验证组件 modal - Vue Bulma的modal组件 Famous-Vue - Famous库的vue组件 vue-input-autosize - 基于内容自动调整文本输入的大小 vue-file-base64 - 将文件转换为Base64的vue组件 Vue-Easy-Validator - 简单的表单验证 vue-truncate-filter - 截断字符串的VueJS过滤器 服务端 vue-ssr - 结合Express使用Vue2服务端渲染 nuxt.js - 用于服务器渲染Vue app的最小化框架 vue-ssr - 非常简单的VueJS服务器端渲染模板 vue-easy-renderer - Nodejs服务端渲染 express-vue - 简单的使用服务器端渲染vue.js 辅助工具 DejaVue - Vuejs可视化及压力测试 vue-generate-component - 轻松生成Vue js组件的CLI工具 vscode-VueHelper - 目前vscode最好的vue代码提示插件 vue-play - 展示Vue组件的最小化框架 VuejsStarterKit - vuejs starter套件 vue-multipage-cli - 简单的多页CLI 应用实例 pagekit - 轻量级的CMS建站系统 vuedo - 博客平台 koel - 基于网络的个人音频流媒体服务 CMS-of-Blog - 博客内容管理器 vue-cnode - 重写vue版cnode社区 vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客 swoole-vue-webim - Web版的聊天应用 fewords - 功能极其简单的笔记本 jackblog-vue - 个人博客系统 vue-blog - 使用Vue2.0 和Vuex的vue-blog vue-dashing-js - nuvo-dashing-js的fork rss-reader - 简单的rss阅读器 Demo示例 eleme - 高仿饿了么app商家详情 NeteaseCloudWebApp - 高仿网易云音乐的webapp vue-zhihu-daily - 知乎日报 with Vuejs Vue-cnodejs - 基于vue重写Cnodejs.org的webapp vue2-demo - 从零构建vue2 + vue-router + vuex 开发环境 vue-wechat - vue.js开发微信app界面 vue-music - Vue 音乐搜索播放 maizuo - vue/vuex/redux仿卖座网 vue-demo - vue简易留言板 spa-starter-kit - 单页应用启动套件 zhihudaily-vue - 知乎日报web版 douban - 模仿豆瓣前端 vue-Meizi - vue最新实战项目 vue-demo-kugou - vuejs仿写酷狗音乐webapp vue2.0-taopiaopiao - vue2.0与express构建淘票票页面 node-vue-server-webpack - Node.js+Vue.js+webpack快速开发框架 VueDemo_Sell_Eleme - Vue2高仿饿了么外卖平台 vue-leancloud-blog - 一个前后端完全分离的单页应用 vue-fis3 - 流行开源工具集成demo mi-by-vue - VueJS仿小米官网 vue-demo-maizuo - 使用Vue2全家桶仿制卖座电影 vue2.x-douban - Vue2实现简易豆瓣电影webApp vue-adminLte-vue-router - vue和adminLte整合应用 vue-zhihudaily - 知乎日报 Web 版本 Zhihu-Daily-Vue.js - Vuejs单页网页应用 vue-axios-github - 登录拦截登出功能 vue2.x-Cnode - 基于vue全家桶的Cnode社区 hello-vue-django - 使用带有Django的vuejs的样板项目 websocket_chat - 基于vue和websocket的多人在线聊天室 x-blog - 开源的个人blog项目 vue-cnode - vue单页应用demo vue-express-mongodb - 简单的前后端分离案例 photoShare - 基于图片分享的社交平台 notepad - 本地存储的记事本 vue-zhihudaily-2.0 - 使用Vue2.0+vue-router+vuex创建的zhihudaily vueBlog - 前后端分离博客 Zhihu_Daily - 基于Vue和Nodejs的Web单页应用 vue-ruby-china - VueJS框架搭建的rubychina平台 vue-koa-demo - 使用Vue2和Koa1的全栈demo life-app-vue - 使用vue2完成多功能集合到小webapp vue-trip - vue2做的出行webapp github-explorer - 寻找最有趣的GitHub库 vue-ssr-boilerplate - 精简版的ofvue-hackernews-2 vue-bushishiren - 不是诗人应用 houtai - 基于vue和Element的后台管理系统 ios7-vue - 使用vue2.0 vue-router vuex模拟ios7 Framework7-VueJS - 使用移动框架的示例 cnode-vue - 基于vue和vue-router构建的cnodejs web网站SPA vue-cli-multipage-bootstrap - 将vue官方在线示例整合到组件中 vue-cnode - 用 Vue 做的 CNode 官网 seeMusic - 跨平台云音乐播放器 HyaReader - 移动友好的阅读器 zhihu-daily - 轻松查看知乎日报内容 vue-cnode - 使用cNode社区提供的接口 zhihu-daily-vue - 知乎日报 vue-dropload - 用以测试下拉加载与简单路由 vue-cnode-mobile - 搭建cnode社区 Vuejs-SalePlatform - vuejs搭建的售卖平台demo vue-memo - 用 vue写的记事本应用 sls-vuex2-demo - vuex2商城购物车demo v-notes - 简单美观的记事本 vue-starter - VueJs项目的简单启动页 原文地址: http://www.javanx.cn/20180720/vue-plug/","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue中name的作用","slug":"vue中name的作用","date":"2019-11-23T14:43:39.000Z","updated":"2019-11-23T14:43:39.000Z","comments":true,"path":"2019/11/23/vue中name的作用/","link":"","permalink":"https://haoge744.github.io/2019/11/23/vue%E4%B8%ADname%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"我们在写vue项目的时候会遇到给组件命名。 123export default &#123; name: 'xxx'&#125; 这里的name非必选项，看起来好像没啥用处，但是实际上这里用处还挺多的","text":"我们在写vue项目的时候会遇到给组件命名。 123export default &#123; name: 'xxx'&#125; 这里的name非必选项，看起来好像没啥用处，但是实际上这里用处还挺多的 当项目需要使用keep-alive时，可以进行缓存过滤使用keep-alive组件时,它的includes和exclude属性中使用的正是component的name 做递归组件时使用，比如当我们需要做层级菜单的时候，递归时需要用到name属性list.vue: 12345678910111213141516171819&lt;div&gt; &lt;div v-for&#x3D;&quot;(item,index) of list&quot; :key&#x3D;&quot;index&quot;&gt; &lt;div&gt; &lt;span class&#x3D;&quot;item-title-icon&quot;&gt;&lt;&#x2F;span&gt; &#123;&#123;item.title&#125;&#125; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;item.children&quot; &gt; &lt;detail-list :list&#x3D;&quot;item.children&quot;&gt;&lt;&#x2F;detail-list&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;script&gt;export default &#123; name:&#39;DetailList&#39;,&#x2F;&#x2F;递归组件是指组件自身调用自身 props:&#123; list:Array &#125;&#125;&lt;&#x2F;script&gt; list数据: 1234567891011121314151617const list = [&#123; \"title\": \"A\", \"children\": [&#123; \"title\": \"A-A\", \"children\": [&#123; \"title\": \"A-A-A\" &#125;] &#125;,&#123; \"title\": \"A-B\" &#125;] &#125;, &#123; \"title\": \"B\" &#125;, &#123; \"title\": \"C\" &#125;, &#123; \"title\": \"D\" &#125;] 使用vue-tools调试工具时，里面的组件标签显示的就是vue的name属性 事件传递时可以用到研究element源码的时候发现有一个mixins/emitter文件，里面写了如何向上和向下的组件传递事件(不限层级)，当然他这里为了避免冲突没有用到name而是componentName,但是是差不多的。mixins/emitter.js 1234567891011121314151617181920212223242526272829303132function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; const name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat([params])); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; let parent = this.$parent || this.$root; let name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue使用mixins提升开发效率","slug":"vue使用mixins提升开发效率","date":"2019-11-12T14:25:09.000Z","updated":"2019-11-12T15:16:22.203Z","comments":true,"path":"2019/11/12/vue使用mixins提升开发效率/","link":"","permalink":"https://haoge744.github.io/2019/11/12/vue%E4%BD%BF%E7%94%A8mixins%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/","excerpt":"混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。","text":"混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。 在开发一些后台系统的时候，像这样的界面随处可见，那么能不能把其中相同的逻辑抽离出来来节省开发效率呢。vue给我们提供了mixins这样的一个混合工具，让我们可以抽离出一部分代码来进行”合并”。 大多数的列表界面都是类似的，不同的地方可能是功能以及数据的列不一样。所以可以把列表的查询条件，查询方法，分页等数据做一个mixins。 开始使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 新建 ListMixins.js// 请求后台的方法，传递url和查询参数即可返回列表值，需要后台统一查询接口import &#123; queryListData &#125; from \"@/api/dataTable\";export default &#123; data () &#123; _url: '', // 请求数据的url list: [], // 数据列表 page: &#123; // 分页参数 pageNum: 1, pageSize: 10, total: 0 &#125;, loading: false, // 加载状态 &#125;, methods: &#123; del() &#123; // 删除提示也可以抽出来，在实际的组件中覆盖 doDelete方法就行了 this.$confirm('是否确认删除?', '提示', &#123; confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' &#125;).then(() =&gt; &#123; this.doDelete() &#125;) &#125;, getQueryParam() &#123; // 获取查询参数 默认是查询条件和分页混合在一起 如果有额外的需求自行添加 return &#123;...this.query, ...this.page &#125; &#125;, queryListData() &#123; // 加载列表数据 const param = this.getQueryParam() // 获取上面定义的参数 return new Promise((resolve, reject) =&gt; &#123; this.loading = true // 设置loading initData(this._url, param).then(res =&gt; &#123; this.loading = false this.page.total = res.data.total // 设置总数 resolve(res.data.list) &#125;).catch(error =&gt; &#123; this.loading = false reject(error) &#125;) &#125;) &#125;, init () &#123;&#125; &#125;, created () &#123; // 初始化函数， 需要在里面做url和数据的处理 this.init() &#125; &#125;&#125; 组件中使用: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div&gt; &lt;!-- 查询部分 --&gt; &lt;div&gt; &lt;el-form :inline&#x3D;&quot;true&quot; size&#x3D;&quot;small&quot; :model&#x3D;&quot;query&quot; class&#x3D;&quot;demo-form-inline&quot;&gt; &lt;el-form-item label&#x3D;&quot;名称&quot;&gt; &lt;el-input v-model&#x3D;&quot;query.name&quot; placeholder&#x3D;&quot;请输入关键字&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item label&#x3D;&quot;电话&quot;&gt; &lt;el-input v-model&#x3D;&quot;query.phone&quot; placeholder&#x3D;&quot;请输入关键字&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-button @click&#x3D;&quot;queryData&quot;&gt;查询&lt;&#x2F;el-button&gt; &lt;&#x2F;el-form&gt; &lt;div class&#x3D;&quot;pull-right&quot;&gt; &lt;el-button type&#x3D;&quot;default&quot;&gt;新增&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;default&quot; @click&#x3D;&quot;edit&quot;&gt;编辑&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;default&quot; @click&#x3D;&quot;del&quot;&gt;删除&lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;!-- 列表部分 --&gt; &lt;el-table :data&#x3D;&quot;list&quot;&gt; &lt;el-table-column label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;name&quot; align&#x3D;&quot;center&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column label&#x3D;&quot;电话&quot; prop&#x3D;&quot;name&quot; align&#x3D;&quot;center&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;&#x2F;el-table&gt; &lt;el-pagination style&#x3D;&quot;text-align: center;&quot; :current-page.sync&#x3D;&quot;page.pageNum&quot; :page-size.sync&#x3D;&quot;page.pageSize&quot; :total&#x3D;&quot;page.total&quot; :page-sizes&#x3D;&quot;[10,20,50]&quot; layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot; @size-change&#x3D;&quot;queryData&quot; @current-change&#x3D;&quot;queryData&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import ListMixin from &#39;..&#x2F;mixins&#x2F;ListMixins&#39; export default &#123; mixins: [ListMixin], methods: &#123; init () &#123; this._url &#x3D; &#39;xxx&#x2F;xxx&#x2F;query&#39; &#x2F;&#x2F; 覆盖查询的url this.queryData() &#125;, doDelete () &#123; &#x2F;&#x2F; 调用删除接口 &#125;, queryData () &#123; this.queryListData().then(res &#x3D;&gt; &#123; this.list &#x3D; res &#125;) &#125; &#125; &#125;&lt;&#x2F;script&gt; 我这里用的是element-ui，关于el-table和el-pagination的可以自己再封装，这里不演示了，只演示mixins的相关内容。 总结封装好mixins后使用既方便了开发，维护起来也方便了很多，比如说我的默认页要调整到20页，我该一行代码就可以了，关键是把真正项目中公用的地方抽离出来，这个要考虑好。 虽然mixins好用，但是也不是没有缺点，如果说你一个组件引入的mixins过多，那么容易产生我这个数据或方法不知道从哪来的，会产生不确定性。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue3.0之vue-composition-api尝鲜","slug":"vue3-0之vue-composition-api尝鲜","date":"2019-11-05T15:30:34.000Z","updated":"2019-11-10T04:14:00.685Z","comments":true,"path":"2019/11/05/vue3-0之vue-composition-api尝鲜/","link":"","permalink":"https://haoge744.github.io/2019/11/05/vue3-0%E4%B9%8Bvue-composition-api%E5%B0%9D%E9%B2%9C/","excerpt":"简介根据vue作者尤雨溪去年发布的vue3.0开发路线，vue3.0很可能会在2019年下半年推出。 此前vue官方也提供过了vue3.0特性的尝鲜版本，叫做vue-function-api,此后推出的最新版本为vue-composition-api,之前的vue-function-api已经淘汰了不再推荐学习了。 虽然vue3.0还没有正式发布，但是已经可以安装composition-api插件来体验了。 本篇文章将介绍composition-api基础使用以及最重要的一些新特性,例如setup()函数、reactive()、ref()等这些Vue Hooks。","text":"简介根据vue作者尤雨溪去年发布的vue3.0开发路线，vue3.0很可能会在2019年下半年推出。 此前vue官方也提供过了vue3.0特性的尝鲜版本，叫做vue-function-api,此后推出的最新版本为vue-composition-api,之前的vue-function-api已经淘汰了不再推荐学习了。 虽然vue3.0还没有正式发布，但是已经可以安装composition-api插件来体验了。 本篇文章将介绍composition-api基础使用以及最重要的一些新特性,例如setup()函数、reactive()、ref()等这些Vue Hooks。 安装 安装@vue/cli3 1npm install -g @vue&#x2F;cli 创建项目 1vue create my-project 安装composition-api 1npm install @vue/composition-api --save 使用 12345// 在main.js使用import Vue from 'vue'import VueCompositionApi from '@vue/composition-api'Vue.use(VueCompositionapi) 使用setup函数setup函数是vue3中，专门为组件提供的新属性，它为我们使用vue3的Composition API 提供了同意的入口 生命周期: setup会在beforeCreate之后，created之前执行。 1234567891011// comp1.vueexport default&#123; props: &#123; title: String &#125;, setup(props, ctx) &#123; console.log(props.title) &#125;&#125;// 使用&lt;compSetup title=\"access\" aaa=\"app\"&gt;&lt;/compSetup&gt; setup函数的形参props对应的是组件的参数，并且必须在props中声明才能访问的到，否则会出现在Vue inheritAttrs中 ctx对应的是一个上下文对象，包含了一些有用的属性，这些属性在vue2.x中通过this才能访问，在vue3.x中集成到了ctx属性中。如图 注意：在setup()函数中无法访问this reactivereactive()函数接受一个普通的对象，返回一个响应式的数据对象 基本语法等价于Vue2.x中的Vue.observable()函数 12345678import &#123; reactive &#125; from '@vue/composition-api'export default &#123; setup (props, ctx) &#123; const state = reactive(&#123;count : 0&#125;) // 将响应式对象state 返回出去，否则外界访问不到 return state &#125;&#125; 模板中访问 1234567&lt;template&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;span&gt; &lt;!-- 每次点击加1，同时页面也会更新 --&gt; &lt;button @click&#x3D;&quot;count +&#x3D; 1&quot;&gt; +1 &lt;&#x2F;button&gt;&lt;&#x2F;template&gt; 使用方式和原来差不多，只不过原来是data属性，现在集成到了setup函数中，写法有点像react了 refref()函数的作用是根据给定的值创建一个响应式的数据对象，ref()函数调用的返回值是一个对象，且该对象只有一个属性:value 使用:12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;!-- 在模板中使用不需要.value --&gt; &#123;&#123; count &#125;&#125; &lt;button @click&#x3D;&quot;count +&#x3D; 1&quot;&gt; +1 &lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref&#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup(props, ctx) &#123; const count &#x3D; ref(0) count.value++ &#x2F;&#x2F; 在setup中使用需要.value ref返回的是对象 return &#123; count &#125; &#125;&#125;&lt;&#x2F;script&gt; ref的功能和reactive很像，但在vue3中推荐使用ref创建响应式对象 ref和reactive配合使用123456789101112131415&lt;script&gt;import &#123;ref, reactive&#125; from '@vue/composition-api'export default &#123; setup(props, ctx) &#123; const cc = ref(0) const state = reactive&#123; cc &#125; console.log(state.cc) // 输出0 此处不需要.value就能直接访问原始值 state.cc++ console.log(state.cc) // 输出1 return state &#125;&#125;&lt;/script&gt; 注意:在setup创建的任何成员，想要使用必须在setup()中return 新的ref会覆盖就的ref: 1234567891011const a1 = ref(0)const state = reactive(&#123; a1&#125;)const a2 = ref(10)state.a1 = a2 // 将旧ref a1指向 新ref a2state.a1++console.log(state.a1) // 输出 11console.log(a2) // 输出11console.log(a1.value) // 输出0 isRef作用是判断该对象是否是ref方法创建的 12import &#123;isRef&#125; from '@vue/composition-api'const objValue = isRef(obj) ? obj.value : obj toRefs的使用toRefs函数的作用是将reactive()创建出来的对象，转换成普通的对象，只不过这个对象的每一个属性都是ref类型的响应式数据。 应用场景: 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &#123;&#123; count &#125;&#125; &lt;button @click&#x3D;&quot;increment&quot;&gt;+1&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;toRefs, reactive&#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup () &#123; const state &#x3D; reactive(&#123; count: 0 &#125;) &#x2F;&#x2F; 定义页面上的事件处理函数 const increment &#x3D; () &#x3D;&gt; &#123; state.count++ &#125; &#x2F;&#x2F; 在setup中返回一个对象供页面调用 可以包含响应式的数据，也可以包含供页面调用的函数 return &#123; ...toRefs(state), &#x2F;&#x2F; 增加的处理函数 increment &#125; &#125;&#125;&lt;&#x2F;script&gt; 在vue3中推荐在setup中写函数而不是在metods中写， 但是如果要返回响应式的值，又要返回函数的话，直接使用...state会让响应式失去作用，所以就有了toRefs函数，他把对象中所有的属性改为了ref类型，所以给页面提供了响应式的功能。 computed计算属性 computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入： 1import &#123; computed &#125; from '@vue/composition-api' 只读计算属性 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; count的值：&#123;&#123; count &#125;&#125; 计算属性：&#123;&#123; plusOne &#125;&#125; &lt;button @click&#x3D;&quot;count +&#x3D; 1&quot;&gt;+&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; computed,ref &#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup(props, ctx) &#123; const count &#x3D; ref(0) const plusOne &#x3D; computed(() &#x3D;&gt; count.value + 1) return &#123; count, plusOne &#125; &#125;&#125;&lt;&#x2F;script&gt; 可读写的计算属性: 123456789const count = ref(0)const plusOne = computed(&#123; get: () =&gt; count.value + 1 set: (val) =&gt; count.value = val - 1&#125;)//为计算属性赋值会触发set函数plusOne.value = 10console.log(count.value) // 输出9 watch和vue2.x的watch作用一致，只是用法不一样 基础用法1234import &#123; watch, ref &#125; from '@vue/composition-api'const count = ref (0)// 每次改变count 都会打印count的值watch(() =&gt; console.log(count.value)) 监听reactive和ref123456789101112131415161718const state = reactive(&#123;count: 0&#125;)// 监视state.count的数据变化watch( () =&gt; state.count, // 第一个参数设置监听的数据源 (count, oldCount) =&gt; &#123; // 第二个参数为监听方法 // TODO &#125;, &#123; lazy: true, // watch创建的时候会自动执行一次，设置lazy可以关闭 &#125;)// 监听refconst c2 = ref(0)watch(c2, (val, oldVal) =&gt; &#123; // TODO &#125; ) 在vue2.x中监听多个数据源，需要写多个watch,在vue3中支持监听多个数据源: 监听多个数据源:1234567891011121314151617181920const state = reactive(&#123; count: 0, name: 'zs' &#125;)watch( [() =&gt; state.count, () =&gt; state.name], // Object.values(toRefs(state)), ([count, name], [oldCount, oldName]) =&gt; &#123; // 按顺序解构赋值 console.log(count) // 新的 count 值 console.log(name) // 新的 name 值 console.log('------------') console.log(oldCount) // 旧的 count 值 console.log(oldName) // 新的 name 值 &#125;, &#123; lazy: true &#125;)setTimeout(() =&gt; &#123; state.count++ state.name = 'ls'&#125;, 1000) 监听多个ref: 123456789101112131415161718192021const count = ref(0)const name = ref('zs')watch( [count, name], // 需要被监视的多个 ref 数据源 ([count, name], [oldCount, oldName]) =&gt; &#123; console.log(count) console.log(name) console.log('-------------') console.log(prevCount) console.log(prevName) &#125;, &#123; lazy: true &#125;)setTimeout(() =&gt; &#123; count.value++ name.value = 'xiaomaolv'&#125;, 1000) 清除watch监视在组件销毁的时候会自动清除watch的监听，但是如果需要手动清除的话可以用以下的方法 123const stop &#x3D; watch(() &#x3D;&gt; &#123;&#125;)&#x2F;&#x2F; 调用watch的返回值就可以停止监听stop() 清除无效的异步任务 有时候，当被 watch 监视的值发生变化时，或 watch 本身被 stop 之后，我们期望能够清除那些无效的异步任务，此时，watch 回调函数中提供了一个 cleanup registrator function 来执行清除的工作。这个清除函数会在如下情况下被调用： watch 被重复执行了 watch 被强制 stop 了 Template 中的代码示例如下： 1/* template 中的代码 */ &lt;input type=\"text\" v-model=\"keywords\" /&gt; Script 中的代码示例如下： 1234567891011121314151617181920212223242526272829// 定义响应式数据 keywordsconst keywords = ref('')// 异步任务：打印用户输入的关键词const asyncPrint = val =&gt; &#123; // 延时 1 秒后打印 return setTimeout(() =&gt; &#123; console.log(val) &#125;, 1000)&#125;// 定义 watch 监听watch( keywords, (keywords, prevKeywords, onCleanup) =&gt; &#123; // 执行异步任务，并得到关闭异步任务的 timerId const timerId = asyncPrint(keywords) // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务 onCleanup(() =&gt; clearTimeout(timerId)) &#125;, // watch 刚被创建的时候不执行 &#123; lazy: true &#125;)// 把 template 中需要的数据 return 出去return &#123; keywords&#125; 实现之后的效果是,等输入框输入暂停时才会触发打印，有了这个功能防抖就好做了 (;￢＿￢) New LifeCycle Hooks新的生命周期方法，可以按需导入到组件中，且只能在 setup() 函数中使用，代码示例如下： 123456789101112131415import &#123; onMounted, onUpdated, onUnmounted &#125; from '@vue/composition-api'const MyComponent = &#123; setup() &#123; onMounted(() =&gt; &#123; console.log('mounted!') &#125;) onUpdated(() =&gt; &#123; console.log('updated!') &#125;) onUnmounted(() =&gt; &#123; console.log('unmounted!') &#125;) &#125;&#125; 下面的列表，是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系： beforeCreate =&gt; use setup() created =&gt; use setup() beforeMount =&gt; onBeforeMount mounted =&gt; onMounted beforeUpdate=&gt; onBeforeUpdate updated =&gt; onUpdated beforeDestroy =&gt; onBeforeUnmount destroyed =&gt; onUnmounted errorCaptured =&gt; onErrorCaptured provide和injectprovide()和inject()用于实现嵌套组件之间的数据传递，这两个函数只能在setup中使用。 父组件使用provide向下分享数据，inject在子组件中进行接收数据 用法父组件传递主题颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;&#x2F; 父组件&lt;template&gt; &lt;div&gt; &lt;h1 :style&#x3D;&quot;&#123;color: color&#125;&quot;&gt;父节点&lt;&#x2F;h1&gt; &lt;comp1 &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; provide,ref &#125; from &#39;@vue&#x2F;composition-api&#39;import inject1 from &#39;.&#x2F;inject1&#39;export default &#123; components: &#123; &#39;comp1&#39;: inject1 &#125;, setup(props, ctx) &#123; const color &#x3D; ref(&#39;#fad0c4&#39;) provide(&#39;textColor&#39;, color) setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 2秒后变为淡蓝色 color.value &#x3D; &#39;#8fd3f4&#39; &#125;,2000) return &#123; color &#125; &#125;&#125;&lt;&#x2F;script&gt;&#x2F;&#x2F; 子组件 inject1.vue&lt;template&gt; &lt;div&gt; &lt;h2 :style&#x3D;&quot;&#123;color: color&#125;&quot;&gt;子组件&lt;&#x2F;h2&gt; &lt;inject2 &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;injectimport &#123;inject&#125; from &#39;@vue&#x2F;composition-api&#39;import inject2 from &#39;.&#x2F;inject2&#39;export default &#123; components: &#123; &#39;inject2&#39;: inject2 &#125;, setup(props, ctx) &#123; const color &#x3D; inject(&#39;textColor&#39;) return &#123; color &#125; &#125;&#125;&lt;&#x2F;script&gt;&#x2F;&#x2F; 孙组件 inject2.vue&lt;template&gt; &lt;div&gt; &lt;h3 :style&#x3D;&quot;&#123;color: color&#125;&quot;&gt;孙组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;inject&#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup(props, ctx) &#123; const color &#x3D; inject(&#39;textColor&#39;) return &#123; color &#125; &#125;&#125;&lt;&#x2F;script&gt; template refsref也支持vue2.x中的 ref属性，下面看看是怎么实现的 引用页面元素和组件1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;h1 ref&#x3D;&quot;refTitle&quot;&gt;&lt;&#x2F;h1&gt; &lt;comp1 ref&#x3D;&quot;refComp&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref, onMounted&#125; from &#39;@vue&#x2F;composition-api&#39;impot comp1 from &#39;.&#x2F;comp&#39;export default &#123; components: &#123; comp1 &#125;, setup(props, ctx) &#123; const refTitle &#x3D; ref(null) const refComp &#x3D; ref(null) onMounted(() &#x3D;&gt; &#123; &#x2F;&#x2F; onMounted后dom才渲染完成 refTitle.value.style.color &#x3D; &#39;red&#39; &#125;) return &#123; &#x2F;&#x2F; 保持和元素中的ref一致 refTitle, refComp &#125; &#125;&#125;&lt;&#x2F;script&gt; createComponent 这个函数是非必须的，除非你想要结合typescript进行vue项目的开发 123456789import &#123;createComponent&#125; '@vue/composition-api'export default createComponent(&#123; props: &#123; foo: String &#125;, setup(props) &#123; props.foo &#125;&#125;) 总结把composition-api都体验了一遍，虽然没有做像样的例子，但是感觉还是比较容易上手的，特别如果是有2.x经验的话。看的出来使用this的地方变少或者没有了。还有就是在vue3中应该不能像以前那样用Mixins了，Mixins本身有个缺点就是数据来源不明，如果引用的多的话更是如此。还有就是对ts的支持更加友好了,这里我还没体验过不作过多说明。 TipsVue 3将支持全局tree-shaking,这意味着如果你不使用它的某些功能，这些则不会出现在你打包的文件中。 123import &#123;nextTick, observable&#125; from 'Vue'nextTick(() =&gt; &#123;&#125;)const obj = objservable(&#123;&#125;) Vue3的响应式由Object.defineProperty换为Proxy后给对象，数组赋值不需要再使用Vue.set方法 123Vue.set(obj, key, value)=&gt;this.obj[key] = value","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"东野圭吾-《秘密》读后感","slug":"东野圭吾-《秘密》读后感","date":"2019-10-29T15:47:49.000Z","updated":"2019-10-30T02:15:31.396Z","comments":true,"path":"2019/10/29/东野圭吾-《秘密》读后感/","link":"","permalink":"https://haoge744.github.io/2019/10/29/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE-%E3%80%8A%E7%A7%98%E5%AF%86%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"秘密 这篇书评可能有关键情节透露。 用了两个晚上把这本书 看完了，第一天看了50页，第二天看了270多页。一直看到凌晨一点（´Д`）。很久没有进入这种感觉了，平时太忙，或者是有其它一些诱惑或者心情焦虑，静不下心来。好的作品确实能 激发读者的遐想，感悟书中的道理，体验书中人物的人生。虽然看完之后心里堵得慌。但是也是学习到了一些人生的哲理，同时也冒出了很多的疑问。特别是以我这个男性的眼光来看，故事的结局并不好。","text":"秘密 这篇书评可能有关键情节透露。 用了两个晚上把这本书 看完了，第一天看了50页，第二天看了270多页。一直看到凌晨一点（´Д`）。很久没有进入这种感觉了，平时太忙，或者是有其它一些诱惑或者心情焦虑，静不下心来。好的作品确实能 激发读者的遐想，感悟书中的道理，体验书中人物的人生。虽然看完之后心里堵得慌。但是也是学习到了一些人生的哲理，同时也冒出了很多的疑问。特别是以我这个男性的眼光来看，故事的结局并不好。 创作背景据说这本书创作时，东野圭吾刚刚和相伴14年的妻子离婚。在这种情况的影响下创作出了这本书，这本书里的内容可能有一些是作者的写照 或者缩影吧。 内容梗概 主人公杉田平介的妻子和女儿坐滑雪大巴回家时，发生了事故，幸亏妻子直子的拼死保护才让女儿藻奈美幸存下来。妻子最终还是抢救无效去世了，女儿醒来之后无法做出正常的反应。平介虽然心情悲痛但是还是要在女儿面前控制自己的情绪。然而神奇的事情发生了，在女儿身体里的灵魂居然是妻子直子的。这一下平介心理就混乱了。妻子的肉体虽然死亡了，但是灵魂却寄居在女儿身体里，虽然女儿的灵魂不在，但是身体却是健康的。 夫妻俩也别无他法了，只好隐瞒真相继续生活下去，直子提议要继续藻奈美的生活，上学，因为这种事情说出去别人也不会相信。并且直子觉得，之前的人生并不完美，现在有重新来的机会，更要好好把握，好好学习，让以后自己的生活的选择更多，不至于只能做一个家庭主妇。 随着生活的进行，家里两个人也发生了微妙的变化，藻奈美的身体第一次来了例假，还有平介对藻奈美的班主任有好感，但是介于与直子之间夫妻关系，平介并没有想发展下去，另外藻奈美表示想上私立中学，自己要好好备考，认真学习。 有一次平介喝了点酒回家，刚好直子在洗澡，但是直子对于在平介面前,露出身体以及身体接触很抵抗。可能藻奈美身体的发育和在学校的环境影响让直子的心理产生了一些变化，此时两人之间的沟壑越来越深了。 对于平介的生活来说，每天就是日常的上班，下班，还有就是在家陪伴直子。但是直子的生活就很丰富了，每天过着很精彩的生活，此外高中时还加入了社团，直子的想法是，既然人生让她以这样的方式重新来一遍，她也不能”浪费”藻奈美身体的使用权，要过的比之前更加精彩，她觉得这样的生活的才有意义。 在高中时期，直子因为加入棒球社团，她居然早出晚归了，有时候不能给平介做饭了。这让平介心中起了疑心，并且偶尔听到直子偷偷和男同学私通电话，终于在占有欲的情况下，平介开始监听了她的电话。终于他听到有一天那位同学在圣诞节约起了直子，平介心中泛起很大不安和嫉妒，于是赶到现场阻止了直子，把她强行带回了家。直子对于出现在现场的平介感到不解和震惊，最终发现了平介偷听的事实… 可能直子是在环境的影响下或者是藻奈美青春期身体的荷尔蒙的作用下吧，她的思维也改变了。他们的关系也出现了很大的裂痕，从上次那件事之后，直子仿佛活的像个机器人，没有灵魂。社团也退了，每天早早的回家做饭，但是她的脸上从那以后，没有笑过。终于有一天，平介决定放手，他开始以藻奈美叫她，并且表示让她今后一直以女儿的身份生活下去。藻奈美感动的哭了。 但是第二天早上却发现了神奇的事，女儿藻奈美的意识苏醒了，但是不记得过去几年的事情，平介给他讲了这几年直子一直在她的身体里替她生活的事。但是没过多久藻奈美睡去,醒来的又是直子的意识。就这样两个人的意识交替的出现。但是过了几天后，直子的意识出现的时间越来越少，终于在某天，直子和平介在他们初次约会的公园，完成了告别。平介很伤心，这意味着直子真的消失了。 。。。 几年之后，平介在女儿的婚礼上发现了装有两人钻戒的小熊公仔，他意识到，原来之前藻奈美的意识都是直子装出来的，她在那之后一直以藻奈美的身份生活了下去。藻奈美的意识从来没有出现过。。 本书完。 书评我所理解的结局是，直子一直在扮演藻奈美。虽然这个结局对平介来说很不公平，却很现实。 我记得一开始直子扮演藻奈美开始说的一句话。 说什么傻话，我会一直陪着你的。 其实看完句话开始我就觉得结局不会很明朗了，至少对平介来说。 直子是焕发第二春了，有了新的人生目标、新的爱好、新的人际交往、新的眼界。那么平介呢，我记得书中说 我今后该怎样生活下去呢？他在心里想着这个问题。自己是父亲又不是父亲，是丈夫又不是丈夫，是男人又不是男人。他的心在无情的现实面前颤抖着。 书中男女主心理的变化也很吸引读者的阅读欲望。两夫妻从那次灾难之后就维持着一段奇怪的关系，丈夫不知道如何看待当时的妻子。当妻子看待却又是女儿的身体，当女儿看待又会吃醋嫉妒。妻子也不知道该如何看待丈夫，是维持夫妻关系，还是用女儿年轻的身体再活一次(当然这种想法在我看来有点自私)。这让我想到之前很火的一个送命题：假如女友和丈母娘灵魂对换，必须和其中一个发生关系才能恢复，你怎么选？ 记得当时看到直子和同学暧昧的时候，我有点体会到当父亲时女儿要被某个野小子夺走的心情(╬￣皿￣)=○，相当的嫉妒啊。同时结局时也很心疼男主，即失去了妻子，又失去了女儿。这样的话还不如不察觉到那个秘密呢。 总结来说这本书是一本不错的书，出了灵魂对调的事情外，书中的情节都合情合理，书中也对人物的心理描写很丰富。书中的人物关系连接的很奇妙。总归来说是本不错的书，值得一看 可能每个人有每个人的看法，我觉得男主还是可怜啊o(╥﹏╥)o","categories":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}],"tags":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"},{"name":"读后感","slug":"读后感","permalink":"https://haoge744.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"Vue inheritAttrs的使用","slug":"Vue-inheritAttrs的使用","date":"2019-10-17T15:49:41.000Z","updated":"2019-10-17T15:49:41.000Z","comments":true,"path":"2019/10/17/Vue-inheritAttrs的使用/","link":"","permalink":"https://haoge744.github.io/2019/10/17/Vue-inheritAttrs%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"介绍Vue inheritAttrs诞生于vue2.4.0版本,目的是为了解决父孙组件传递参数的问题。在以前如果要父组件要给孙组件传值只能给子组件设置一套值，然后再给孙组件再设置一套相同的值，这样代码太过冗余并且工作量，还有一个方法就是用provide和inject,但是貌似这个方法也不是很好，组件多的话很难控制。所以vue2.4发布后解决了这个问题，还增加了关于事件向上传递的相关api $listeners","text":"介绍Vue inheritAttrs诞生于vue2.4.0版本,目的是为了解决父孙组件传递参数的问题。在以前如果要父组件要给孙组件传值只能给子组件设置一套值，然后再给孙组件再设置一套相同的值，这样代码太过冗余并且工作量，还有一个方法就是用provide和inject,但是貌似这个方法也不是很好，组件多的话很难控制。所以vue2.4发布后解决了这个问题，还增加了关于事件向上传递的相关api $listeners 如果你使用的是vue2.4之后的版本，那么当前的vue组件实例中会默认带一个属性，这个就是$attrs属性,这个属性用来保存没有在props中声明的参数属性。什么意思呢，就是你定义一个组件，这个组件的props只有一个count，但是我父组件调用的时候除了给了count，比如说还传递了一个:age=”12”,那么子组件就可以通过$attrs来获取到age。 123456789101112131415&#x2F;&#x2F; parent.vue&lt;template&gt; &lt;div&gt; &lt;children :count&#x3D;&quot;10&quot; :age&#x3D;&quot;15&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import children from &#39;.&#x2F;children&#39;export default &#123; components: &#123; children &#125;&#125;&lt;&#x2F;script&gt; 1234567891011121314151617&#x2F;&#x2F; children.vue&lt;template&gt; &lt;div&gt; &#123;&#123; count &#125;&#125; &#123;&#123; $attrs.age &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: &#123; count: Number &#125;, mounted() &#123; console.log(this) &#125;&#125;&lt;&#x2F;script&gt; 把children.vue实例打印出来如下图。 比如说项目中有这样有个功能，弹出一个有table的dialog，只是表格的字段和查询条件不一样。并且很多地方用得到，这样最好是封装成一个组件，然后我要用element的dialog和table进行封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;template&gt; &lt;el-dialog &lt;!-- sync是不支持的,所以要额外写参数 --&gt; :visible.sync&#x3D;&quot;visible&quot; &lt;!-- 给dialog组件传递参数 --&gt; v-bind&#x3D;&quot;$attrs&quot;&gt; &lt;div style&#x3D;&quot;padding: 5px;&quot;&gt; &lt;el-table class&#x3D;&quot;data-table-container&quot; :data&#x3D;&quot;tableData&quot; style&#x3D;&quot;width: 100%&quot; v-loading&#x3D;&quot;loading&quot; border&gt; &lt;el-table-column type&#x3D;&quot;index&quot; align&#x3D;&quot;center&quot; label&#x3D;&quot;序号&quot; v-if&#x3D;&quot;showNumber&quot; width&#x3D;&quot;50&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;!-- 循环表格的列，并且给表格列设置绑定属性为item --&gt; &lt;el-table-column v-for&#x3D;&quot;(item, index) in head&quot; v-bind&#x3D;&quot;item&quot; :key&#x3D;&quot;index&quot;&gt; &lt;template v-slot&#x3D;&quot;scope&quot;&gt; &lt;!-- 如果类型是slot的话给表格的列设置插槽 --&gt; &lt;slot :name&#x3D;&quot;item.prop&quot; v-if&#x3D;&quot;item.type &#x3D;&#x3D;&#x3D; &#39;slot&#39;&quot; :data&#x3D;&quot;scope.row&quot;&gt;&lt;&#x2F;slot&gt; &lt;template v-else&gt; &#123;&#123; scope.row[scope.column.property] &#125;&#125; &lt;&#x2F;template&gt; &lt;&#x2F;template&gt; &lt;&#x2F;el-table-column&gt; &lt;&#x2F;el-table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;el-dialog&gt;&lt;&#x2F;template&gt;&lt;script&gt; import request from &#39;@&#x2F;utils&#x2F;request&#39; export default &#123; name: &#39;tableGridDialog&#39;, props: &#123; head: &#123; &#x2F;&#x2F; 表格的列 required: true &#125;, showNumber: &#123; type: Boolean, default: true &#125;, url: &#123; type: String &#125;, params: &#123; type: Object &#125;, httpMethod: &#123; type: String, default: &#39;get&#39; &#125;, show: &#123; type: Boolean &#125;, formatDataMethod: &#123; type: Function &#125; &#125;, data() &#123; return &#123; tableData: [], loading: false, visible: false, &#125; &#125;, methods: &#123; initList() &#123; const queryData &#x3D; &#123; url: this.url, method: this.httpMethod &#125; if (this.params) &#123; if (this.httpMethod.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123; queryData.params &#x3D; this.params &#125; else &#123; queryData.data &#x3D; this.params &#125; &#125; this.loading &#x3D; true request(queryData).then(res &#x3D;&gt; &#123; this.loading &#x3D; false if (res.status &#x3D;&#x3D;&#x3D; 200) &#123; &#x2F;&#x2F; 如果有数据格式化方法，执行完之后赋值 if (this.formatDataMethod) &#123; this.tableData &#x3D; this.formatDataMethod(res.data) &#125; else &#123; this.tableData &#x3D; res.data &#125; &#125; &#125;).catch(error &#x3D;&gt; &#123; console.log(error) this.loading &#x3D; false &#125;) &#125; &#125;, created() &#123; &#125;, watch: &#123; params: &#123; handler(val) &#123; if (val) this.initList() &#125;, immediate: true &#125;, url (val) &#123; if (val) this.initList() &#125;, show: &#123; handler(val) &#123; if (val !&#x3D;&#x3D; this.visible) &#123; this.visible &#x3D; val &#125; &#125;, immediate: true &#125;, visible(val) &#123; if (val !&#x3D;&#x3D; this.show) &#123; this.$emit(&#39;update:show&#39;, val) &#125; &#125; &#125; &#125;&lt;&#x2F;script&gt; 使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;tableGridDialog :url&#x3D;&quot;changeUrl&quot; width&#x3D;&quot;740px&quot; title&#x3D;&quot;xx明细&quot; :params&#x3D;&quot;param&quot; :head&#x3D;&quot;changeDesignHead&quot; :show.sync&#x3D;&quot;showchangeDesign&quot;&gt; &lt;template v-slot:createTime&#x3D;&quot;&#123;data&#125;&quot;&gt; &#123;&#123; data.createTime | dateFormat&#125;&#125; &lt;&#x2F;template&gt; &lt;&#x2F;tableGridDialog&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; changeUrl: &#39;xxx&#39;, param: &#123; queryId: &#39;xxx&#39; &#125;, changeDesignHead: [ &#123; prop: &#39;createTime&#39;, label: &#39;日期&#39;, align: &#39;center&#39;, type: &#39;slot&#39; &#125;, &#123; prop: &#39;name&#39;, label: &#39;变更名称&#39;, align: &#39;center&#39;, type: &#39;slot&#39; &#125;, &#123; prop: &#39;content&#39;, label: &#39;内容&#39;, align: &#39;center&#39;, width: &#39;200px&#39; &#125; ] &#125;, &#x2F;&#x2F; ...&#125;&lt;&#x2F;script&gt; 使用的话代码也比较简单，不作太多讲解了。总结来说在组件嵌套这块解决了很大的问题。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"win10更新后提示未安装任何音频设备","slug":"win10更新后提示未安装任何音频设备","date":"2019-10-10T06:54:00.000Z","updated":"2019-10-10T06:57:41.835Z","comments":true,"path":"2019/10/10/win10更新后提示未安装任何音频设备/","link":"","permalink":"https://haoge744.github.io/2019/10/10/win10%E6%9B%B4%E6%96%B0%E5%90%8E%E6%8F%90%E7%A4%BA%E6%9C%AA%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87/","excerpt":"","text":"某天正常开启自己的笔记本电脑发现右上角的音量图标划伤了叉号，明明前几天用的好好的，最多就是windows自动更新了下系统，没想到就给更新挂了!!!∑(ﾟДﾟノ)ノ 点击了音量图标，然后弹出个框一直在loading,读取完之后提示我重启之后就好了，但是每次重启之后还是这样提示我重启(╬￣皿￣)=○，无限循环。。。 最后百度后找到了一下三种解决方法 更新声卡驱动下载了驱动精灵安装,并更新声卡驱动到最新版本，并没有啥用￣へ￣ 卸载声卡设备操作步骤是这样的： 右键此电脑 =&gt; 管理 左侧菜单切换到设备管理器 找到声音、视频和游戏控制器 把里面关于声音的设备全部卸载了 重启电脑 再回到设备管理器右键选择 扫描检测硬件改动 但是我试了这种方法也不行 秘之方法最后在csdn的秘之方法，据说是国外大神的。 直接在命令行输入 12net localgroup Administrators /add networkservicenet localgroup Administrators /add localservice 没想到意外解决了，所以记下此次记录，希望帮助更多人。","categories":[{"name":"生活","slug":"生活","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"webpack基础使用及配置","slug":"webpack基础使用及配置","date":"2019-10-06T16:34:46.000Z","updated":"2019-10-06T17:00:46.365Z","comments":true,"path":"2019/10/07/webpack基础使用及配置/","link":"","permalink":"https://haoge744.github.io/2019/10/07/webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/","excerpt":"VueCli用的比较多了，但是没有系统性的学过webpack,今天不基于任何脚手架工具单纯用webpack搭建一个小项目,加深自己对webpack的理解,以及一些常用配置。另外本文使用的是webpack4.41.0,在一些插件的使用上用了最新的方案。","text":"VueCli用的比较多了，但是没有系统性的学过webpack,今天不基于任何脚手架工具单纯用webpack搭建一个小项目,加深自己对webpack的理解,以及一些常用配置。另外本文使用的是webpack4.41.0,在一些插件的使用上用了最新的方案。 初始化12345678910111213-- 创建一个项目文件夹名字任意-- 新建src/main.js-- 新建src/index.htmlcd 项目文件夹-- 初始化package.jsonnpm init -y -- 安装相关组件yarnyarn add webpack --devyarn add html-webpack-plugin --devyarn add webpack-dev-server --devyarn add webpack-cli --dev 创建配置文件1234567891011121314151617// 创建webpack.config.jsconst path = require('path')const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: path.join(__dirname, './src/index.js'),// 入口文件 output: &#123; // 输出文件 path: path.join(__dirname, './dist'), filename: 'bundle.js' &#125;, plugins: [ // 插件 new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), filename: 'index.html' &#125;) ]&#125; 配置启动命令行123456789// package.json&#123; ... \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", // --open自动打开浏览器 端口 3000, 热修复 \"dev\": \"webpack-dev-server --open --port 3000 --hot\" &#125;,&#125; 添加模式作用是为了区分生产环境和测试环境 12345678&#x2F;&#x2F; package.json&#123; ... &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --hot --mode development&quot;, &quot;prod&quot;: &quot;&quot;webpack-dev-server --open --port 3000 --hot --mode production&quot; &#125;,&#125; mode属性是webpack4.0.0后增加的，内容可以是development和production,在dev和prod环境下process.env.NODE_ENV打印的值分别为development和production。 项目是可以跑起来了,但是还有一些欠缺，没有对css/scss、图片资源等资源进行处理；还有没有对es6语法进行兼容性问题处理。这个时候就需要用到webpack的loader了。 添加loader在src中新建css/index.scss文件和目录,然后给一个div设置背景图片 在main.js中引入 1import &#39;.&#x2F;css&#x2F;index.scss&#39; 然后运行后设置的css是无效的，因为没有给css和scss配置对应的loader，代码没有转换，所以会出现错误。 配置样式loader1yarn add style-loader css-loader sass-loader node-sass url-loader file-loader --dev 修改webpack.config.js 1234567891011module.exports = &#123; // 入口、输出、插件等配置在这里省略... module: &#123; rules: [ //some rule loaders... , &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|gif|bmp|jpg)$/, use: ['url-loader?limit=5000']&#125;, ] &#125;&#125; 配置babel1yarn add babel-core babel-loader babel-plugin-transform-runtime babel-preset-env babel-preset-stage-0 --dev 修改webpack.config.js 12345678910module.exports = &#123; // 入口、输出、插件等配置在这里省略... module: &#123; rules: [ //some rule loaders... , // 对js文件使用babel-loader, 排除node_modules中的文件 &#123; test: /\\.js$/, use 'babel-loader', exclude: /node_modules/ &#125; ] &#125;&#125; 在根目录新建.babelrc文件 1234567// json格式&#123; // 刚刚装的babel-preset-x 在这里写上 \"presets\": [\"env\", \"stage-0\"], // 使用的插件 babel-plugin-transform-runtime \"plugins\": [\"transform-runtime\"]&#125; 关于babel相关的配置及.babelrc文件的编写可以查看这篇文章 配置完后就可以使用scss、图片、es6等最新语法了 打包打包前需要安装几个全局依赖(如果没有安装的话) 12npm install webpack -gnpm install webpack-cli -g 然后直接在当前目录执行webpack命令就可以打包到dist目录下了 打包相关配置优化很多时候我们开发和打包的相关配置希望单独存放 复制webpack.config.js重命名webpack.config.build.js 在package.json中添加build命令 12345678&#123; // ... \"scripts\": &#123; // ... some scripts // 自定义设置文件 \"build\": \"webpack --config webpack.config.build.js --mode production\" &#125;&#125; 然后运行 npm run build就okl了 优化图片路径及名称1234&#123; test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000] &#125;// 改为// 图片名称改为8为哈希值-图片名.后缀名, 路径生成到images下面 &#123; test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000&amp;name=images/[hash:8]-[name].[ext]'] &#125; 每次打包前删除dist文件安装插件 1yarn add clean-webpack-plugin --dev 在config中添加 12345678910111213141516171819const clearWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; // ... plugins: [ // 数组中传入需要删除的文件夹名 new clearWebpackPlugin(['dist']) ]&#125;------------- 新写法----------------------const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin')module.exports = &#123; // ... plugins: [ // 数组中传入需要删除的文件夹名 new clearWebpackPlugin() ]&#125; 抽取第三方包在开发项目中会用到各种各样的第三方包,我们目前的这个打包方式会把第三方包和自己写的业务代码都放在bundle.js文件中，这样太臃肿了。 1234567891011121314151617181920212223242526272829303132// 修改webpack.config.build.js文件const webpack = require('webpack') // 导入webpack// 修改entry入口节点 把原来的入口文件改为对象module.exports = &#123; entry: &#123; // 配置入口节点 app: path.join(__dirname, './src/main.js'), // 这个名字要和chunk插件中的name对应 vendors: ['jquery','moment'] // 数组内为要分割的第三方包 &#125;,// 修改plugins// ------------------ 这是 webpack 3.x.x的写法 ----------------------- plugins: [ ... new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendors', // 指定要抽离的入口名称 filename: 'vendors.js' // 打包时除了会有一个bundle.js还有一个vendors.js文件里面存放了第三方包 &#125;) ]// ------------------ webpack 4.x.x的写法 ----------------------- // 配置optimization(和entry同级的属性) optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; name: \"vendors\", chunks: \"initial\", minChunks: 2 &#125; &#125; &#125; &#125;,&#125; 随着webpack4升级chunk得配置也发生了变化 相关链接 html-webpack-plugin的优化1234567891011121314&#x2F;&#x2F; 修改打包配置文件&#123; plugins: [ new htmlWebpackPlugin(&#123; template: path.join(__dirname, &#39;.&#x2F;src&#x2F;index.html&#39;), filename: &#39;index.html&#39;, minify: &#123; &#x2F;&#x2F; html优化项 collapseWhitespace: true,&#x2F;&#x2F; 清除多余的空格 removeComments: true, &#x2F;&#x2F; 清除注释 removeAttributeQuotes: true &#x2F;&#x2F; 清除属性上的双引号 &#125; &#125;), ]&#125; 还有更多选项Github css相关优化抽取css文件安装插件webpack 3.x.x使用extract-text-webpack-plugin(这里不做介绍) 1npm install --save-dev mini-css-extract-plugin github webpack 4.x.x使用mini-css-extract-plugin github地址 1npm install --save-dev mini-css-extract-plugin 修改配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// webpack.build.config.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin') // 引入插件module.exports = &#123; plugins: [ // ... some another plugins new MiniCssExtractPlugin(&#123; filename: '[hash:8]-[name].css', chunkFilename: '[id],css', ignoreOrder: false, // Enable to remove warnings about conflicting order &#125;) ], module: &#123; rules: [ &#123; test: /\\.css$/, // use: ['style-loader', 'css-loader'] // 注释之前的loader use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: (resourcePath, context) =&gt; &#123; // 资源路径，如果你的css打包至css/xxx.css中，那么要返回../ return './'; &#125;, &#125; &#125;, // style-loader不能引入否则会报错 'css-loader' ] &#125;, &#123; test: /\\.scss$/, // 配置scss // use: ['style-loader', 'css-loader', 'sass-loader'] use: [ &#123; loader:MiniCssExtractPlugin.loader, options: &#123; publicPath: (resourcePath, context) =&gt; &#123; return './'; &#125;, hmr: process.env.NODE_ENV === 'development' &#125;, &#125;, // style-loader不能引入否则会报错 'css-loader', 'sass-loader' ] &#125;, ] &#125;&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/tags/webpack/"}]},{"title":"typescript随手笔记1","slug":"typescript随手笔记1","date":"2019-10-02T15:33:15.000Z","updated":"2019-10-05T15:34:14.034Z","comments":true,"path":"2019/10/02/typescript随手笔记1/","link":"","permalink":"https://haoge744.github.io/2019/10/02/typescript%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B01/","excerpt":"介绍TypeScript是Javascript的超集，具有静态类型特性，旨在简化大型JavaScript应用程序的开发，也被称为Javascript that scales(可扩展的JavaScript)","text":"介绍TypeScript是Javascript的超集，具有静态类型特性，旨在简化大型JavaScript应用程序的开发，也被称为Javascript that scales(可扩展的JavaScript) 优点 在开发周期中能更早地捕获潜在的错误。 管理大型代码库 更易于重构 更易于团队合作：代码的耦合性越强，不同开发人员访问代码库时越不容易造成无意的破坏 文档特性：类型本身就是一种文档信息，方便日后开发者本人或者其他开发者查询。 缺点 需要学习周期 类型错误多种多样 配置极大地影响运行 TS的类型Boolean1const loading: boolean = true; Number12const decimal: number = 1;const binary: number = 0b110; String1const str: string = 'hello world' Array123let arr: Array = [2,4,5,6]// 使用泛型let arr2: Array&lt;number&gt; = [2,6,55] Tuple(元组)数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。 1let tom: [string, number] = ['Tom', 25]; Any (任意类型)123let variable: any = 123variable = 'bbb'variable = [12,23] void 空值void表示没有任何类型。它通常用作没有返回值的函数的返回类型 123function sayHello(name: string): void &#123; console.log(`hello $&#123;name&#125;`)&#125; Neverneverl类型表示的是那些用不存在的值得类型。一般用于错误处理函数 123function error(message: string): never &#123; throw new Error(message);&#125; 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 12var a: string | number = 'abc'a = 212 Null &amp; Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： 12let u: undefined = undefined;let n: null = null; undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12345678&#x2F;&#x2F; 这样不会报错let num: number &#x3D; undefined;&#x2F;&#x2F; 这样也不会报错let u: undefined;let num: number &#x3D; u;&#x2F;&#x2F; 这样会报错let u: void;let num: number &#x3D; u;&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;. 下一篇会写些关于接口和类相关的内容 更多详细内容推荐阅读此篇教程","categories":[{"name":"typescript","slug":"typescript","permalink":"https://haoge744.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://haoge744.github.io/tags/typescript/"}]},{"title":"moment.js基础使用","slug":"moment-js基础使用","date":"2019-09-28T15:09:16.000Z","updated":"2019-09-28T15:09:16.000Z","comments":true,"path":"2019/09/28/moment-js基础使用/","link":"","permalink":"https://haoge744.github.io/2019/09/28/moment-js%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"moment.js基础使用开发中不可避免的会经常碰到一些对日期的操作，使用moment.js可以很简单的实现很多对日期的一些操作，像日期的格式化，转换，计算，当月的第一天或最后一天等等之类的需求，它都可以快速实现。","text":"moment.js基础使用开发中不可避免的会经常碰到一些对日期的操作，使用moment.js可以很简单的实现很多对日期的一些操作，像日期的格式化，转换，计算，当月的第一天或最后一天等等之类的需求，它都可以快速实现。 安装moment.js也支持使用包管理器安装 123npm install moment// or &lt;script src=\"moment.js\"&gt;&lt;/script&gt; 创建moment对象12345moment() // 当前时间moment().format('YYYY-MM-DD HH:mm:ss') // 当前事件格式化moment('2019-12-12 ', 'YYYY-MM-DD') // 字符串格式化转为对象moment(new Date().getTime()) // 使用时间戳毫秒转const day = moment(\"1995-12-25\"); 格式化1moment().format('YYYY-MM-DD') 日期计算123456moment().days(3) // days函数取得是在周中的天数，比如传入3求的是下个周三的日期moment().day(-7); // 上周三 (0 - 7)// weekday的用法和days大致相同moment().weekday(3) // 获取本周三的日期moment().weekday(-1) // 获取上周末的日期 相当于这周一减1的日期moment().weekday(-10) // 获取上上周周五的日期 本周-10 日期加减12moment().add(1, 'days') // 可以使用简写moment().subtract(1, 'days') // 求昨天的日期 Key Shorthand years y quarters Q months M weeks w days d hours h minutes m seconds s milliseconds ms 日期相减12// 计算当前两个日期相差多少天moment().diff(moment('2019-08-05', 'YYYY-MM-DD'), 'days') 获取最后一天1234567// 获取当月最后一天的日期moment().endOf('month').format('YYYY-MM-DD')// 获取当年最后一天的日期 moment().endOf('year').format('YYYY-MM-DD')// 这样也可以获取当年最后一天的日期moment().month(11).endOf('month')moment('2018-05-24','YYYY-MM-DD').endOf('month') // 2018-05-31 我目前常用的也就是格式化和互相转换,还有日期相减之类的，具体更多方法请参照官方api文档","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"moment","slug":"moment","permalink":"https://haoge744.github.io/tags/moment/"}]},{"title":"vue-cli3.0升级","slug":"vue-cli3-0升级","date":"2019-09-15T15:29:49.000Z","updated":"2019-09-15T15:29:49.000Z","comments":true,"path":"2019/09/15/vue-cli3-0升级/","link":"","permalink":"https://haoge744.github.io/2019/09/15/vue-cli3-0%E5%8D%87%E7%BA%A7/","excerpt":"全局安装目前执行 install Vue-cli -g命令只会安装到Vue-cli 2.9.6,因为Vue cli以后的版本改了包名 改为了 @vue/cli 所以要先卸载掉Vue-cli 2.x.x的版本,在进行安装 12npm uninstall -g vue-clinpm install -g @vue/cli 12yarn global remove vue-cliyarn global add @vue/cli","text":"全局安装目前执行 install Vue-cli -g命令只会安装到Vue-cli 2.9.6,因为Vue cli以后的版本改了包名 改为了 @vue/cli 所以要先卸载掉Vue-cli 2.x.x的版本,在进行安装 12npm uninstall -g vue-clinpm install -g @vue/cli 12yarn global remove vue-cliyarn global add @vue/cli 创建vue-cli3项目1234567891011vue create &lt;projectName&gt;&#x2F;&#x2F; 之后可以选择以下选项 (空格&#x3D;单选 a&#x3D;全选 i&#x3D; 反选)1. Babel 使用babel做编译以兼容IE浏览器2. TypeScript 支持TypeScript3. Progressive Web App (PWA) support 支持pwa应用4. router 路由5. vuex 状态管理6. Css Pre-processors css 预处理7. Linter &#x2F; Formatter 代码风格校验8. Unit Testing 单元测试9. E2E Testing 端对端测试 除了使用命令行创建项目还可以使用图形化界面创建 1vue ui 运行命令后会自动打开浏览器，点击选择好目录可以点击在此创建新项目创建项目了， 然后输入一些基本信息 然后选择项目配置，我选了手动配置,然后可以选择一些基本功能，router,vuex,linter,css预处理之类的功能，css预处理有scss、less、stylus之类。全部选好之后就会自动创建项目了。 创建完成后可以进入图形化的项目管理界面。功能分为5个大模块 项目仪表盘 可以做一些之运行任务、关闭端口、更新插件依赖的功能(可以自定义菜单) 插件 可以查看、安装插件。 依赖 可以查看、安装依赖。 配置 对Vue Cli、Eslint、Css编译进行配置 任务 一些运行、构建、lint之类的指令。 vue-ui具体更多功能和效果需要自己动手去摸索。 启动123cd &lt;project-name&gt;npm run servenpm run build // 构建 启动参数: 123456789vue-cli-service serve [options] [entry]选项： --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false) 构建参数: 12345678910111213用法：vue-cli-service build [options] [entry|pattern]选项： --mode 指定环境模式 (默认值：production) --dest 指定输出目录 (默认值：dist) --modern 面向现代浏览器带自动回退地构建应用 --target app | lib | wc | wc-async (默认值：app) --name 库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名) --no-clean 在构建项目之前不清除目标目录 --report 生成 report.html 以帮助分析包内容 --report-json 生成 report.json 以帮助分析包内容 --watch 监听文件变化 工程结构 Vue-cli3目录 123456789101112131415┌─src 源码目录│ └─assets 资源目录│ └─components 组件目录│ └─api 后端交互相关模块(需自己手动添加,这里只是建议)│ └─views 所有路由组件│ └─router 所有路由配置文件目录│ └─store 所有状态管理配置文件目录│ └─main.js vue入口文件│ └─App.js 入口vue文件├─package.json 项目基本信息,包依赖信息等├─platforms 存放各平台专用页面的目录，详见├─public public静态资源文件，打包时会被复制到输出目录(dist)中│ └─index.html│ └─favicon.ico├─vue.config.js 可选配置文件，下面会介绍 可以看到Vue Cli3和Vue Cli2相比少了config和build文件夹，少了很多配置文件，变得更加简洁。但是如果要修改webpack相关配置的话需要就用到vue.config.js文件了。 vue.config.js部分属性说明: 12345678910111213141516171819202122232425262728293031323334353637383940module.export&#123; // 做文件打包后部署用的。如果你的公共路径是 http://www.xxx.com 那么使用默认的 '/' // 如果是 http://www.xxx.com/app 则需要修改成'/app' publicPath: '/', // 最新版本使用publicPath替代原来的 baseUrl outputPath: 'dist', // 构建之后 lintOnSave: true, // 是否在保存时执行eslint检查 devServer: &#123; host: '', port: 8181, open: true, //配置自动启动浏览器 proxy: &#123; ... &#125; &#125;, configureWebpack: &#123; // Object | Function plugs: [ new webpack.DefinePlugin(&#123; // 使用definePlugin定义全局变量 'process.env.api_url': '', &#125;) ] &#125;, chainWebpack(config) &#123; // 使用chainWebpack自定义loader config.module .rule('svg') .exclude.add(resolve('src/icons')) .end() config.module // 使用svg-sprite-loader组件加载svg文件 .rule('icons') .test(/\\.svg$/) .include.add(resolve('src/icons')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options(&#123; symbolId: 'icon-[name]' &#125;) .end() &#125;, pluginOptions: &#123;&#125; // 第三方插件配置 &#125; 关于vue-config的更多配置请参考官方文档 配置环境变量前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。 Vue Cli2.x.x的配置主要是在 config/dev.env.js 和config/prod.env.js中配置,但是到了Vue Cli3后这个配置文件没有了，但是不用担心，到了Vue Cli3中后这个功能变得更加灵活了，可以配置更多种环境变量。 比如说我们配置开发、生产环境的后台地址变量: 123456&#x2F;&#x2F; 新建 &#39;.env.development&#39; 文件# api地址VUE_APP_BASE_API &#x3D; &#39;&#x2F;development&#x2F;api&#39;&#x2F;&#x2F; 新建 &#39;.env.production&#39; 文件# api地址VUE_APP_BASE_API &#x3D; &#39;&#x2F;production&#x2F;api&#39; 新建完成后会自动根据当前运行环境来读取对应配置文件中的变量了。 自定义模式假如我们要创建一个预上线的环境需要另外一套配置,比如说叫做staging。 在package.json中添加一个命令(也可以在启动时添加 —mode参数) 1234567\"scripts\": &#123; \"scripts\": &#123; \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", \"staging\": \"vue-cli-service serve --mode staging\" &#125;, 创建 .env.staging, 文件后缀需要与 --mode 后面跟的值一样 12NODE_ENV &#x3D; &#39;production&#39;VUE_APP_BASE_API &#x3D; &#39;&#x2F;staging&#x2F;api&#39; 注意: 只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。 关于环境变量和模式的官方介绍文档 Tips安装Vue cli3前必须卸载Vue cli2,如果安装完Vue cli3 之后，还想用Vue-cli2.x 版本呢Vue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 Vue init 功能，你可以全局安装一个桥接工具： 123npm install -g @vue/cli-init// 安装完后 就还可以使用 vue init 命令vue init webpack my_project","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"webpack打包优化配置","slug":"webpack打包优化配置","date":"2019-09-03T03:38:49.000Z","updated":"2019-09-03T03:38:49.000Z","comments":true,"path":"2019/09/03/webpack打包优化配置/","link":"","permalink":"https://haoge744.github.io/2019/09/03/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/","excerpt":"关闭source-map配置关闭source-map之后可以大大减少打包后文件体积，关掉之后出现的弊端是如果出现报错信息，无法准确判断问题在哪。 1234567// config/index.js// 把productionSourceMap属性的true改成false即可生效module.exports = &#123; build: &#123; productionSourceMap: true =&gt; false &#125;&#125;","text":"关闭source-map配置关闭source-map之后可以大大减少打包后文件体积，关掉之后出现的弊端是如果出现报错信息，无法准确判断问题在哪。 1234567// config/index.js// 把productionSourceMap属性的true改成false即可生效module.exports = &#123; build: &#123; productionSourceMap: true =&gt; false &#125;&#125; gzip压缩优化gzip可以优化页面加载时的速度，这个操作需要后台配合开启gzip,并且安装compression-webpack-plugin的时候要注意版本，像我用的webpack 3.6安装了compression-webpack-plugin 3.0.0然后就出现错误了。 开启gzip后,js会生成js.gz文件，会略微增加打包文件的体积: 123456// Gzip off by default as many popular static hosts such as// Surge or Netlify already gzip all static assets for you.// Before setting to `true`, make sure to:// npm install --save-dev compression-webpack-pluginproductionGzip: false, 服务端开启gzip压缩: 修改服务器的配置，这里的服务器是Nginx找到conf目录下的nginx.conf ,开启gzip,并设置gzip的类型，如下开启后，访问服务器的js文件时，会优先查找.gz文件，如果没有则会查找.js文件 123456gzip on; #开启或关闭gzip on offgzip_disable &quot;msie6&quot;; #不使用gzip IE6gzip_min_length 100k; #gzip压缩最小文件大小，超出进行压缩（自行调节）gzip_buffers 4 16k; #buffer 不用修改gzip_comp_level 5; #压缩级别:1-10，数字越大压缩的越好，时间也越长gzip_types text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png; # 压缩文件类型 HappyPack插件优化由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以Webpack 需要处理的事情需要一件一件的做，不能多件事一起做。我们需要Webpack 能同一时间处理多个任务，发挥多核 CPU 电脑的威力，HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 安装: 1npm i -D happypack 在webpack.config.js中添加plugins 123456789101112131415161718module.exports = &#123; // ... 一些模块配置 plugins: [ // ... 一些插件配置 new HappyPack(&#123; //用id来标识 happypack处理那里类文件 id: 'happyBabel', //如何处理 用法和loader 的配置一样 loaders: [&#123; loader: 'babel-loader?cacheDirectory=true', &#125;], //共享进程池 threadPool: happyThreadPool, //允许 HappyPack 输出日志 verbose: true, &#125;) ]&#125; 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块作用:优化打包速度 因此我们首先需要在我们的项目根目录下创建一个 webpack.dll.config.js 文件。然后配置代码如下： 123456789101112131415161718192021222324252627282930313233343536const path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = &#123; // 入口文件 entry: &#123; // 项目中用到该两个依赖库文件 jquery: ['jquery'], echarts: ['echarts'] &#125;, // 输出文件 output: &#123; // 文件名称 filename: '[name].dll.js', // 将输出的文件放到dist目录下 path: path.resolve(__dirname, 'dist'), /* 存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll 是为了防止全局变量冲突。 */ library: '_dll_[name]' &#125;, plugins: [ // 使用插件 DllPlugin new DllPlugin(&#123; /* 该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。 比如在jquery.manifest文件中有 name: '_dll_jquery' */ name: '_dll_[name]', /* 生成manifest文件输出的位置和文件名称 */ path: path.join(__dirname, 'dist', '[name].manifest.json') &#125;) ]&#125;; 在webpack.config.js中配置它: 1234567891011121314151617// 引入 DllReferencePluginconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');// 使用插件module.exports = &#123; plugins: [ // 告诉webpack使用了哪些第三方库代码 new DllReferencePlugin(&#123; // jquery 映射到json文件上去 manifest: require('./dist/jquery.manifest.json') &#125;), new DllReferencePlugin(&#123; // echarts 映射到json文件上去 manifest: require('./dist/echarts.manifest.json') &#125;) ]&#125; 执行构建： 最后一步就是构建代码了，先生存第三方库文件，因此我们运行如下命令： 1webpack --config webpack.dll.config.js 在package.json中添加如下代码: 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline&quot;, &quot;build&quot;: &quot;webpack --progress --colors --devtool cheap-module-source-map&quot;, &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js&quot;&#125;, 最后运行npm run build:dll打包即可 按需引入组件实现优化打包体积如果只需要一个库的一部分功能，尽量按需导入而不是使用 Vue.use(Plugin)","categories":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/tags/webpack/"}]},{"title":"vue性能优化9法","slug":"vue性能优化","date":"2019-09-01T08:46:07.000Z","updated":"2019-09-01T10:58:14.360Z","comments":true,"path":"2019/09/01/vue性能优化/","link":"","permalink":"https://haoge744.github.io/2019/09/01/vue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"在2019年3月VueConf US大会上，有人分享了一个Vue性能优化9法的相关演讲，在此和大家分享。 演讲视频 http://www.youtube.com/watch?v=5B66qer8cZo 演讲稿 https://slides.com/akryum/vueconfus-2019#/ 演示网站 https://vue-9-perf-secrets.nettlify.com 演示代码 https://github.com/Akryum/vue-9-perf-secrets","text":"在2019年3月VueConf US大会上，有人分享了一个Vue性能优化9法的相关演讲，在此和大家分享。 演讲视频 http://www.youtube.com/watch?v=5B66qer8cZo 演讲稿 https://slides.com/akryum/vueconfus-2019#/ 演示网站 https://vue-9-perf-secrets.nettlify.com 演示代码 https://github.com/Akryum/vue-9-perf-secrets 函数型组件优化前 1234567891011&lt;template&gt; &lt;div class=\"cell\"&gt; &lt;div v-if=\"value\" class=\"on\"&gt;&lt;/div&gt; &lt;section v-else class=\"off\"&gt;&lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; props:['value'] &#125;&lt;/script&gt; 优化后 123456789101112&lt;template functional&gt; &lt;div class=\"cell\"&gt; &lt;div v-if=\"props.value\" class=\"on\"&gt;&lt;/div&gt; &lt;section v-else class=\"off\"&gt;&lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['value']&#125;&lt;/script&gt; 可以看到两段代码的不同仅仅是 template标签加了一个functional属性，加了这个属性有什么用呢，就是把当前组件变成函数组件，他的一系列生命周期的钩子方法不会调用。省去了这些钩子后，性能将会得到优化。 子组件拆分优化前 1234567891011121314&lt;template&gt; &lt;div :style=\"&#123; opacity: number / 300 &#125;\"&gt; &lt;div&gt;&#123;&#123; heavy() &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['number'], methods: &#123; heavy () &#123; /* 非常耗时，计算量大的处理 */ &#125; &#125;&#125;&lt;/script&gt; 优化后 123456789101112131415161718192021&lt;template&gt; &lt;div :style=\"&#123; opacity: number / 300 &#125;\"&gt; &lt;ChildComp/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['number'], components: &#123; ChildComp: &#123; methods: &#123; heavy () &#123; /* 耗时计算逻辑放到子组件当中 */ &#125; &#125;, render (h) &#123; return h('div', this.heavy()) &#125; &#125; &#125;&#125;&lt;/script&gt; 在主组件当中把一个非常耗时耗性能的处理仅仅放在method中，那么每次组件更新时，都会重新调用一下，这样非常耗性能。那么优化之后，把耗时的逻辑放到了子组件中，那么主组件更新，也不会重新计算，提高了性能。 局部变量优化前 123456789101112131415161718192021&lt;template&gt; &lt;div :style=\"&#123; opacity: start / 300 &#125;\"&gt;&#123;&#123; result &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; heavy &#125; from '@/utils'export default &#123; props: ['start'], computed: &#123; base () &#123; return 42 &#125;, result () &#123; let result = this.start for (let i = 0; i &lt; 1000; i++) &#123; result += heavy(this.base) // 每次调用计算属性 &#125; return result &#125; &#125;&#125;&lt;/script&gt; 优化后 1234567891011121314151617181920212223&lt;template&gt; &lt;div :style=\"&#123; opacity: start / 300 &#125;\"&gt; &#123;&#123; result &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; heavy &#125; from '@/utils'export default &#123; props: ['start'], computed: &#123; base () &#123; return 42 &#125;, result () &#123; const base = this.base // 先声明一个常量， let result = this.start for (let i = 0; i &lt; 1000; i++) &#123; result += heavy(base)// 每次计算时使用常量 &#125; return result &#125; &#125;&#125;&lt;/script&gt; 这个例子比较简单，在循环中处理比较复杂的逻辑时，推荐先声明常量，然后每次计算时用常量而不是计算属性。 活用v-show,减少v-if优化前 12345678910&lt;template functional&gt; &lt;div class=\"cell\"&gt; &lt;div v-if=\"props.value\" class=\"on\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/div&gt; &lt;section v-else class=\"off\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; 优化后 12345678910&lt;template functional&gt; &lt;div class=\"cell\"&gt; &lt;div v-show=\"props.value\" class=\"on\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/div&gt; &lt;section v-show=\"!props.value\" class=\"off\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; 这个也很简单，v-if显示和隐藏时，是删除和新增dom，而v-show是控制dom的css来隐藏显示，所以隐藏显示频繁的组件最好用v-show。 使用keep-alive优化前 12345&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 优化后 1234567&lt;template&gt; &lt;div id=\"app\"&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 保持页面cache，提高页面加载效率 活用延迟装载(Defer)优化前 123456789&lt;template&gt; &lt;div&gt; &lt;h2&gt;I'm an heavy page&lt;/h2&gt; &lt;Heavy v-for=\"n in 10\" :key=\"n\"/&gt; &lt;Heavy class=\"super-heavy\" :n=\"9999999\"/&gt; &lt;/div&gt;&lt;/template&gt; 优化后 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;h2&gt;I'm an heavy page&lt;/h2&gt; &lt;template v-if=\"defer(2)\"&gt; &lt;Heavy v-for=\"n in 10\" :key=\"n\"/&gt; &lt;/template&gt; &lt;Heavy v-if=\"defer(3)\" class=\"super-heavy\" :n=\"9999999\"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Defer from '@/mixins/Defer'export default &#123; mixins: [ Defer() ]&#125;&lt;/script&gt; 延迟加载各组件，使用户感觉界面加载流畅 123456789101112131415161718192021222324252627282930313233// Defer.jsexport default function (count = 10) &#123; // @vue/component return &#123; data () &#123; return &#123; displayPriority: 0, &#125; &#125;, mounted () &#123; this.runDisplayPriority() &#125;, methods: &#123; runDisplayPriority () &#123; const step = () =&gt; &#123; requestAnimationFrame(() =&gt; &#123; this.displayPriority++ if (this.displayPriority &lt; count) &#123; step() &#125; &#125;) &#125; step() &#125;, defer (priority) &#123; return this.displayPriority &gt;= priority &#125;, &#125;, &#125;&#125; 分批处理(Time Sicing)优化前 1234fetchItems (&#123; commit &#125;, &#123; items &#125;) &#123; commit('clearItems') commit('addItems', items)&#125; 优化后 12345678910111213141516fetchItems (&#123; commit &#125;, &#123; items, splitCount &#125;) &#123; commit('clearItems') const queue = new JobQueue() splitArray(items, splitCount).forEach( chunk =&gt; queue.addJob(done =&gt; &#123; // Commit array chunks on several frames requestAnimationFrame(() =&gt; &#123; commit('addItems', chunk) done() &#125;) &#125;) ) // Start and wait for all the jobs // to finish await queue.start()&#125; 未优化时，同时处理两个提交操作，操作效率慢，把任务分成块执行，按顺序执行，提高渲染性能 非相应模式(non-reactive)优化前 1234567const data = items.map( item =&gt; (&#123; id: uid++, data: item, vote: 0 &#125;)) 优化后 12345678910111213141516const data = items.map( item =&gt; optimizeItem(item))function optimizeItem (item) &#123; const itemData = &#123; id: uid++, vote: 0 &#125; Object.defineProperty(itemData, 'data', &#123; // Mark as non-reactive configurable: false, value: item &#125;) return itemData&#125; 在上面，使用map方法来遍历更改对象，每次在循环中赋值时，会改变原对象。并且会触发vue的监视机制从而更新组件。在优化之后，取消了vue对itemData对象的观察，这样不会触发多余的监视方法。从而提高了效率。 仅渲染可视化部分优化前 12345678&lt;div class=\"items no-v\"&gt; &lt;FetchItemViewFunctional v-for=\"item of items\" :key=\"item.id\" :item=\"item\" @vote=\"voteItem(item)\" /&gt;&lt;/div&gt; 优化后 123456789101112&lt;recycle-scroller class=\"items\" :items=\"items\" :item-size=\"24\"&gt; &lt;template v-slot=\"&#123; item &#125;\"&gt; &lt;FetchItemView :item=\"item\" @vote=\"voteItem(item)\" /&gt; &lt;/template&gt;&lt;/recycle-scroller&gt; 优化前:一下就选软所有数据项。优化后：只渲染24个组件，只渲染用户能看到的数据。提高渲染性能。 总结对于简单的页面，可以忽略优化细节，重点可以放在功能实现上，尤其在工期紧张的时候。而对于页面复杂，计算逻辑过多的应用时，应该充分考虑使用优化技巧。不过在时间充足的情况下，可以考虑把性能以及资源加载这部分优化到极致，这不但使应用变得更好，对自己更是一个提升。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"围棋入门","slug":"围棋入门","date":"2019-08-31T04:55:09.000Z","updated":"2019-09-01T08:42:57.295Z","comments":true,"path":"2019/08/31/围棋入门/","link":"","permalink":"https://haoge744.github.io/2019/08/31/%E5%9B%B4%E6%A3%8B%E5%85%A5%E9%97%A8/","excerpt":"有段时间对围棋比较感兴趣，不过之前对于围棋的规则还不是很了解，只是觉得围棋很复杂、深奥。于是在B站上补了补课，学习了围棋的相关规则，还有就是看了一下名局的讲解(看不太懂，但感觉很厉害)。可能现在人们下的比较多的就是象棋、五子棋这些吧。还有比较有名的是国际象棋和日本的将棋。国际象棋和中国象棋很像，但是有一些特殊的规则，比如王车易位、吃过路兵、小兵升级等。将棋的规则相比前两个要复杂很多，先是将棋棋子中几乎所有棋子都可以升级，并且吃完对手的棋子后，可以归为己用，重新下在棋盘上。这个规则大幅度提高了将棋的复杂度。中国象棋、国际象棋、将棋这三种棋都有一些相同的地方,比如开局要摆放好固定的阵型，获胜的方式都是将死对面的老大。围棋和它们不一样，一开始要双方自己布局，下棋的方式也不一样，以上三种棋是运子，围棋是落子。","text":"有段时间对围棋比较感兴趣，不过之前对于围棋的规则还不是很了解，只是觉得围棋很复杂、深奥。于是在B站上补了补课，学习了围棋的相关规则，还有就是看了一下名局的讲解(看不太懂，但感觉很厉害)。可能现在人们下的比较多的就是象棋、五子棋这些吧。还有比较有名的是国际象棋和日本的将棋。国际象棋和中国象棋很像，但是有一些特殊的规则，比如王车易位、吃过路兵、小兵升级等。将棋的规则相比前两个要复杂很多，先是将棋棋子中几乎所有棋子都可以升级，并且吃完对手的棋子后，可以归为己用，重新下在棋盘上。这个规则大幅度提高了将棋的复杂度。中国象棋、国际象棋、将棋这三种棋都有一些相同的地方,比如开局要摆放好固定的阵型，获胜的方式都是将死对面的老大。围棋和它们不一样，一开始要双方自己布局，下棋的方式也不一样，以上三种棋是运子，围棋是落子。 围棋易学难精！！！ 围棋的规则十分简单，却拥有十分广大的空间可以落子，使得围棋变化多端，比象棋更为复杂。这就是围棋的魅力所在。下一盘围棋的时间没有规定，快则五分钟，慢则要几天，多数时候下一盘棋需要一到二个小时。首先，它包含着极为丰富的哲学内涵：哲学家可以从中领悟到哲学矛盾范畴中对立与统一规律，量变与质变规律，否定之否定规律。现象与本质，认识与实践等等辩证关系。 军事家可以从中领悟到军事领域内斗智斗勇的奥秘，历史上有很多的军事家都是围棋高手，如曹操，谢玄等都精通围棋。有很多围棋理论著作都是借战争理论加以阐述的。汉马融的《围棋赋》上说：“观围棋兮，法于用兵，三尺之局兮，为战斗场”。宋围棋国手刘仲青《棋诀》中写道：盖布棋之先务，如兵之先阵而后敌也。围棋十诀与毛老人家的十大军事原则有异曲同工之妙。 另外围棋具备修身益智的作用。关于围棋是早的说法就是：昔者尧造围棋以教彤朱。并且在历史上围棋向来与神仙有不解之缘，从烂柯故事到很多名画，中间的道具都基本上是围棋。 介绍围棋，起源于中国，中国古代称为“弈”，可以说是棋类之鼻祖，围棋至今已有4000多年的历史。据先秦典籍《世本》记载，“尧造围棋，丹朱善之。”晋张华在《博物志》中继承并发展了这种说法：“尧造围棋，以教子丹朱。若白：舜以子商均愚，故作围棋以教之。” 围棋的规则围棋是一个圈地盘的游戏，谁圈的地盘大，谁就获胜。围棋棋盘由19*19组成，形成361个交叉点，棋子下在交叉点上而不是格子里，棋盘上有9个黑点，称为星位，中间的那个最特殊，只有它没有对称的点。称为天元。一个棋子下在棋盘上，他的相邻的上下左右四个相邻点称之为这个棋子的气。注意斜方向不算，如果有相邻的棋子连在一起，可以把这两个棋子看成是一个整体，他们的气是共享的。如下图,左边的白棋有9气，右边的白棋有6气。气没有了，棋子就死了,如下图，如果白棋下在A点黑棋就死了,这时候这个棋子就要从棋盘上拿掉了。 禁入点围棋的棋子不能下在不入气的地方，这个地方也称为禁入点，如下图，白棋是不能下在A的位置的，因为一下在棋盘上，他就没有气了，所以这个点是白棋的禁入点。如下图但是也有例外，我们看下图的这个棋形。白棋先行，按理来说白棋不能下在A这个位置，因为一下在棋盘上，就没有气了。但是白棋下下来之后，上面的黑棋被吃掉了，这时候黑棋被提子之后，白棋又有气了。所以这种情况白棋是可以下在A点的。但是我们观察发现，这时候黑棋又可以下在刚刚被吃掉的地方，再把A点的白棋吃掉。再之后白棋又可以下在A点的地方吃掉黑棋… 那这样不是没完没了吗。所以围棋中有一个规定，刚刚被吃掉子的那个点，第一手不可以再落子。比如说第一手白棋下在A的位置，吃掉了黑棋，那么黑棋不能马上在B下棋了。这种情况围棋术语称为打劫，之后黑棋在其他地方落子，称为找劫财。如果白棋在被吃黑子后再下在B点，那么这个打劫就结束了。 围棋的”死” “活” 在围棋的范围中，研究单方死或活的关于眼的问题叫做死活。死活是围棋的根本，要想围棋计算力提高必须做死活题，否则棋艺不会提高。 随着棋局的进行，棋盘上最后剩下的就只会有活棋，那么什么是活棋?就是永远都有气的棋，那么怎样才能让棋永远都有气呢?可以看下面这个棋形.可以看到黑棋中间是围了两个禁入点，白棋不论怎么围，始终不能把黑棋的气给杀干净，所以黑棋是活棋.因为黑棋围住的两个点像两只眼睛。所以我们把不入气点成为”眼”。想要活棋必须要做出两个或两个以上的眼 假眼我们看上面这个棋形，虽然黑棋好像做出了两个眼，但是我们发现，黑棋下面有一颗棋子被白棋打吃了，只要白棋下在B的位置，那么黑棋的这个眼就被破坏掉了，那这个时候黑棋就只剩下一只眼了，那么黑棋只剩一只眼是不能活棋的，最后还是会被白棋给吃掉。那么稍微调整下棋形，思考下面这个棋形，黑棋是死棋还是活棋。 双活双方棋子互相包围，且不具备两只真眼，形成双方均不能杀死对方的局面，此时双方都算活棋，这种活棋的方法叫作双活。 我们看到，黑白双方都不能落子，如果谁先动手，那么反过来会被对方吃掉。这种棋形就是双活。 死活题如果下面这个棋形黑棋先下，怎么杀掉白棋呢？ 只要黑棋下在B点，那么白棋就死了，我们从上面的结论得出，想要活棋必须有两个眼，所以我们把黑棋下在B点，白棋就没有空间做出两个眼。那么白棋就死了。反过来，如果白棋先下，下在B点就是活棋了。 棋局的胜负如果不是有一方中盘认输的情况下，下到围棋上不能在下的情况下，棋局就结束了。那么如何判断棋局的胜负呢? 本文一开头说了，围棋是一个圈地盘的游戏，谁的地盘大谁就赢。中国规则是子空皆地，什么意思呢，就是你下在棋盘上的棋子+你围住的空的总数~~谁的总数多，谁就赢 用己方棋子围住的棋盘上的交叉点，这些交叉点叫“目”，也叫“空”，常说这块有“N目空”；对局过程中被吃掉的子，终局后要放回己方的空内；然后比较哪方的“空”多，与棋盘上存在多少棋子无关。 日韩规则都规定，黑方先行，因此贴6.5目，因此日韩规则下的胜负结果就是“黑胜半目”或“黑胜N目半”。 一颗子的价值等于两目，中国规则黑贴3又3/4子，换算成目就是7.5目。两相比较，同样执黑棋，用中国规则就比用日韩规则稍微吃亏。 围棋的三个阶段布局 布局，又称布石，围棋术语，指围棋的开局走法，一般在几手到几十手的范围内。 布局阶段的主要目标是抢占空地，因为在角上的围空效率更高，所以初期棋盘的四个角上的争斗会比较多。古力的布局(执黑) 中盘 中盘是围棋术语。进入中盘阶段后，棋局变化莫测。所以，中盘战斗力量是棋手提高棋力的关键，是下棋者的乐趣所在，也是围棋艺术美的根本。相对而言，布局和收官可以从书籍、定式和高手的对局通过模仿学习，而中盘战斗则是围棋中最难以掌握的技术之一。 中盘的阶段，落子要注意效率，不能靠的太近，靠的太近效率低，围空少，也不能靠的太远，太远容易被分隔开。并且要注意棋子的死活。中盘阶段的变化非常多，这里不多细说，可以自己下下看。 收官 收官是一个汉语词语，拼音是shōu guān，又称“作官子”，是围棋比赛中三个阶段（布局、中盘、官子）中的最后一个阶段，指双方经过中盘的战斗，地盘及死活已经大致确定之后，确立竞逐边界的阶段。 收官阶段，棋盘上已经下满了棋子了，这个阶段开始争抢一些所剩无几的利益。很多时候棋局并不会进入到收官阶段，因为如果中盘阶段出现了较大的悬殊，那么落后的一方很可能就投资认输了。如果能进入到收官阶段说明双方的底盘是不分伯仲的。这个时候每步棋就要精打细算，寸土必争。不要小看一些细小的利益，很多时候就是因为半目的差距就会输掉比赛。 对弈我上面使用的围棋打谱软件叫MultiGo,也可以支持和ai对战，但是要下一个GNUGO的ai引擎,棋力对于初学者来说已经非常强了。另外也可以去弈城围棋、腾讯围棋等网络平台在线与人对弈。 MultiGo下载地址 GNU Go官方下载地址","categories":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}],"tags":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"},{"name":"围棋","slug":"围棋","permalink":"https://haoge744.github.io/tags/%E5%9B%B4%E6%A3%8B/"}]},{"title":"vue中使用stylus","slug":"vue中使用stylus","date":"2019-08-29T05:38:03.000Z","updated":"2019-08-29T05:55:07.088Z","comments":true,"path":"2019/08/29/vue中使用stylus/","link":"","permalink":"https://haoge744.github.io/2019/08/29/vue%E4%B8%AD%E4%BD%BF%E7%94%A8stylus/","excerpt":"介绍stylus是css的预处理框架。和Sass、Less是一类东西。在stylus中可以 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件。","text":"介绍stylus是css的预处理框架。和Sass、Less是一类东西。在stylus中可以 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件。 安装1cnpm install stylus stylus-loader --save-dev 在组件中使用执行完安装命令之后不需要任何配置就可以使用了。 在组件中使用只要把在style标签中增加lang=&quot;stylus&quot;就可以用了 在vue文件中引用12345&lt;style lang=\"stylus\"&gt; @import \"assets/common.styl\"; .main_wrapper padding 12 20px&lt;/style&gt; stylus 编码风格123456789101112131415161718$shadow = 0px 3px 6px -2px rgba(0,0,0,0.3)// mixinsflexvc() display flex items-align center// methodadd (a,b = 10) a + b // 函数可省略返回值.card.card2 box-shadow $shadow &amp;:hover background-color #F4F5F6 .footer border-top #ededef 可以看到stylus的写法非常简洁，层级关系使用缩进来表示，分号、冒号、大括号都是可选项，可写可不写。 使用语法 选择器stylus选择器规则和css一样.class选择、#id选择、[type=textarea]属性选择器等等 12p color #f00 编译后 123p&#123; color: #f00;&#125; 多个选择器共用 12345.card,.boxor .card.box box-shadow 0px 3px 6px -2px rgba(0,0,0,0.3) 父级引用,stylus中使用&amp;指向父选择器，可以用来做各种伪类选择器，伪元素等等 1234567li background-color #F3F4F5 border-bottom 1px solid #f4f5f6 &amp;:hover background-color #ccc &amp;:last-child border-bottom none 变量 123primary-bg = #3A75E7.main_wrapper background-color primary-bg 标识符（变量名，函数等），也可能包括$字符。例如： 123$font-size = 14pxp font-size $font-size 属性查找 Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下： 12345678#logo position: absolute top: 50% left: 50% width: w = 150px height: h = 80px margin-left: -(w / 2) margin-top: -(h / 2) 我们不使用这里的变量w和h, 而是简单地前置@字符在属性名前来访问该属性名对应的值： 12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 函数一个简单的函数 1234add(a,b) a + b // 省略returnbody padding add(10px, 5) 默认参数 123456add(a, b =a) a = unit(a, px) // unit把单位都变成px b = unit(b, px) a + badd(15%, 10deg) // =&gt; 25 多个返回值 123456paddings() 25px 12px.main padding paddings() // 编译后 =&gt; padding: 25px 12px; 混合混合和函数定义差不多，但是效果不一样。函数有返回值，混合没有。比如我们想定义一个垂直居中的横向flex布局可以像下面这样: 12345flexvc() display flex align-items center.main-list flexvc() 父级引用比如说我们想创建一个条纹表格,even和odd均提供了默认颜色值，每行也指定了background-color属性。我们可以在tr嵌套中使用&amp;来引用tr，以提供even颜色。 123456stripe(even = #fff, odd = #eee) tr background-color odd &amp;.even &amp;:nth-child(even) background-color even 然后利用混合书写,如下: 1234567table stripe()table#data-grid stripe(#212121, #494848) td color white 插值 Stylus支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。例如，-webkit-{&#39;border&#39; + &#39;-radius&#39;}等同于-webkit-border-radius. 比较好的例子就是私有前缀属性扩展： 1234vendor(prop, args) &#123;prop&#125; args.well border-radius 4px 选择器插值 1234table for row in 1 2 3 4 5 tr:nth-child(&#123;row&#125;) height: 10px * row 编译后 123456789101112131415table tr:nth-child(1) &#123; height: 10px;&#125;table tr:nth-child(2) &#123; height: 20px;&#125;table tr:nth-child(3) &#123; height: 30px;&#125;table tr:nth-child(4) &#123; height: 40px;&#125;table tr:nth-child(5) &#123; height: 50px;&#125; 注释 单行注释 1// 单行注释 多行注释 123/* * 多行注释 */ 总结总的来说写法和很多css预处理语言很相似，但是stylus写法更简洁一些，入门也更简单。上面介绍到的功能和用法能满足大部分日常使用需要了。如果还需了解的更加深入的话可以去读下这份文档。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"h5常用新元素","slug":"h5常用新元素","date":"2019-08-25T13:49:03.000Z","updated":"2019-08-25T13:49:03.000Z","comments":true,"path":"2019/08/25/h5常用新元素/","link":"","permalink":"https://haoge744.github.io/2019/08/25/h5%E5%B8%B8%E7%94%A8%E6%96%B0%E5%85%83%E7%B4%A0/","excerpt":"过去的标签书写习惯了，其实有些更有语义化的标签可以代替div、span这些标签的。","text":"过去的标签书写习惯了，其实有些更有语义化的标签可以代替div、span这些标签的。 语义与结构元素: 标签 描述 定义了文档的头部区域 定义导航链接的部分 定义文档或节的页脚 底部 定义文章。潜在来源:论坛帖子、博客文章、新闻故事、评论 定义文档中的节（section、区段） 定义其所处内容之外的内容 侧边(侧边栏或者侧边菜单用的较多) 定义带有记号的文本。 定义日期或时间。(可以用来标记时间，行内元素，无任何样式) 规定独立的流内容（图像、图表、照片、代码等等）。(经常用于展示图片，和figcaption配合的多) 定义 元素的标题 多媒体元素 标签 描述 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API 定义音频内容 定义视频（video 或者 movie） 定义多媒体资源 和 定义嵌入的内容，比如插件。 为诸如 和 元素之类的媒介规定外部文本轨道。","categories":[{"name":"html","slug":"html","permalink":"https://haoge744.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://haoge744.github.io/tags/html/"}]},{"title":"vue自定义指令实现功能级权限","slug":"vue自定义指令实现功能级权限","date":"2019-08-24T01:00:31.000Z","updated":"2019-08-26T15:10:11.487Z","comments":true,"path":"2019/08/24/vue自定义指令实现功能级权限/","link":"","permalink":"https://haoge744.github.io/2019/08/24/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%BA%A7%E6%9D%83%E9%99%90/","excerpt":"自定义指令使用介绍在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。 自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。","text":"自定义指令使用介绍在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。 自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 钩子函数参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 功能实现权限的获取是在登录时获取，获取完之后缓存至cookie和vuex中，防止用户刷新后出现的问题。然后每次刷新初始化时尝试从cookie中取出权限项再次放入vuex。 123456789101112131415161718// store/morules/user.js 用户存储的状态信息import &#123;setRoles, getRoles&#125; from '@/utils/cookieHelper'import Vue from 'vue'const user = &#123; state: &#123; roles: getRoles() &#125;, mutations: &#123; SET_ROLES: (state, val) =&gt; &#123; setRoles(state, val) Vue.set(state,'roles', val) &#125; &#125;, actions: &#123; &#125;&#125;export default user 12345678910111213141516// cookieHelper.js import Cookies from 'js-cookie' // cookie存取使用了js-cookie的组件export function setRoles (roles) &#123; return Cookies.set('roles', roles.split())&#125;export function getRoles () &#123; // const roleStr = Cookies.get('roles') const roleStr = 'admin' // 先写死一个变量 利于测试 if (roleStr) &#123; return roleStr.split(',') &#125; else &#123; return [] &#125;&#125; 实现自定义指令功能1234567891011121314151617181920212223// 新建 directive/auth.jsimport Vue from 'vue'import store from '../store'Vue.directive('permission', &#123; inserted: (el, binding) =&gt; &#123; // 如果使用bind钩子会找不到父元素 const &#123; value &#125; = binding let hasPermission = false const myRoles = store.getters.roles if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0)&#123; hasPermission = value.some(item =&gt; &#123; return myRoles.includes(item) &#125;) &#125;else &#123; throw new Error('参数错误') &#125; if(!hasPermission)&#123; // 没有权限移除该元素 el.parentNode.removeChild(el) &#125; &#125;&#125;) 123 // 在main.js中引入auth.js// 测试成功后，把cookieHelper中的返回的权限改为其他值后，按钮隐藏了&lt;el-button v-permission=\"['add', 'admin']\"&gt;添加&lt;/el-button&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"活着-生命的意义","slug":"活着-生命的意义","date":"2019-08-19T15:27:05.000Z","updated":"2019-09-01T08:42:51.343Z","comments":true,"path":"2019/08/19/活着-生命的意义/","link":"","permalink":"https://haoge744.github.io/2019/08/19/%E6%B4%BB%E7%9D%80-%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89/","excerpt":"","text":"内容梗概主人公富贵在年轻时是一个地主家的大少爷，整天游手好闲，无所事事，又嫖又赌，每天还骑着一个胖嘟嘟的妓女和老丈人打招呼，还不以为耻。最终家产被败光。父亲被他气死。所幸妻子家珍对他不离不弃，并且激励富贵要好好生活。富贵好不容易又重燃对生活的信心，不料母亲病倒了，富贵去城里找郎中却又遇上了国民党抓壮丁。被编入了队伍，好不容易没被子弹打死，没有饿死，之后被共产党俘虏，费劲千辛万苦总算回到家乡。本以为回到家一切都会好起来，谁知却是悲剧的开端，母亲病逝了，女儿凤霞也因为发高烧没能及时医治成为了聋哑人。富贵心里别提多难受了。不过自己还有个儿子呢。不过烦心的事又来了，儿子有庆到了上学的年龄，但富贵却根本付不起学费。于是和家珍商量着把凤霞送去给有钱人当丫鬟，这才让儿子有学上。直到有一天凤霞因为太想念父母，而自己偷溜回家看看，富贵此时又舍不得送她走了，又将她留在家里，给家里的农活帮忙，日子也能过。一家人整整齐齐，日子也这么开心的过下去，直到有一天，有庆忽然死了，原来有庆因为跑去给县夫人输血，被医生活活抽血抽死在了医院里。本想着要找县长偿命，但县长居然是之前富贵的战友春生，富贵是即悲痛又无奈。家珍说她这辈子不会原谅春生，他欠她们家一条命。 日子又一天天的过去，没转眼凤霞也到了结婚的年纪，经人介绍认识了县城的工人二喜，虽说二喜有点残疾但是人憨厚老实对凤霞又体贴，不嫌弃凤霞不会说话，这么说来二喜对凤霞来说也算是个好归宿。只是没想到幸福这么短暂，凤霞因为生孩子大出血也死在了那家医院。留下一个男孩苦根。富贵的两个孩子相继去世后，家珍也因为辛苦劳作患上软骨病，最终也在家中逝世。一大家子只剩下富贵、女婿二喜和孙子苦根相依为命。几年后,二喜也因为工地发生意外死了。老年的富贵就把外孙苦根接回了乡下和富贵一起生活。一天富贵为苦根熬了豆子，便出去干活，哪想到，苦根因为很久没吃到好吃的，吃了太多的豆子，活活被撑死了。富贵眼睁睁的看着自己的亲人一个个离自己而去，现在只剩他一个人和一头牛陪伴了。 总结读完整本书，很庆幸自己活在一个比较安定的社会中。不会有不会有国民党抓壮丁，不会有大跃进吃不饱肚子也不会有文化大革命被批斗。 富贵在今天看来是旧社会的一个代表性悲剧人物，每次好像快要抓住幸福了，但是上天又会突如其来的给与下一场考验，把你迅速拉向地狱。或许这样的故事才贴近生活吧，才能引发读者的无限遐想。虽然年轻时不懂事，因为好赌败光了土地和家产。但是之后正好碰上土改。因为富贵家正好在这之前就已经是贫农了所以才幸免遇难。富贵是个乐观豁达的人，他在面对接踵而至的灾祸时，每次都能挺过来、能坚强的活着。我不知道如果我遇到富贵的遭遇我会不会对人生放弃希望，我经常思考人生活着的意义是什么，是奋发图强出人头地，还是只追求快乐只顾眼前。人们总说要知足，但是如果一知足就会安于现状不去做任何努力。也有人说人到了二十多岁就已经死了只是到八十岁才埋葬，之后工作，成家立业，然后又等着下一辈的出生。又让他们读书成家立业养育后代。如此反复,重复着一天天的生活，像一具行尸走肉。或许真像文中那样说的吧： “人应该为活着本身而活着，不是为了活着之外的任何事物所活着。” 家珍是我在文中很喜欢的人物，她是一个聪明善良坚强的人，富贵在赌场赌博的时候，家珍一直都想把他给拉走。只不过不得而终，自己一个人又走了十几里路回家，那个时候她可是大着肚子啊，可见家珍一直都是想把丈夫给拉回正轨的。并且富贵每次在妓院彻夜不归的时候，家珍也没有什么怨言，并且在外人面前也一直照顾丈夫的面子，替他说话。后面富贵家破产家珍也没有怨言跟着富贵搬到茅草屋住。后来家珍的父亲因为富贵败家把家珍给接走了。所幸后来又回来了，但是没有人知道她付出的代价是什么。在富贵服兵役的两年间，婆婆病倒，凤霞发烧变成聋哑人，她不知道富贵去了哪，也不知道他是否能回来，他只能自己在扛着。谁能知道她有多少次绝望，她在夜里哭过多少次呢。在大饥荒期间，好不容易拉下脸去父亲那要回了一小袋米。才让家里吃上了几顿粥，之后队长来苦苦相求要一点的时候家珍也没有吝啬，给了他一些带回给家里，由此可见她的善良。在有庆死后，富贵并没有马上告诉家珍，但家珍还是从丈夫的神情和反常的行为中发现了儿子已死，但是她并没有大哭大闹，反而只是提议带她去儿子的墓看一看。这段经历也体现出家珍的聪明和冷静。在我看来这样一个善良聪慧又忠诚的女子在现实中是不可多得的，也是现在女性学习的榜样。 写在后面这本小说是差不多2年前读的，剧情在脑中也有些模糊了，文中所有难免会有些误差。请见谅。","categories":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}],"tags":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"},{"name":"读后感","slug":"读后感","permalink":"https://haoge744.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"filco入手评测","slug":"filco入手评测","date":"2019-08-15T12:59:39.000Z","updated":"2019-09-01T14:22:40.853Z","comments":true,"path":"2019/08/15/filco入手评测/","link":"","permalink":"https://haoge744.github.io/2019/08/15/filco%E5%85%A5%E6%89%8B%E8%AF%84%E6%B5%8B/","excerpt":"使用感受话说花一千多块买一把键盘到底值不值？不过我为了体验顶级键盘的手感，还是忍痛割爱了。说实话这款键盘我早就看中了，犹豫了很久。最后还是没忍住哈哈。对于程序猿这种重度使用键盘的人群，给自己一把好一点的键盘，我觉得也是可以奖励给自己的啊。毕竟时不时给自己一个小礼物，有助于提升自己的幸福感呢。 包装图","text":"使用感受话说花一千多块买一把键盘到底值不值？不过我为了体验顶级键盘的手感，还是忍痛割爱了。说实话这款键盘我早就看中了，犹豫了很久。最后还是没忍住哈哈。对于程序猿这种重度使用键盘的人群，给自己一把好一点的键盘，我觉得也是可以奖励给自己的啊。毕竟时不时给自己一个小礼物，有助于提升自己的幸福感呢。 包装图 包装中规中矩吧，上面也显示支持有线和蓝牙连接，赠送了一个拔键器、防尘罩、两节电池、还有两个键帽，这个待会再说有什么用。 键盘整体图 从外观上说我觉得还可以，没有现在游戏键盘那么多花里胡哨的各种灯，各种特效。我比较喜欢这种稳重的黑，也没有背光灯。给人看起来比较低调。filco采用的是Abs材质的键帽，懂行的可能知道，Abs键帽虽然手感好，但是时间长了之后，键帽容易打油。个人更喜欢Abs的键帽，虽然Pbt的键帽不会打油，但是磨砂的手感完全比不上Abs类肤的手感。尤其是filco，键帽的厚度和大键的手感调试的非常好。大键和小键的手感几乎完全一样，一般中低端的樱桃轴键盘，大键的手感要么很肉，要么给人感觉就像黑轴一样 很硬。filco给人的感觉相当完美。 LOGO特写 由于我买的是青轴，声音非常清脆，打字声音比较大，但还可以接受。另外键盘手感比我的 IKBC DC108好了很多。IKBC给我的感觉有点偏硬了。因为我喜欢桌面整洁，所以选了双模版，这款键盘支持4台设备切换，但是它这个蓝牙连接方式，要看说明书才能学会。另外键盘右下方好像没有菜单键，这时候赠送的键帽就派上用场了，可以把右win换成菜单键，开一下键盘底下的一个开关就好了,然后换一下键帽，完美。 总结根据这几个星期的使用感受，我总结了以下优缺点：优点： 手感。filco的手感一直是它最大的卖点，这点我非常满意。 双模 没有线的束缚，如果再配上一个无线鼠标，简直爽的一批。 设计 键帽整体设计给我感觉落落大方，键帽的字体我也很喜欢，还有就是右上角雕刻的LOGO，设计也很棒。 缺点： 贵。 键帽易打油，这是Abs通用的缺点，使用1至2年就需要更换键帽了。","categories":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}],"tags":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}]},{"title":"嫌疑人X的献身读后感","slug":"嫌疑人X的献身读后感","date":"2019-08-12T16:05:57.000Z","updated":"2019-09-01T08:43:00.130Z","comments":true,"path":"2019/08/13/嫌疑人X的献身读后感/","link":"","permalink":"https://haoge744.github.io/2019/08/13/%E5%AB%8C%E7%96%91%E4%BA%BAX%E7%9A%84%E7%8C%AE%E8%BA%AB%E8%AF%BB%E5%90%8E%E6%84%9F/","excerpt":"内容简介:百年一遇的数学天才石神，每天唯一的乐趣，便是去固定的便当店买午餐，只为看一眼在便当店做事的邻居靖子。靖子与女儿相依为命，失手杀了前来纠缠的前夫。为救靖子，石神提出由他料理善后。石神以数学家缜密的逻辑思考设了一个匪夷所思的局，为靖子提供了天衣无缝的不在场证据，令警方始终只能在外围敲敲打打，根本无法与案子沾边。","text":"内容简介:百年一遇的数学天才石神，每天唯一的乐趣，便是去固定的便当店买午餐，只为看一眼在便当店做事的邻居靖子。靖子与女儿相依为命，失手杀了前来纠缠的前夫。为救靖子，石神提出由他料理善后。石神以数学家缜密的逻辑思考设了一个匪夷所思的局，为靖子提供了天衣无缝的不在场证据，令警方始终只能在外围敲敲打打，根本无法与案子沾边。 正文:看书封面的简介，确实很吸引读者去阅读，这本推理小说和普通推理小说不同的是，一开始就告诉你犯罪嫌疑人是谁了，真正让读者感兴趣的是，石神是利用什么手法和技巧和警方斗智斗勇,制造骗局的。 石神是个数学天才，深爱着数学，可以为了一道数学谜题孜孜不倦到深夜。某天早晨，石神像往常一样离开公寓，路过公园，径直去靖子打工的便利店买便当，路上碰到熟人打了个招呼，随后到了便利店。像往常一样来了一份便当打包带走，他依然不敢直视靖子。石神走后没多久，没想到靖子的前夫慎二又前来纠缠，在靖子家里成功索财后，还不忘威胁道：“你们逃不出我的手掌心”,这个时候实在忍不住的靖子的女儿美里给了他一榔头，慎二顿时大怒和母女厮打在一起，为了保护女儿，靖子也失去了理智，等到回过神来，前夫慎二已经被她用被炉电线勒死。此时 惊魂未定的母女还未从刚刚的灾难中缓过神来，敲门声突然响起。仓促收拾现场后，靖子开了门. 一开门，只见石神那张大圆脸。细缝般的小眼睛对着靖子，他面无表情，这点令人毛骨悚然。“呃……请问……有什么事吗？”靖子对他挤出微笑，她知道自己的脸颊僵硬。“因为我听到很大的声音。”石神依旧用难以判读情绪的表情说道，“出了什么事吗？”“不，什么事也没有。”她用力摇头，“对不起，给您添麻烦了。”“没事就好。”靖子发现石神的小眼睛正朝室内看去，全身顿时一热。“呃，是蟑螂……”她情急之下脱口而出。“蟑螂？”“对。因为有蟑螂，所以……我跟我女儿想打蟑螂……所以才引起骚动。”“杀死了吗？”“啊？……”石神的问题，令靖子的脸颊突然绷紧。“蟑螂消灭了吗？”“啊……对。那当然是解决了。已经没事了，对。”靖子频频点头。“这样吗？如果有什么我能帮忙的尽管说，别客气。”“谢谢。吵到您，真的很不好意思。”靖子鞠个躬，关上门，顺便锁上。听到石神回到住处关门的声音，她呼的吐出一口大气，忍不住当场蹲了下来。 没想到石神通过室内的物品摆放，聊天对话以及气味，已经判断出发生了什么。在靖子母女考虑要不要自首的时候，石神打电话来了,他直接开门见山的说 “女人是无法处理尸体的”，他说他可以帮忙，一方面被石神的逻辑能力和冷静震惊一方面她也只好让石神帮忙。靖子好奇为什么他会知道，问他原因: “刚才我来的时候，府上仍留有烟味，所以我本来以为有客人在，却没有看到客人的鞋子。但暖桌底下却好像有人，暖桌的电线也没插上。如果要躲应该躲进屋里。换句话说，这表示暖桌下的人不是躲起来而是被藏起来。再加上之前打斗的声音，你又罕见的蓬头散发，当然想像得到发生了什么事。还有一点，这栋公寓没有蟑螂，我在这已定居多年可以打包票。” 剧透就到这里了。石神和母女说他会搞定尸体，为靖子母子布置了一个匪夷所思的局，一个完美的不在场证明，把他们保护在安全港中，为了他们的安全，石神不顾一切，不惜把自己塑造成一个杀人犯，跟踪狂，只为让靖子安稳度过余生。如果不是石神的天才校友汤川学洞察了这一切，恐怕剧本真的会朝着石神想的那样走。替靖子顶罪，给世人留下一个变态杀人跟踪狂的骂名。 但靖子最终还是从汤川中获知了惊人的真相。她实在无法理解石神居然会为了自己这么一个毫无长处, 长相平凡的女人毁了一生。她之后在之前交换信封的盒子里翻出了这样一句话。 “工藤邦明先生似乎是个诚实可靠的人。和他结婚，你和美里获得幸福的几率应该比较高。请把我完全忘记，千万不要有罪恶感。因为如果你过得不幸福，我的行为将会完全成为徒劳。”她看了又看，再次落泪。她以前从没遇到过这么深的爱情，不，她连世上有这种深情都不知道。石神面无表情的背后，其实藏着常人难以理解底蕴的爱情。 完 感悟这本书全文几乎没有一句废话，一些不起眼的细节也有可能是伏笔。相比其早年的作品，文笔越加狠辣、细腻。让人读起来过瘾。此外，谜底的设计也惊为天人，整本书逻辑相辅而成，没有太多的剧情bug。 其实几年前就读过这本书，一直都想写篇读后感。为了写这篇读后感，我几乎将整本书重看了一遍。而且正是这本书让我对作者有了全新的认知，之前我只读过他的《解忧杂货店》，没想到他的推理小说 更精彩，之后读了他的相关《白夜行》《恶意》《放学后》等推理小说，觉得特别好，除了巧妙的布局之外还经常描写人性，让人意味深长。 另外东野圭吾曾想几度冲击直木奖，但是都只得到了提名，但是这次《嫌疑人x的献身》终于让他如愿以偿，并且还冲击了当年年度推理小说本格奖和推理小说排行榜第一，这让东野圭吾的知名度得到了很高的提升，我觉得正是这个原因，才有了东野圭吾作品大量翻拍成电影、电视剧的现象。","categories":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}],"tags":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"},{"name":"读后感","slug":"读后感","permalink":"https://haoge744.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"v-slot的使用","slug":"v-slot的使用","date":"2019-08-12T15:00:37.000Z","updated":"2019-08-26T15:05:13.003Z","comments":true,"path":"2019/08/12/v-slot的使用/","link":"","permalink":"https://haoge744.github.io/2019/08/12/v-slot%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"v-slot介绍vue2.6.x开始，vue为具名和范围插槽引入了一个全新的语法,即v-slot。目的就是想统一slot和scope-slot语法，使代码更加规范和清晰。 还在2.5.x的小伙伴注意v-slot只支持在vue2.6以上使用，想用的同学请先升级版本哦。 我们看看v-slot和之前的语法区别吧。","text":"v-slot介绍vue2.6.x开始，vue为具名和范围插槽引入了一个全新的语法,即v-slot。目的就是想统一slot和scope-slot语法，使代码更加规范和清晰。 还在2.5.x的小伙伴注意v-slot只支持在vue2.6以上使用，想用的同学请先升级版本哦。 我们看看v-slot和之前的语法区别吧。 局名插槽12345678910111213&lt;!-- base-layout.vue -- &gt;&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 使用 1234567891011&lt;!-- 过时语法 --&gt;&lt;base-layout&gt; &lt;template slot=\"header\"&gt; &lt;h1&gt;ssss&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;12125125&lt;p&gt; &lt;p&gt;198248924&lt;/p&gt; &lt;template slot=\"footer\"&gt; &lt;p&gt;Some Description&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 使用v-slot指令改写: 12345678910111213&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;title&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; or &lt;template v-slot:default&gt; &lt;&#x2F;template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;&#x2F;base-layout&gt; 作用域插槽:12345&lt;!-- 首先定义绑定对象 --&gt;&lt;span&gt; &lt;slot v-bind:user&#x3D;&quot;user&quot;&gt; &lt;&#x2F;slot&gt;&lt;&#x2F;span&gt; 123456&lt;!-- 过时语法 --&gt;&lt;slot-example&gt; &lt;template slot-scope&#x3D;&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.name &#125;&#125; &lt;&#x2F;template&gt;&lt;&#x2F;slot-example&gt; 12345678910111213141516&lt;!-- v-slot的写法 --&gt;&lt;slot-example&gt; &lt;template v-slot&#x3D;&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.name &#125;&#125; &lt;&#x2F;template&gt;&lt;&#x2F;slot-example&gt;&lt;!-- 可解构赋值改写成以下内容 --&gt;&lt;slot-example&gt; &lt;template v-slot&#x3D;&quot;&#123;user&#125;&quot;&gt; &#123;&#123; user.name &#125;&#125; &lt;&#x2F;template&gt;&lt;&#x2F;slot-example&gt;&lt;!-- 可以给结构变量赋默认值,防止未定义 --&gt;v-slot&#x3D;&quot;&#123;user &#x3D; &#123;name: &#39;ghost&#39;&#125; &#125;&quot; 简写形式事件绑定和数据绑定使用的是@和:，v-slot推出后也有一个简写符号，即使用# 代替v-slot例如 12345678910111213&lt;base-layout&gt; &lt;template #header&gt; &lt;h1&gt;title&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; or &lt;template #default&gt; &lt;&#x2F;template&gt; &lt;template #footer&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;&#x2F;template&gt;&lt;&#x2F;base-layout&gt; 然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的： 1234&lt;!-- 这样会触发一个警告 --&gt;&lt;current-user #&#x3D;&quot;&#123; user &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125;&lt;&#x2F;current-user&gt; 如果你希望使用缩写的话，你必须始终以明确插槽名取而代之： 123&lt;current-user #default=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 实际使用接下来写一个导航组件，每个导航可能会有图标或者badge，这个实际使用要看后台数据。首先先写两个组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- NavList.vue 导航的父组件 --&gt;&lt;template&gt; &lt;nav class&#x3D;&quot;nav_wrapper&quot;&gt; &lt;!-- 循环迭代导航列表，默认只显示导航的名称 --&gt; &lt;slot v-for&#x3D;&quot;item in navList&quot; v-bind:item&#x3D;&quot;item&quot;&gt; &lt;NavItem&gt; &#123;&#123; item.name &#125;&#125; &lt;&#x2F;NavItem&gt; &lt;&#x2F;slot&gt; &lt;&#x2F;nav&gt;&lt;&#x2F;template&gt;&lt;script&gt;import NavItem from &#39;.&#x2F;NavItem&#39;export default &#123; components: &#123; NavItem &#125;, props: &#123; navList: &#123; required: true, type: Array &#125; &#125;, name: &#39;NavList&#39;&#125;&lt;&#x2F;script&gt;&lt;style scoped lang&#x3D;&quot;stylus&quot;&gt;.nav_wrapper background-color #545c64 color white display flex flex-flow row nowrap padding 0px 40px height 40px align-items stretch &amp; &gt;&gt;&gt; .nav_item &#x2F;&#x2F; 让子组件的css生效 text-decoration none padding 0 40px cursor: pointer display flex align-items center &amp;:hover background-color black &amp; &gt;&gt;&gt; .nav_item_icon img &lt;!-- 给子组件的导航图标设置的样式 --&gt; width 30px height 30px display flex align-items center margin-right 10px&lt;&#x2F;style&gt; 1234567891011121314151617181920&lt;!-- 导航的子组件 NavItem.vue --&gt;&lt;template&gt; &lt;a class&#x3D;&quot;nav_item&quot;&gt; &lt;!-- 导航的图标,默认没有, 在slot标签上设置class不生效,所以用span包裹一下 --&gt; &lt;span class&#x3D;&quot;nav_item_icon&quot;&gt; &lt;slot name&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;span&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;slot name&#x3D;&quot;badge&quot; class&#x3D;&quot;nav_item_badge&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;a&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;NavItem&#39;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt; 两个相互搭配的组件写好了，接下来开始使用了: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;NavList :navList&#x3D;&quot;navList&quot;&gt; &lt;template v-slot&#x3D;&quot;&#123;item&#125;&quot;&gt; &lt;NavItem&gt; &lt;!-- 菜单项中有图标则显示、没有则隐藏 --&gt; &lt;template v-slot:icon v-if&#x3D;&quot;item.icon&quot;&gt; &lt;img :src&#x3D;&quot;item.icon&quot; alt&#x3D;&quot;&quot; &gt; &lt;&#x2F;template&gt; &#123;&#123; getName(item) &#125;&#125; &lt;!-- 菜单项中有badge则显示、没有则隐藏 --&gt; &lt;template v-slot:badge v-if&#x3D;&quot;item.badge&quot;&gt; &lt;!-- badge的样式是在父组件中定义的， --&gt; &lt;span class&#x3D;&quot;nav_item_badge&quot;&gt; &#123;&#123; item.badge &#125;&#125; &lt;&#x2F;span&gt; &lt;&#x2F;template&gt; &lt;&#x2F;NavItem&gt; &lt;&#x2F;template&gt; &lt;&#x2F;NavList&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import NavList from &#39;@&#x2F;components&#x2F;NavList&#39;import NavItem from &#39;@&#x2F;components&#x2F;NavItem&#39;export default &#123; name: &#39;index&#39;, components: &#123; NavList, NavItem &#125;, data () &#123; return &#123; navList: [&#123; &#x2F;&#x2F; 导航菜单的列表 name: &#39;home&#39;, icon: require(&#39;..&#x2F;..&#x2F;assets&#x2F;icon.png&#39;) &#125;,&#123; name: &#39;news&#39;, badge: 2 &#125;,&#123; name: &#39;tags&#39; &#125;,&#123; name: &#39;about&#39;, icon: require(&#39;..&#x2F;..&#x2F;assets&#x2F;logo.png&#39;), badge: 3 &#125;] &#125; &#125;, methods: &#123; getName (item) &#123; return item.name.toUpperCase() &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped lang&#x3D;&quot;stylus&quot;&gt; .nav_item_badge width 10px height 10px padding 5px display flex align-items center justify-content center margin-top -12px margin-left 4px font-size 10px border-radius 50% background-color red color: white&lt;&#x2F;style&gt; 效果如下: 可能样式不是很完美，但是今天主题还是v-slot, 为什么不在NavItem里设置badge的样式呢？这是因为badge的宽高设定之后，父组件无法控制其隐藏。我目前暂时没有想到好的办法。另外本身badge这个东西也应该封装成一个组件的，如果在子组件里写死了那么久丧失了灵活性。另外这个导航本身实际项目中应该不会这样写，这只是一个v-slot的使用样例，仅供参考。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"echarts地图钻取位置异常的解决办法","slug":"echarts地图钻取位置异常的解决办法","date":"2019-08-08T15:41:16.000Z","updated":"2019-08-15T10:24:29.904Z","comments":true,"path":"2019/08/08/echarts地图钻取位置异常的解决办法/","link":"","permalink":"https://haoge744.github.io/2019/08/08/echarts%E5%9C%B0%E5%9B%BE%E9%92%BB%E5%8F%96%E4%BD%8D%E7%BD%AE%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"因为有需求要做一个中国地图下钻到市的功能，但是在钻取中放大的时候碰到了地图位置显示异常的问题，切换地图的时候偶尔会出现地图找不到的问题，如下图:","text":"因为有需求要做一个中国地图下钻到市的功能，但是在钻取中放大的时候碰到了地图位置显示异常的问题，切换地图的时候偶尔会出现地图找不到的问题，如下图: 地图下钻逻辑，初始化的时候缓存全国的地图，省的多次加载，我这里实现echarts下钻的核心方法是 registerMap(mapName,geoJson,specialAreas)作用是向echarts内注册一个地图，这个地图的第一个参数是地图名字，可以自定义，第二个是geoJson，可以自己画geojson的数据也可以在echarts的github地址里找到关于中国省市区的地图数据(echarts官网已经下载不了了),访问这个链接可以下载到。第三个是可选参数，具体参考文档。 在官网上看到了地图的series中可以设置center参数，然后在地图json中看到了每个城市也有经纬度的数据所以可以每次钻取的时候给series设置当前城市的中心点来避免问题发生。 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109export default &#123; // ... somecode methods: &#123; // ...somecode init () &#123; // 地图初始化，把画布大小调整为全屏以及注册点击事件 const dom = document.getElementById('map-wrapper') dom.style.width = document.body.clientWidth + 'px' dom.style.height = document.body.clientHeight + 'px' this.chartInstance = echarts.init(dom) this.chartInstance.on('click', this.chartClickHandler) &#125;, chartClickHandler (params) &#123; // 地图点击事件 if (params.name in provinces) &#123; // 点省级或者直辖市 if (special.indexOf(params.name) &gt;= 0) &#123; this.$toast('直辖市不支持放大') return &#125; this.isNational = false const key = provinces[params.name] const name = params.name this.$toast.loading(&#123; mask: true, duration: 0 &#125;) // 请求static路径下城市的geoJSON.json数据 getMapJson(`./static/map/province/$&#123;key&#125;.json`).then(async response =&gt; &#123; let cityData = [] let cityMap = &#123;&#125; console.log(response.data.features[0].properties.name) const lat = response.data.features[0].properties.cp // 获取json里第一个城市的经纬度 response.data.features.forEach(item =&gt; &#123; // 没有数据的展示零 cityMap[item.properties.name] = 0 &#125;) try &#123; if (this.provIdKeyMap.get(name)) &#123; // 根据省的id拿到后台数据展示 let cData = await getCityData(this.provIdKeyMap.get(name).split('_')[0]) // 根据省id 获取市的数据 if (cData.status === 200) &#123; cData.data.forEach(item =&gt; &#123; cityMap[item.cityname] = item.ftreermb &#125;) &#125; &#125; this.$toast.clear() &#125; catch (error) &#123; this.$toast('加载地图数据失败') &#125; for (let a in cityMap) &#123; // 遍历组装所有市的数据 let showLabel = cityMap[a] ? true : false cityData.push(&#123; name: a, value: cityMap[a], label: &#123; show: showLabel &#125; &#125;) &#125; echarts.registerMap(name, response.data) // 注册地图 this.renderMap(name, cityData, lat) // 渲染 &#125;) &#125; else &#123; this.isNational = true this.renderMap('china', this.nationalData) &#125; &#125;, // 渲染地图 renderMap (map, data, lat = [103.754, 34.452]) &#123; // 地图名字, 数据, 经纬度 this.$set(this.option.title, 'subtext', map) const series = [&#123; name: map, type: 'map', mapType: map, roam: true, zoom: 2, nameMap: &#123;'china': '中国'&#125;, left: 20, top: '30%', center: lat, // 设置中心点 默认中国的中心点 showLegendSymbol: false, label: &#123; normal: &#123; show: true, textStyle: &#123;color: '#000', fontSize: 14&#125; &#125;, emphasis: &#123; show: true, textStyle: &#123;color: '#999', fontSize: 14&#125; &#125; &#125;, itemStyle: &#123; normal: &#123; areaColor: '#E6E6FA', borderColor: 'dodgerblue', label: &#123; show: true, formatter: '&#123;b&#125;\\n&#123;c&#125; ' &#125;&#125;, emphasis: &#123; areaColor: 'darkorange' &#125; &#125;, data: data &#125;] //设置option this.$set(this.option, 'series', series) this.chartInstance.setOption(this.option) &#125; &#125;&#125; 完成后效果如下: 不显示数据为零的地名series里的data也可以设置label的样式和隐藏显示,设置标签位置等等等。详细配置请访问链接 1234567&#123; name: a, value: cityMap[a], label: &#123; show: showLabel // 判断数据是否为空或者零 &#125;&#125;","categories":[{"name":"echarts","slug":"echarts","permalink":"https://haoge744.github.io/categories/echarts/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://haoge744.github.io/tags/echarts/"},{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"vue项目使用lottie动画","slug":"vue项目使用lottie动画","date":"2019-08-08T14:45:51.000Z","updated":"2019-08-09T09:31:24.485Z","comments":true,"path":"2019/08/08/vue项目使用lottie动画/","link":"","permalink":"https://haoge744.github.io/2019/08/08/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8lottie%E5%8A%A8%E7%94%BB/","excerpt":"Lottie是一个开源动画框架，支持Android，IOS，ReactNative以及web开发，这篇文章主要讲Lottie在vue项目中如何使用。GitHub地址,我在官方社区看了一下，交互性非常好，动画支持倍速播放，倒放，暂停等功能，能熟练使用的话，交互性能提升很多。 安装在安装目录执行以下命令: 1npm install --save vue-lottie","text":"Lottie是一个开源动画框架，支持Android，IOS，ReactNative以及web开发，这篇文章主要讲Lottie在vue项目中如何使用。GitHub地址,我在官方社区看了一下，交互性非常好，动画支持倍速播放，倒放，暂停等功能，能熟练使用的话，交互性能提升很多。 安装在安装目录执行以下命令: 1npm install --save vue-lottie 使用准备好动画json文件。可以让UI处理好: UI使用AE–安装bodymovin插件-将AE中的动画工程文件通过bodymovin转换为.json文件–发给开发-开发集成Lottie框架-直接在项目中使用。 或者是在官方库里找:链接。 具体代码: 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;Lottie :options=\"defaultOptions\" v-on:animCreated=\"handleAnimation\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Lottie from 'vue-lottie'// 引用动画json文件，在官网下载的。import * as animeData from '../assets/anime.json'export default &#123; name: 'animate', components: &#123; Lottie &#125;, data () &#123; return &#123; // ... some code defaultOptions:&#123; animationData: animeData &#125; &#125; &#125;, methods: &#123; handleAnimation: function (anim) &#123; this.anim = anim &#125; &#125;&#125;&lt;/script&gt;&lt;style scope&gt; ...some code&lt;/style&gt; 效果: 常用配置:以上配置只用到了animationData,下面列出一些常用的，更多配置项请在该链接中查看 animationData: 动画json path: 可直接指定动画json // 路径 loop: true / false / number //循环 autoplay: true / false // 自动播放 name: // 给动画取名字,方便方法调用 renderer: ‘svg’ / ‘canvas’ / ‘html’ //渲染方式 container: the dom element on which to render the animation // 可直接指定dom节点渲染","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"},{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"uni随手笔记一","slug":"uni随手笔记一","date":"2019-08-04T07:34:44.000Z","updated":"2019-08-23T07:45:11.611Z","comments":true,"path":"2019/08/04/uni随手笔记一/","link":"","permalink":"https://haoge744.github.io/2019/08/04/uni%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0%E4%B8%80/","excerpt":"自己看官方文档做的一些笔记，记了一些和vue差异的地方和印象较深的地方。看看就好哈哈。","text":"自己看官方文档做的一些笔记，记了一些和vue差异的地方和印象较深的地方。看看就好哈哈。 编写uni注意事项用uni-app想兼容多端，不能使用带dom、window操作的库，并且最好是纯flex布局，如果只开发h5端，推荐还是用vue-cli构建项目。 新老编译模式:12345678在manifast.json中配置&#123; // ... app-plus: &#123; // app h5+相关 usingComponents: true // 如果是true则是自定义组件模式/否则不是 &#125;, wp-wexin: &#123; // 微信小程序相关 &#125;&#125; 最新版本的XHbuilder默认是自定义组件模式不支持v-slot新语法 // vue2.6新增 npm支持情况初始化项目 初始化 package.json文件 npm init -y 安装依赖 npm install packageName –save 使用 package from 'packageName'123const package &#x3D; require(&#39;packageName&#39;)* 注意非H5端不支持使用含有dom、window等操作的vue组件和js模块,安装的模块及其依赖的模块使用的api必须是uni-app已有的api, 说明npm 的插件极其难找* 支持安装 mpvue组件，但npm方式不支持小程序自定义组件(如wxml格式的vant-weapp) 生命周期:全局生命周期: 属性 类型 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当uni-app 启动，或从后台进入前台显示 onHide 当uni-app 从前台进入后台 onUniNViewMessage 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 组建中新增 onBackPress(event) -- 返回 event ={form: backbutton | navigateBack} 自定义返回键可以看这篇文章:http://ask.dcloud.net.cn/article/35120组件生命周期除了vue的基本生命周期额外增加了一些生命周期 建议使用 uni-app 的 onReady代替 vue 的 mounted。 建议使用 uni-app 的 onLoad 代替 vue 的 created。 static 目录下的 js 文件不会被编译，如果里面有 es6 的代码，不经过转换直接运行，在手机设备上会报错。 条件编译及判断运行环境判断开发环境和生产环境: (方便切换生产环境和正式环境 后台url) 123456&#x2F;&#x2F; uEnvDevif(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;)&#123; console.log(&#39;开发环境&#39;)&#125;else&#123; console.log(&#39;生产环境&#39;)&#125; 平台条件编译 123&#x2F;&#x2F; #ifdef H5 alert(&quot;只有h5平台才有alert方法&quot;)&#x2F;&#x2F; #endif 注意在css或scss等其他样式中，要使用/* #ifdef MP-WEIXIN */代替ifdef的可取值如下 APP-PLUS、APP-PLUS-NVUE（Weex）、H5、MP-WEIXIN、MP-ALIPAY、MP-BAIDU、MP-TOUTIAO、MP-QQ(qq小程序目前仅cli版支持)、MP(非h5和app+/weex) 样式导入:​ 使用@import 语句导入​ @import “../../common/uni.css”;内联样式以及动态样式​ ​ 注意:​ page相当于body节点，例如:​ page { background-color: #ccc } css 内置变量 快捷键heivar(--status-bar-height) //系统状态栏高度 var(--window-top) //内容区域距离顶部的距离 -- NavagationBar的高度 var(--window-bottom) // 内容区域距离底部的距离 -- tabBar的高度注意导航栏和底部选项卡最好用px作为单位 ##注意:背景图片仅支持以 ~@ 开头的绝对路径(不支持相对路径!) 字体图标支持网络路径图标，网络路径必须加协议头httpsvue 使用注意1.1建议使用 uni-app 的 onReady代替 vue 的 mounted。 1.2建议使用 uni-app 的 onLoad 代替 vue 的 created。事件处理: // 事件映射表，左侧为 WEB 事件，右侧为 uni-app 对应事件 12345678910111213141516171819202122&#123; click: 'tap', touchstart: 'touchstart', touchmove: 'touchmove', touchcancel: 'touchcancel', touchend: 'touchend', tap: 'tap', longtap: 'longtap', input: 'input', change: 'change', submit: 'submit', blur: 'blur', focus: 'focus', reset: 'reset', confirm: 'confirm', columnchange: 'columnchange', linechange: 'linechange', error: 'error', scrolltoupper: 'scrolltoupper', scrolltolower: 'scrolltolower', scroll: 'scroll'&#125; 基本元素:uni-app推荐使用view、text等元素替代原来的html元素 用navigator替代 a ,虽然写div或者a之类的h5标签也不影响使用但是推荐按照官方的来 元素 共同属性类型 属性 类型 说明 id String 组件的唯一标示 保持整个页面唯一 class String 组件的样式类 在对应的 css 中定义的样式类 style String 组件的内联样式 可以动态设置的内联样式 hidden Boolean 组件是否隐藏 所有组件默认是显示的 data-* Any 自定义属性 组件上触发的事件时，会发送给事件处理函数 @* EventHandler 组件的事件 详见各组件详细文档，事件绑定参考 事件处理器","categories":[{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/categories/uni-app/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/tags/uni-app/"}]},{"title":"vue3.0 新特性","slug":"vue3-0-新特性","date":"2019-08-01T02:43:33.000Z","updated":"2019-08-26T15:01:10.276Z","comments":true,"path":"2019/08/01/vue3-0-新特性/","link":"","permalink":"https://haoge744.github.io/2019/08/01/vue3-0-%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"目前vue最新的版本是19年2月份发布的2.6.x,更新了一些插槽、动态参数等，据说3.0也会在下半年发布，下面根据尤大的视频分享总结3.0的新特性。","text":"目前vue最新的版本是19年2月份发布的2.6.x,更新了一些插槽、动态参数等，据说3.0也会在下半年发布，下面根据尤大的视频分享总结3.0的新特性。 Vue3.0即将带来哪些新东西: 更快 更小 更易于维护 更好的多端渲染支持 新功能 判断元素是html原生还是组件的时候把这个动作放到了编译时，提高了运行时的性能。跳过不需要的条件判断，生成更易于被JS引擎优化的代码。 优化Slots生成Vue2.0存在父组件更新时，子组件也关联着也更新了。在vue3.0中优化了这一问题。避免不必要的组件渲染。检测组件更新变得更精确。 静态属性提取跳过整块静态内容的更新及时静态内容在列表中被重复也可以生效。跳过单个元素的patch，但依然处理子元素。 主要意思是避免元素不必要的更新。 内联时间函数提取解决组件重新渲染后 再重新创建函数的问题，3.0中第一次创建后会缓存，那么每次重新渲染之后可以避免这个问题。 数据监听改为Proxy之前的数据监听系统是由Object.definedProperty的，3.0中会修改为Proxy提高了性能。再大规模数据监听的情况下，性能提升明显。 据说提升后组件实例初始化效率加倍，内存占用减半 更小代码结构优化和Tree-shaking(把没有用到的代码，在最后编译时给优化掉)配合，减小包的体积。3.0中内置的模块可以按需引入。只引入最基本模块的情况下,依赖包只有10kb左右。 更易于维护对于vue开发团队而言，更易于维护。用TypeScript完全重写vue的源码。并且不影响用户使用。 源码的各个模块更加解耦。更加利于对阅读源码的理解。 编译器重构使用插件化设计带位置信息的parser(source maps!)为更好的IDE供给链铺路 runtime时出错提示优化 更好的多端渲染支持vue衍生出Wexx、NativeVue、wePy 等小程序终端。vue3会进行更好的优化。推出Custom Renderer API，为多端提供更好的渲染。 12345import &#123; createRenderer &#125; from '@vue/runtime-core'const &#123;render&#125; = createRenderer(&#123; nodeOps, patchData&#125;) 新功能响应式数据监听API12345678import &#123;observable, effect&#125; from 'vue'const state = observable(&#123; count: 0&#125;)effect(() =&gt; &#123; console.log(`count is: $&#123;state.count&#125; `) //每次更改状态时触发的函数&#125;)// count is: 0state.count ++ //count is : 1 可以很简单的在多组件中实现状态共享 轻松排查组件更新的触发原因123456789const Comp = &#123; render(props) &#123; return h('div', props.count) &#125;, renderTriggered(event)&#123; debugger // 可在此检查是在哪触发的组件更新 //event可查看更多信息，更改了那个key，哪行代码做的更改..等 &#125;&#125; 更好的TypeScript支持提升了性能。支持tsx 更好的警告信息 组件堆栈包含函数式组件 可以直接在警告信息中查看组件的props 在更多的警告中提供组件堆栈信息 新加Experimental HooksAPI类似React Hooks,大概率取代mixins。逻辑重用机制。 github上已有Vue Hooks这个项目 Experimental Time Slicing Support把js中复杂的计算切成一帧一帧(每16毫秒)，解决用户界面卡顿的问题。 开启Time Slicing，在js计算的时候每次只占用16毫秒左右的工作量，之后把主动权交还给浏览器，这样浏览器有时间去相应用户的操作 关于IE会有一个专门的版本在IE11中自动降级为旧的getter/setter机制。并对IE中不支持的用法给出警告。但在ie中可能享受不到vue的一些新功能。 整理的比较乱，具体功能以及使用需要参考相关官方文档。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"uni-app 入坑系列一","slug":"uni-app-入坑系列一","date":"2019-07-31T15:24:42.000Z","updated":"2019-08-05T09:24:42.000Z","comments":true,"path":"2019/07/31/uni-app-入坑系列一/","link":"","permalink":"https://haoge744.github.io/2019/07/31/uni-app-%E5%85%A5%E5%9D%91%E7%B3%BB%E5%88%97%E4%B8%80/","excerpt":"uni的简介和优点 uni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可编译到iOS、Android、H5、以及各种小程序等多个平台。 uni-app的特点和优势在于，跨平台数量多、性能体验好、生态环境好、开发效率高等特点，确实值得现在开发者学习，学习成本也不高。","text":"uni的简介和优点 uni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可编译到iOS、Android、H5、以及各种小程序等多个平台。 uni-app的特点和优势在于，跨平台数量多、性能体验好、生态环境好、开发效率高等特点，确实值得现在开发者学习，学习成本也不高。 项目目录结构一个uni-app工程，默认包含如下目录及文件： 123456789101112131415┌─components uni-app组件目录│ └─comp-a.vue 可复用的a组件├─hybrid 存放本地网页的目录，详见├─platforms 存放各平台专用页面的目录，详见├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此├─wxcomponents 存放小程序组件的目录，详见├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见└─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见 uni-app 和普通Vue项目开发上有什么区别路由vue项目配置路由页面在src/router/index.js文件下配置uni-app在项目根目录下的pages.json文件配置，并且结构和vue不一样。pages.json具体配置项可见详情。 路由跳转vue使用vue-router的router-view和vue-router的api进行页面跳转uni-app使用navigator组件跳转、或者调用API跳转。 组件开发uni-app和vue一样也使用.vue文件来编写组件 但是uni-app的tmeplate层内的标签是使用类似微信小程序的标签元素来编写的，例如用&lt;view&gt;和&lt;text&gt;来替代html中的&lt;div&gt;和&lt;span&gt;标签。 第三方组件引入可以访问进行查看区别。 配置文件uni-app使用manifast.json配置各平台相关信息，vue使用package.json webpack.*.conf.js 等配置文件配置 状态管理uni-app也可以使用vuex来管理生命周期，但是nvue模式下不支持。 生命周期uni-app给app环境下添加了几个全局的生命周期 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onUniNViewMessage 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 webpack 配置uni-app也支持使用webpack安装插件，但是只推荐h5平台使用，其他只支持flex布局和不操作dom的库，制作APP个人不推荐使用webpack安装第三方组件。","categories":[{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/categories/uni-app/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/tags/uni-app/"}]},{"title":"hexo项目搭建","slug":"hexo项目搭建","date":"2019-07-21T06:59:40.000Z","updated":"2019-08-26T01:30:43.665Z","comments":true,"path":"2019/07/21/hexo项目搭建/","link":"","permalink":"https://haoge744.github.io/2019/07/21/hexo%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","excerpt":"安装 安装Node.js和git 此处不再阐述 执行一下命令全局安装hexo 123$ npm install -g hexo-cli或者$ cnpm install -g hexo-cli","text":"安装 安装Node.js和git 此处不再阐述 执行一下命令全局安装hexo 123$ npm install -g hexo-cli或者$ cnpm install -g hexo-cli 建站安装完成后执行以下命令 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 目录结构安装完成之后会生成以下目录12345678.├── _config.yml &#x2F;&#x2F; 网站的配置信息├── package.json &#x2F;&#x2F; package.json 依赖信息，可查看安装了哪些依赖包├── scaffolds &#x2F;&#x2F; ├── source &#x2F;&#x2F; 资源文件夹| ├── _drafts| └── _posts└── themes &#x2F;&#x2F; 主题文件夹 写作在hexo目录下 执行以下命令: 123456789101112hexo new &quot;post title&quot; &#x2F;&#x2F;写完之后执行 hexo g 生成页面hexo s &#x2F;&#x2F;生成草稿、 草稿不会生成页面hexo new draft &quot;draft title&quot;&#x2F;&#x2F;生成纯页面hexo new page &quot;page title&quot;&#x2F;&#x2F; 发布草稿hexp pulic [layout] &lt;filename&gt; 命令部署: 启动本地服务: 1hexo s -g 1hexo g -d","categories":[{"name":"hexo","slug":"hexo","permalink":"https://haoge744.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://haoge744.github.io/tags/hexo/"}]}]}