{"meta":{"title":"cch‘s blog","subtitle":"JUST DO IT","description":null,"author":"cch","url":"https://haoge744.github.io","root":"/haoge744.github.io/"},"pages":[{"title":"关于","date":"2019-07-31T02:13:18.000Z","updated":"2020-03-14T03:40:13.363Z","comments":true,"path":"about/index.html","permalink":"https://haoge744.github.io/about/index.html","excerpt":"","text":"关于hi,你好欢迎来到我的博客。 搭建本博客的目的主要为了是记录和总结日常工作时出现的问题，以及学习新知识做笔记、总结以及转载。有时候也会写一些书评或者人文生活(仅包含个人观点)。文章质量可能参差不齐，有些文章可能为临时记录，有些为用心打磨，主要看自己费的心思吧。 希望自己能看到自己的不足，尽快提升自己。目标是想要成为大前端。 本人的邮箱: cch_it@sina.com 或者 cch_it@163.com 技术栈 h5+css3、jQuery、bootstrap vue node.js java 写过一年java 爱好: 看书，喜欢自己买实体书看，喜欢书的味道，还有把自己看完的书摆满书架的那种自豪感。喜欢的书的类型也没有太固定的，人物传记、嫌疑小说、短篇小说都挺喜欢。买书也没有特别挑，基本看到新出的书和感兴趣的或者书评不错的话都会想买。目前比较喜欢的作家是东野圭吾，我看他的第一部作品是《解忧杂货店》，然后陆陆续续看了他的成名作《嫌疑人x的献身》《白夜行》《放学后》《恶意》等等。他的最新作我也有在留意，有兴趣的话会考虑再入。 看电影，很平常也很普通的爱好，喜欢科幻片和喜剧片。 音乐。是周杰伦的歌迷。 玩游戏，大部分男同志都有的爱好。 喜欢唱、跳、rap((^▽^))。 技术领域:目前从事前端&amp;移动的开发工作，致力于web和移动端解决方案，对前端领域有浓厚的兴趣，喜欢尝试新技术。 本博客内文章可能总结于网络内容，如有侵权，请邮件联系本人删除。"},{"title":"所有分类","date":"2019-08-01T09:36:25.000Z","updated":"2020-03-15T12:42:02.691Z","comments":false,"path":"categories/index.html","permalink":"https://haoge744.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-08-01T15:21:15.000Z","updated":"2020-03-15T12:42:28.121Z","comments":false,"path":"tags/index.html","permalink":"https://haoge744.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git hooks","slug":"git-hooks","date":"2020-11-15T14:29:13.000Z","updated":"2020-11-15T14:29:51.127Z","comments":true,"path":"2020/11/15/git-hooks/","link":"","permalink":"https://haoge744.github.io/2020/11/15/git-hooks/","excerpt":"git hooks使用在团队协作开发时，为了保证代码质量和代码风格一致，需要在代码commit或push前对代码做一些测试和校验，那么就可以使用git hooks了。常用的hook有pre-commit、pre-push这些。分别在提交和推送前调用。","text":"git hooks使用在团队协作开发时，为了保证代码质量和代码风格一致，需要在代码commit或push前对代码做一些测试和校验，那么就可以使用git hooks了。常用的hook有pre-commit、pre-push这些。分别在提交和推送前调用。 在提交前做lint校验，推送前做测试校验: 123456&#123; \"gitHooks\": &#123; \"pre-commit\": \"lint-staged\", \"pre-push\": \"test\" &#125;&#125; 如果es-lint校验没有通过的话那么代码是不会提交成功的，如果说你非得提交，那么是也有办法的。 1git commit --no-verify -m '提交校验'","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"}]},{"title":"vite的使用","slug":"vite的使用","date":"2020-10-12T14:48:23.000Z","updated":"2020-10-12T14:48:23.000Z","comments":true,"path":"2020/10/12/vite的使用/","link":"","permalink":"https://haoge744.github.io/2020/10/12/vite%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"目前vue3.0已经在9月18号发布正式版本了，目前官方的脚手架有两种，一种是使用@vue/cli,需要4.x以上，一种是使用Vite。","text":"目前vue3.0已经在9月18号发布正式版本了，目前官方的脚手架有两种，一种是使用@vue/cli,需要4.x以上，一种是使用Vite。 Vite介绍 Vite，一个基于浏览器原生ES Module的开发服务器，利用浏览器去解析模块，在服务端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅有Vue文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。 他主要有以下特点： 更快的冷启动速度 及时的热替换功能 真正的按需编译 在我开发的vue项目中只要页面一多的话，那么首次启动需要十几秒，然后修改文件后需要等2、3秒后才能编译完毕，大大降低了开发和调试的效率。 初始化项目初始化使用npm 1234npm init vite-app project-namecd project-namenpm installnpm run dev 使用yarn 1234yarn create vite-app project-namecd project-nameyarnyarn dev Templates参数:创建一个vue-ts的项目 1yarn create vite-app project-name --template vue-ts vue (默认) vue-ts react react-ts preact reason-react 项目目录这是由vue-ts生成项目目录 123456789101112index.htmlpackage.jsonpublicsrc--|App.vue--|assets--|components--|index.css--|main.ts--|vue-app-env.d.tstsconfig.jsonyarn.lock vite生成的项目目录比vue/cli生成的目录还简单，没有任何的配置文件，如果需要进行配置的话，需要新建vite.config.js，这点和vue.config.js类似，配置选项上和vue/cli选项差不多，如果对配置有问题的话，可以去看看vue/cli的官方文档 注意: Vite当前仅支持Vue 3.x。这也意味着您不能使用尚未与Vue 3 兼容的库 设置别名的方法打开vite.config.js 123456const path = require('path')export default &#123; alias: &#123; '/@/': path.resolve(__dirname, 'src') &#125;&#125; 使用: 1import Hello from '/@/components/Hello.vue' 注意不能使用@开头去引用，这是一个bugissues","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue拾遗","slug":"vue拾遗","date":"2020-08-05T08:52:47.000Z","updated":"2020-08-06T09:15:03.906Z","comments":true,"path":"2020/08/05/vue拾遗/","link":"","permalink":"https://haoge744.github.io/2020/08/05/vue%E6%8B%BE%E9%81%97/","excerpt":"记录一下vue的一些不太清楚，和之前没了解过的api。","text":"记录一下vue的一些不太清楚，和之前没了解过的api。 hookEvent在监听生命周期方法时，除了声明生命周期方法也可以使用以下方式 基本用法12345678910111213export default&#123; created () &#123; window.addEventListener('resize', this.resizeHandler) this.$once('hook:beforeDestory', () =&gt; &#123; window.removeEventListener('resize', this.resizeHanlder) &#125;) &#125;, methods: &#123; resizeHandler() &#123; // brbrbr &#125; &#125;&#125; 监听其他组件或第三方组件的生命周期方法比如说我们想监听第三方组件的update事件，但是内部又没有提供change事件, 这时候也可以直接在组件上监听其生命周期事件 1&lt;Component @hook:update&#x3D;&quot;componentUpdateHandler&quot;&gt;&lt;&#x2F;Component&gt; 来看下源码中是怎么调用的 123456789101112131415export function callHook (vm: Component, hook: string) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] const info = `$&#123;hook&#125; hook` if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info) &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit('hook:' + hook) &#125; popTarget()&#125; 在_hasHookEvent为true的情况下，会调用hook:前缀的事件，继续看一下_hasHookEvent的条件是什么。 1234567891011121314151617const hookRE = /^hook:/ Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn) &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm&#125; 以hook:开头的事件监听，会被当成hookEvent,那么在生命周期触发的同时也会触发对应的事件。 所以，如果你想给一个Vue组件添加生命周期函数有3个办法： 在Vue组件选项中添加； 在模板中通过@hooks:created这种形式； vm.$on(&#39;hooks:created&#39;, cb)或者 vm.$once(&#39;hooks:created&#39;, cb)。 使用Vue.observable管理状态 “如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex”。这时候我们就可以使用Vue2.6提供的新API Vue.observable手动打造一个Vuex 创建store 123456789101112131415import Vue from 'vue'export const store = new Vue.observable(&#123; userName: '', roles: []&#125;)export const mutations = &#123; setUserName(userName) &#123; store.userName = userName &#125;, setRoles(roles)&#123; store.roles = roles &#125;&#125; 组件中使用 123456789101112131415161718&lt;template&gt; &lt;div&gt; &#123;&#123; userName &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;store,mutations&#125; from &#39;@&#x2F;store&#39;export default &#123; computed: &#123; userName () &#123; return store.userName &#125; &#125;, created() &#123; mutations.setUserName(&#39;张三&#39;) &#125;&#125;&lt;&#x2F;script&gt; $watch监听在开发过程中有可能会有取消watch监听的要求，那么可以使用$watch方法取消监听 123456789101112131415161718export default &#123; data () &#123; formData: &#123; name: '', password, &#125; &#125;, created() &#123; const unwatch = this.$watch('formData', (val, oldVal) =&gt; &#123; console.log(val) &#125;, &#123; deep: true &#125; ) &#125;&#125; $watch方法返回的是一个unwatch方法，执行后即可取消监听。 函数式组件123456789export default &#123; functional: true, props: &#123; title: '', &#125;, render(h, context) &#123; return &lt;h1&gt;&lt;/h1&gt; &#125;&#125; 函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等 函数式组件与普通组件的区别 函数式组件需要在声明组件是指定functional 函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替 函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等 函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件 因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement 函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止) 12345&lt;!--在template 上面添加 functional属性--&gt;&lt;template functional&gt; &lt;img :src=\"props.avatar ? props.avatar : 'default-avatar.png'\" /&gt;&lt;/template&gt;&lt;!--根据上一节第六条，可以省略声明props--&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"防抖节流","slug":"防抖节流","date":"2020-05-01T14:46:28.000Z","updated":"2020-05-01T14:46:28.000Z","comments":true,"path":"2020/05/01/防抖节流/","link":"","permalink":"https://haoge744.github.io/2020/05/01/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","excerpt":"在实际开发过程中，处理滚动或者输入框搜索的时候，防抖和节流是非常常见的需求，以下列出我在使用的防抖节流的实现。","text":"在实际开发过程中，处理滚动或者输入框搜索的时候，防抖和节流是非常常见的需求，以下列出我在使用的防抖节流的实现。 防抖123456789101112131415161718192021222324252627282930/** * 防抖 * @param &#123;Object&#125; func 方法 * @param &#123;Object&#125; wait 间隔时长 毫秒 * @param &#123;Object&#125; immediate 是否事件触发时立即执行一次 */export function debounce(func, wait, immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 节流1234567891011121314151617181920212223242526272829303132333435/** * 节流 * @param &#123;Object&#125; func 方法 * @param &#123;Object&#125; wait 间隔时长 毫秒 */export function throttle(func, wait) &#123; var timeout, context, args, result; var previous = 0; var later = function() &#123; previous = +new Date(); timeout = null; func.apply(context, args) &#125;; var throttled = function() &#123; var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 使用： 12345678910111213import &#123;debounce&#125; from '@/utils'export default&#123; watch:&#123; tempKeyWord(val) &#123; this.search(&#123;ctx: this, keyword: val&#125;) &#125; &#125;, methods: &#123; search: debounce((&#123;ctx, keyword&#125;) =&gt; &#123; // do search... &#125;,700) &#125;&#125; 原文链接：https://blog.csdn.net/weixin_42333548/article/details/90815258","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"}]},{"title":"尝试svelte","slug":"尝试svelte","date":"2020-04-05T14:46:28.000Z","updated":"2020-04-05T14:46:28.000Z","comments":true,"path":"2020/04/05/尝试svelte/","link":"","permalink":"https://haoge744.github.io/2020/04/05/%E5%B0%9D%E8%AF%95svelte/","excerpt":"最近才听说有svelte这个框架，他最大的卖点就是no virutal dom，并且渲染速度非常的快，我也上官网稍微了解了下，感觉蛮有意思的。 接下来我将通过svelte来实现一个TODOList","text":"最近才听说有svelte这个框架，他最大的卖点就是no virutal dom，并且渲染速度非常的快，我也上官网稍微了解了下，感觉蛮有意思的。 接下来我将通过svelte来实现一个TODOList 初始化1npx degit sveltejs/template my-svelte-project 生成的文件目录: 123456publicrollup.config.jssrcpackage.jsonREADME.mdscripts 可以看出来svelte是使用rollup来进行模块打包的 TODOList实现循环遍历svelte的代码风格类似于vue,对vue开发者来说非常友好;实现todo的遍历: 12345678910111213141516171819&lt;script&gt;export let todoInputText;export let todoList = [];&lt;/script&gt;&lt;main&gt;&lt;div&gt; &lt;ul&gt; &#123;#each todoList as item, i&#125; &lt;li :class=\"&#123;item.completed ? 'done' : ''&#125;\"&gt; &#123;item.name&#125; &lt;/li&gt; &#123;/each&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/main&gt;&lt;style&gt;&lt;/style&gt; 遍历需要使用{ each }代码块包裹需要循环的元素, as后面可以跟变量名和下标,并且可以支持解构 12&#123;#each todoList as &#123;name, complete&#125;, index&#125;&#123;&#x2F;each&#125; class绑定和vue的差不多，这里就不详细讲解了 svelte使用.svelte文件实现单文件组件，文件大致分为三块script js代码块、main模板、style样式。并且样式是会自动css模块化，而不需要像vue那样写scoped标签。 双向绑定和事件触发列表做完之后，需要做的是列表项的添加和删除了，这里就需要增加一个input, 并且处理回车事件了， 每个列表项后面增加一个删除按钮，处理删除事件，在这里碰到了一个问题是点击删除按钮时调用的方法，不能把模板当中的下标当参数传到方法内，官网也没有写对应的样例，最后试了试用react的方式去处理，结果就OK了。 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; export let name; export let todoInputText; export let todoList = []; export function keyupHandler(e) &#123; if(e.keyCode === 13) &#123; todoList = todoList.concat([&#123; name: todoInputText, completed: false &#125;]) &#125; &#125; export function remoteTodo(index) &#123; todoList.splice(index, 1) todoList = todoList &#125;&lt;/script&gt;&lt;div&gt; &lt;input on:keydown=\"&#123;keyupHandler&#125;\" bind:value=\"&#123;todoInputText&#125;\" type=\"text\" placeholder=\"请输入待办事项\"&gt; &lt;button on:click=\"&#123;log&#125;\"&gt;clickme&lt;/button&gt; &lt;ul&gt; &#123;#each todoList as item, i&#125; &lt;li :class=\"&#123;item.completed ? 'done' : ''&#125;\"&gt; &lt;input type=checkbox bind:checked=&#123;item.completed&#125;&gt; &#123;item.name&#125; &lt;button on:click=&#123;remoteTodo.bind(this,i)&#125;&gt;删除&lt;/button&gt; &lt;/li&gt; &#123;/each&#125; &lt;/ul&gt; &lt;/div&gt; 碰到的还有另外一个问题，貌似svelte没有给Array的事件做观察，所以当我们调用splice、push、pop这样的方法时，并不能响应式的触发视图更新，只能重新赋一遍值。目前还没有找到好的思路。 总结尝试了以下svelte的使用，感觉还是不错的，据说他在渲染的性能上是强过react、vue、augular的，同时它也是打包后体积最小的一个框架了。然后在代码编写上也比较简洁，不用像react那样继承class也不用像vue那样写那么多 data methods等。目前svelte也推出了状态管理的解决方案，不知道有没有路由相关的。多尝试些不同的框架也能增加自己的见识，开阔视野吧。如果有兴趣的话，可以看看官方文档。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"}]},{"title":"vuex持久化插件","slug":"vuex持久化插件","date":"2020-03-15T12:37:12.000Z","updated":"2020-03-15T13:56:55.220Z","comments":true,"path":"2020/03/15/vuex持久化插件/","link":"","permalink":"https://haoge744.github.io/2020/03/15/vuex%E6%8C%81%E4%B9%85%E5%8C%96%E6%8F%92%E4%BB%B6/","excerpt":"vuex里存储的也只是一个全局变量，页面刷新之后，数据则会丢失。","text":"vuex里存储的也只是一个全局变量，页面刷新之后，数据则会丢失。 编写vuex插件进行持久化, 原地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 新建 storage.js/** * vuex localStorage plugin *//** * * @param * namespace 命名空间 * storage 存储对象 * persistence 持久化的state名 */export default function storagePlugin(&#123; namespace = 'mfg-vux-', storage = localStorage, persistence = []&#125; = &#123;&#125;) &#123; let serialize = JSON.stringify, deserialize = JSON.parse, isAll = persistence.length === 0 // 传入空数组代表存储所有的值 /** * 获取持久化的state * @param &#123;[type]&#125; state [description] * @return &#123;[type]&#125; [description] */ function getState(state) &#123; let data = &#123;&#125;, keys = isAll ? Object.keys(state) : persistence, i = 0, len = keys.length for (; i &lt; len; i++) &#123; let key = keys[i], value = deserialize(storage.getItem(namespace + key)) data[key] = value === null ? state[key] : value &#125; return data &#125; /** * 持久化state * @param &#123;[type]&#125; state [description] */ function setState(state) &#123; let keys = isAll ? Object.keys(state) : persistence, i = 0, len = keys.length for (; i &lt; len; i++) &#123; let key = keys[i] storage.setItem(namespace + key, serialize(state[key])) &#125; &#125; return store =&gt; &#123; let state = store.state // 初始化state store.replaceState( _.merge( &#123;&#125;, state, getState(state) ) ) // 持久化state store.subscribe((mutation, state) =&gt; &#123; setState(state) &#125;) &#125;&#125; vuex中使用插件 12345678910111213// vuex部分代码import storage from './plugins/storage'export defualt new Vuex.Store(&#123; state, mutations, getters, actions, plugins: [storage(&#123; persistence: ['testText'] &#125;)] , strict: process.env.NODE_ENV !== 'production'&#125;) // 还有个跟简单的方法 转载至 123456789101112131415export default &#123; name: 'App', created () &#123; //在页面加载时读取sessionStorage里的状态信息 if (sessionStorage.getItem(\"store\") ) &#123; //this.$store.replaceState()替换 store 的根状态 this.$store.replaceState(Object.assign(&#123;&#125;, this.$store.state,JSON.parse(sessionStorage.getItem(\"store\")))) &#125; //在页面刷新时将vuex里的信息保存到sessionStorage里 window.addEventListener(\"beforeunload\",()=&gt;&#123; sessionStorage.setItem(\"store\",JSON.stringify(this.$store.state)) &#125;) &#125;&#125;","categories":[{"name":"vuex","slug":"vuex","permalink":"https://haoge744.github.io/categories/vuex/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://haoge744.github.io/tags/vuex/"}]},{"title":"date-fns的使用","slug":"date-fns的使用","date":"2020-03-15T05:17:23.000Z","updated":"2020-03-24T13:53:41.665Z","comments":true,"path":"2020/03/15/date-fns的使用/","link":"","permalink":"https://haoge744.github.io/2020/03/15/date-fns%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"由于使用 Webpack 打包 moment.js 时，会将 moment.js 所有的 locale 全部打包进去。这样会让包的体积很大，现在有个比较好的替代方案就是使用date-fns","text":"由于使用 Webpack 打包 moment.js 时，会将 moment.js 所有的 locale 全部打包进去。这样会让包的体积很大，现在有个比较好的替代方案就是使用date-fns 安装1npm install date-fns --save 常用apidate-fns的所有方法都是按模块化加载的所以需要像下面这样使用，这样做的好处是对webapck treeShaking更加友好，然后在打包的时候体积可以做到最小。 12import &#123;format&#125; from 'date-fns'format(new Date(), 'yyyy-MM-dd') format1234import &#123; format &#125; from 'date-fns'// 格式化，非常常用的方法console.log(format(new Date(), 'yyyy-MM-dd hh:mm:ss'))// =&gt; 2019-03-15 11:19:56 add123456789101112// 日期加 年月日小时分秒 等var result = add(new Date(2014, 8, 1, 10, 19, 50), &#123; years: 2, months: 9, weeks: 1, days: 7, hours: 5, minutes: 9, seconds: 30,&#125;)//=&gt; Thu Jun 15 2017 15:29:20// 此外还有对应的 addYears() addMonths() addDays() addHours() addMinutes() addSeconds() sub123456789101112// 当前日期减 同上const result = sub(new Date(2017, 5, 15, 15, 29, 20), &#123; years: 2, months: 9, weeks: 1, days: 7, hours: 5, minutes: 9, seconds: 30&#125;)//=&gt; Mon Sep 1 2014 10:19:50// 也有类似的subYears()等方法同add closestIndexTo &amp; closestTo1234567891011// 传入一个日期和一个日期数组，返回最接近的那一个的对象/索引var dateToCompare = new Date(2015, 8, 6)var datesArray = [ new Date(2015, 0, 1), new Date(2016, 0, 1), new Date(2017, 0, 1)]var result = closestIndexTo(dateToCompare, datesArray)//=&gt; 1var result = closestTo(dateToCompare, datesArray)/=&gt; 2016-01-01 isToday &amp; isTomorrow &amp; isYesterday1234// 判断传入的日期是否是今天/明天/昨天// If today is 6 October 2014, is 6 October 14:00:00 today?var result = isToday(new Date(2014, 9, 6, 14, 0))// =&gt; true parse123// 把字符串转换为Date类型 // v2.x.x// 接收参数dateString formatString , referenceDate options 转换失败会返回第三个参数， 注意第三个参数是必填的parse('2019-08-08', 'yyyy-MM-dd',new Date()) isEqual123456// 判断两个日期是否相等var result = isEqual( new Date(), new Date())// true max &amp; min12345// 获取日期数组中最大/最小的日期max([new Date(1989, 6, 10),new Date(1987, 1, 11)])// =&gt; 1989, 6, 10min([new Date(1989, 6, 10),new Date(1987, 1, 11)])// =&gt; 1987, 1, 11 startOfMonth &amp; endOfMonth:123456// 获取日期月份的第一天和最后一天console.log(endOfMonth(new Date(2020, 1)))console.log(startOfMonth(new Date(2020,1)))// Sat Feb 29 2020 23:59:59 GMT+0800 (中国标准时间)// Sat Feb 01 2020 00:00:00 GMT+0800 (中国标准时间)// 还有些类似startOfDay startOfToday startOfHours等的api可以方便的获取各种开始、结束时间 startOfWeek &amp; endOfWeek1234567// 获取传入日期的一周的第一天和最后一天， 周日是第一天 周六是最后一天console.log(startOfWeek(new Date(2020, 1)))console.log(endOfWeek(new Date(2020,1)))// Sun Jan 26 2020 00:00:00 GMT+0800 (中国标准时间)// Sat Feb 01 2020 23:59:59 GMT+0800 (中国标准时间)// tips：如果需要从周一开始 需要添加参数endOfWeek(new Date(2020,1),&#123;weekStartsOn: 1&#125;) differenceInDays123// 获取两个时间相差多少天differenceInDays(new Date(),addDays(new Date(),1))// =&gt; -1 其他时间的方法: differenceInHours();获得两个时间相差的小时. differenceInMinutes(): 获得两个时间相差的分钟 differenceInMonths():获得两个时间相差月份 differenceInWeeks(): 获得两个时间相差的周数 differenceInYears():获得两个时间相差的年数 isBefore &amp; isAfter1234// 判断两个时间是否在之前、之后var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))// 1.false 2.true 我认为比较常用的就是上面这些，很多时候原生的api也可以满足需要。引入api按需引入就好，不要直接import * 。更多详细的api可以去他的官网看。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"}]},{"title":"vue缓存问题","slug":"vue缓存问题","date":"2020-03-14T03:55:42.000Z","updated":"2020-01-27T12:32:02.000Z","comments":true,"path":"2020/03/14/vue缓存问题/","link":"","permalink":"https://haoge744.github.io/2020/03/14/vue%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"关于vue路由缓存问题之前在工作中遇到了个关于页面跳转相关的缓存问题，没想到解决起来意外的挺简单的。 需求是这样的，有个移动webApp，下面有4个tab可以切换，然后其中有个页面有个列表，在列表页点击某些功能可以跳转至页面B、页面C,页面C返回的时候列表不能刷新，滚动条需要在原来的位置，然而在C页面做了一些操作的时候是会影响列表项的值的，做了这些操作的话，返回列表页需要刷新数据。 我的解决方案当然是用keep-alive了，然后把他的includes绑定到状态中去，这样可以方便的进行增加、删除。然后在列表页面中添加路由守卫，当判断要跳转到B、C页面的时候，把当前页面添加到缓存中，如果在二级页面需要删除缓存，则在状态管理里把缓存删掉，这样回到列表页之后就会刷新了。 需要注意的是includes中使用的是组件的名称进行缓存的，所以组件的命名要规范，有语义，最好不要重复。","text":"关于vue路由缓存问题之前在工作中遇到了个关于页面跳转相关的缓存问题，没想到解决起来意外的挺简单的。 需求是这样的，有个移动webApp，下面有4个tab可以切换，然后其中有个页面有个列表，在列表页点击某些功能可以跳转至页面B、页面C,页面C返回的时候列表不能刷新，滚动条需要在原来的位置，然而在C页面做了一些操作的时候是会影响列表项的值的，做了这些操作的话，返回列表页需要刷新数据。 我的解决方案当然是用keep-alive了，然后把他的includes绑定到状态中去，这样可以方便的进行增加、删除。然后在列表页面中添加路由守卫，当判断要跳转到B、C页面的时候，把当前页面添加到缓存中，如果在二级页面需要删除缓存，则在状态管理里把缓存删掉，这样回到列表页之后就会刷新了。 需要注意的是includes中使用的是组件的名称进行缓存的，所以组件的命名要规范，有语义，最好不要重复。 在状态管理中添加缓存的状态和一些动作新建cache.js 12345678910111213141516171819202122import Vue from 'vue'const cache = &#123; state: &#123; cacheComps: [] // 缓存组件 &#125;, mutations: &#123; addCacheComp: (state, name) =&gt; &#123; if (!state.cacheComps.includes(name)) &#123; state.cacheComps.push(name) &#125; &#125;, removeCacheComp: (state, name) =&gt; &#123; const index = state.cacheComps.indexOf(name) console.log('index:' + index) if (index &gt; -1) &#123; Vue.set(state, 'cacheComps', state.cacheComps.splice(index, 1)) &#125; &#125; &#125;&#125;export default cache 添加路由守卫1234567891011121314beforeRouteLeave (to, from, next) &#123; // 缓存策略，当页面离开前判断 是不是以下几个路由，如果是，添加至状态，不是则清空 console.log(to) const cachePath = ['a','b'] const needCache = cachePath.some(item =&gt; to.path.indexOf(item) &gt;= 0) if (needCache) &#123; // 由于我是嵌套路由实现的tab 所以需要缓存父子的组件 this.$store.commit('addCacheComp', 'layout') this.$store.commit('addCacheComp','list') &#125; else &#123; this.$store.commit('removeCacheComp', 'layout') this.$store.commit('removeCacheComp','list') &#125; next()&#125; 适当情况下清空缓存在B或C页面做了某些提交操作，影响列表数据时需要删除缓存： 1234567commit()&#123; doCommit().then(() =&gt; &#123; // ... this.$store.commit('removeCacheComp', 'layout') this.$store.commit('removeCacheComp','list') &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue插件开发","slug":"vue插件开发","date":"2020-02-15T14:06:55.000Z","updated":"2020-02-15T14:06:55.000Z","comments":true,"path":"2020/02/15/vue插件开发/","link":"","permalink":"https://haoge744.github.io/2020/02/15/vue%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","excerpt":"Vue插件化我们注意到在使用一些Vuex、Vue-router或者是像element-ui等库的时候。 使用到的Vue.use()方法。在调用use方法内部做了哪些事呢，还有为什么Vue.use(element-ui) 就可以使用el开头的组件了呢。","text":"Vue插件化我们注意到在使用一些Vuex、Vue-router或者是像element-ui等库的时候。 使用到的Vue.use()方法。在调用use方法内部做了哪些事呢，还有为什么Vue.use(element-ui) 就可以使用el开头的组件了呢。 Vue.use方法的形参是一个函数，或者一个对象，为对象时，需要有一个叫install的方法，还有一个可选参数options，Vue在初始化时会调用use方法接收的对应的方法，并传入Vue对象,和options(如果有的话)，那么我们就可以利用Vue做全局组件、指令的注册: 1234567891011121314151617181920212223242526272829303132333435363738let myPlugin = &#123;&#125;myPlugin.install = function (Vue, options) &#123; // 判断插件是否已经注册 if (myPlugin.install.installed) return Vue.prototype.ss = () =&gt; &#123; // 注册全局方法 &#125; const component = Vue.extend(&#123; propsData: &#123; // propData: ... &#125;, template: `&lt;li&gt;&#123;&#123; text &#125;&#125;&lt;/li&gt;`,// 也可以使用render data () &#123; return &#123; text: '123' &#125; &#125; &#125;) Vue.component('component-name', component) // 注册自定义指令 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // something &#125; &#125;) Vue.mixin(&#123; // 混入全局对象 可以混入data和生命周期方法 data () &#123; aaa: '12' &#125;, created() &#123; // dosomething &#125; &#125;) &#125;export default myPlugin 添加全局插件二创建组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;el-dialog width=\"70%\" top=\"7vh\" :visible.sync=\"dialogFormVisible\" :close-on-click-modal=\"false\" :show-close=\"false\" &gt; &lt;div slot=\"title\"&gt; &lt;span class=\"result-check-tips\"&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;c-table :isPage=\"false\" :data=\"list\" :columns=\"header\" dragTableKey=\"dragTableKeyCheckResult\" &gt; &lt;template slot=\"num\" slot-scope=\"item\"&gt; &lt;div&gt;&#123;&#123;item.bodyItemIndex+1&#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/c-table&gt; &lt;div slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button @click=\"cancel\" size=\"mini\"&gt;返 回&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; dialogFormVisible: false, title: \"\", list: [], header: [] &#125;; &#125;, methods: &#123; getProductCheckResult(options) &#123; this.type=options.type; this.title = options.msg; this.list = options.data; this.dialogFormVisible = true; &#125;, cancel() &#123; this.dialogFormVisible = false; &#125; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021222324// productCheckResult.js文件import productCheckResult from './productCheckResult.vue'export default &#123; install: function (Vue) &#123; const productCheckResultInstance = Vue.extend(productCheckResult) let productCheckResultInit; const initInstance = () =&gt; &#123; // 实例化vue实例 productCheckResultInit = new productCheckResultInstance(); let productCheckResultEl = productCheckResultInit.$mount().$el; document.body.appendChild(productCheckResultEl); &#125;; Vue.prototype.$Dialog = &#123; getProductCheckResult(options) &#123; if (!productCheckResultInit) &#123; initInstance(); &#125; console.log(options) productCheckResultInit.getProductCheckResult(options) &#125; &#125; &#125;&#125;// 在main.js中注册 省略...","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"express设置跨域和自定义Header","slug":"express设置跨域和自定义Header","date":"2020-02-01T13:05:08.000Z","updated":"2020-02-01T13:05:08.000Z","comments":true,"path":"2020/02/01/express设置跨域和自定义Header/","link":"","permalink":"https://haoge744.github.io/2020/02/01/express%E8%AE%BE%E7%BD%AE%E8%B7%A8%E5%9F%9F%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89Header/","excerpt":"有些时候服务器和前端服务器部署在不同的地方，这个时候需要处理跨域问题，而且为了安全，一些接口必须要传token才能访问通过，可以把它放在header中。","text":"有些时候服务器和前端服务器部署在不同的地方，这个时候需要处理跨域问题，而且为了安全，一些接口必须要传token才能访问通过，可以把它放在header中。 express的设置express设置允许跨域及设置自定义请求头: 12345678910111213141516171819202122const express = require('express')const app = express()var allowCrossDomain = function(req, res, next) &#123; // 允许跨域的主机，这里暂时设置* res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Methods\", \"GET,POST,DELETE,PUT,OPTIONS,HEAD,FETCH\"); res.header(\"Access-control-max-age\", 1000); //测试通过 // 如果需要支持cookie，就要加入 res.header('Access-Control-Allow-Credentials', true); res.header('Access-Control-Allow-Headers', 'Content-Type,Content-Length, Authentication,Origin,Accept,X-Requested-With'); res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE'); // res.header('X-Powered-By', ' 3.2.1'); // res.header('Content-Type', 'application/json;charset=utf-8'); // 自定义header的话web端会先发一个预请求OPTIONS，必须要返回200,告诉前台可以访问 if (req.method === 'OPTIONS') &#123; res.sendStatus(200); &#125; else &#123; next(); &#125;&#125;;app.use(allowCrossDomain); 编写接口1234567891011app.all('/getData', (req, res) =&gt; &#123; console.log(req.method) const token = req.get('Authentication') console.log('token:',req.get('Authentication')) if (!token) &#123; console.log('token is gone') res.status(401).end('Token invaildate') return &#125; // 在确认有token的情况下我们可以根据token在redis获取到用户信息..&#125;)","categories":[{"name":"express","slug":"express","permalink":"https://haoge744.github.io/categories/express/"}],"tags":[{"name":"node","slug":"node","permalink":"https://haoge744.github.io/tags/node/"},{"name":"express","slug":"express","permalink":"https://haoge744.github.io/tags/express/"}]},{"title":"vueTips","slug":"vueTips","date":"2020-01-25T12:42:02.000Z","updated":"2020-01-27T12:32:02.000Z","comments":true,"path":"2020/01/25/vueTips/","link":"","permalink":"https://haoge744.github.io/2020/01/25/vueTips/","excerpt":"前面发过一篇javascript的tips这次发布一些vue相关的,如果以后还有相关的会更新。 生命周期Tip:beforeCreate和created触发时，dom还不存在。服务端渲染时，beforeMount和mounted不会触发，因为服务端不会创建节点。renderError 渲染错误时触发 测试和正式环境可以使用errorCaptured来收集错误, 子组件会向父组件冒泡，一直冒到最上层(App.vue)。 watch深入观察对象/数组变化watch: { ‘obj.a’: // 监听对象中某个属性的变化。。 firstName: { handler(newName, oldNme){ this.fullName = newName + “ “ + this.lastName }, immediate: true, // 初始化就执行一次 deep: true // 深入观察，会观察对象或数组的变化 比如想监听对象中某一个属性的变化,开销大不推荐 }}","text":"前面发过一篇javascript的tips这次发布一些vue相关的,如果以后还有相关的会更新。 生命周期Tip:beforeCreate和created触发时，dom还不存在。服务端渲染时，beforeMount和mounted不会触发，因为服务端不会创建节点。renderError 渲染错误时触发 测试和正式环境可以使用errorCaptured来收集错误, 子组件会向父组件冒泡，一直冒到最上层(App.vue)。 watch深入观察对象/数组变化watch: { ‘obj.a’: // 监听对象中某个属性的变化。。 firstName: { handler(newName, oldNme){ this.fullName = newName + “ “ + this.lastName }, immediate: true, // 初始化就执行一次 deep: true // 深入观察，会观察对象或数组的变化 比如想监听对象中某一个属性的变化,开销大不推荐 }} 父组件和子/孙组件共享值provide的用法，本人不是很常用。 // 父组件export default { provide () { return { yeye: this } }} // 子组件export default { inject: [‘yeye’] mounted () { console.log(this.yeye) }} v-bind父组件 子组件this.$attrs 模板语法绑定属性时也可以使用模板语法:placeholder=”$attrs.disabled?’’:placeholder || 请输入${label}“事件传递 @change=”handler($event, 2)” Vue强制渲染this.$forceUpdate();进行强制渲染 Object.freeze()冻结对象如果你有一个巨大的数组或Object，并且确信数据不会修改，使用Object.freeze()可以让性能大幅提升。new Vue({ data: { // vue不会对list里的object做getter、setter绑定 list: Object.freeze([ { value: 1 }, { value: 2 } ]) }, mounted () { // 界面不会有响应 this.list[0].value = 100; // 下面两种做法，界面都会响应 this.list = [ { value: 100 }, { value: 200 } ]; this.list = Object.freeze([ { value: 100 }, { value: 200 } ]); }}) 跳转相同路由页面不刷新 (需要判断跳转其它路由的情况)watch: { ‘$route’: (to, from) { this.$router.go(0); }}, 事件绑定使用计算属性123456789101112131415161718&lt;template&gt; &lt;componentA v-bind&#x3D;&quot;$attrs&quot; :value&#x3D;&quot;value&quot; v-on&#x3D;&quot;bindListeners&quot;&gt; &lt;&#x2F;componentA&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default&#123; computed: &#123; bindListeners() &#123; const events &#x3D; this.$attrs.listeners if (events &amp;&amp; Object.keys(events).includes(&#39;input&#39;)) &#123; this.$delete(events,&#39;input&#39;) &#125; return Object.assign(this.$listeners,events) &#125; &#125;&#125;&lt;&#x2F;script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"jsTips","slug":"jsTips","date":"2020-01-18T10:38:32.000Z","updated":"2020-01-18T10:38:32.000Z","comments":true,"path":"2020/01/18/jsTips/","link":"","permalink":"https://haoge744.github.io/2020/01/18/jsTips/","excerpt":"小本本记录了一些关于js的小tips，下面整理一下发出来，内容可能会有过时。","text":"小本本记录了一些关于js的小tips，下面整理一下发出来，内容可能会有过时。 打印变量类型判断是否是对象 1Object.prototype.toString.call(obj) === '[object Object]' 判断变量是不是无穷的 1isFinite(val) 删除数组元素 12345678function remove (arr, item) &#123; if (arr.length) &#123; var index = arr.indexOf(item); if (index &gt; -1) &#123; return arr.splice(index, 1) &#125; &#125;&#125; replace高级应用及占位符_ 12345678910111213141516171819202122232425262728str.replace(/-(\\w)/g, function (_, c) &#123; return c ? c.toUpperCase() : ''; &#125;) str.replace(hyphenateRE, '-$1').toLowerCase(// 1.$i (i:1-99) : 表示从左到右正则子表达式所匹配的文本。 // 2.$&amp;:表示与正则表达式匹配的全文本。 // 3.$`(`:切换技能键)：表示匹配字符串的左边文本。 // 4.$'(‘:单引号)：表示匹配字符串的右边文本。// 5.$$：表示$转移。``` 5. // Firefox has a \"watch\" function on Object.prototype...火狐浏览器对象的原型链上都有watch函数6. void 0 得到纯正的undefined7. 常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate。而常见的 micro task 有 MutationObsever 和 Promise.then。8. DocumentFragment documentFragment的作用是创建临时的dom节点，当append的时候才真正渲染dom从而可以提升效率``` javascriptwindow.requestAnimationFrame(function()&#123; let fragment = document.createDocumentFragment(); for(let i = 0; i &lt; pageCount; i++)&#123; let li = document.createElement('li'); li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) loop(curTotal - pageCount,curIndex + pageCount) &#125;) 获取元素离顶部的距离 1document.getElementById('aa').getBoundingClientRect().top window.scrollY 页面滚动y距离 获取对象类型属性 12345const _toString = Object.prototype.toString function toRawType(value) &#123; return _toString.call(value).slice(8, -1) &#125;console.log(toRawType(&#123;&#125;))//Object 字符串占位符 12345678910111213141516171819202122232425262728String.prototype.format = function() &#123; if(arguments.length == 0) return this; var param = arguments[0]; var s = this; if(typeof(param) == 'object') &#123; for(var key in param) s = s.replace(new RegExp(\"\\\\&#123;\" + key + \"\\\\&#125;\", \"g\"), param[key]); return s; &#125; else &#123; for(var i = 0; i &lt; arguments.length; i++) s = s.replace(new RegExp(\"\\\\&#123;\" + i + \"\\\\&#125;\", \"g\"), arguments[i]); return s; &#125;&#125; var str = \"&#123;one&#125;&#123;two&#125;&#123;three&#125;\".format(&#123;one: \"1\",two: \"2\",three: \"3\"&#125;); //123var str2 = \"&#123;0&#125; &#123;1&#125; &#123;2&#125;\".format(\"how\",\"are\",\"you\"); //how are you``` 13. 如果需要在数组循环时跳出循环 推荐使用every函数而不是forEacth14. !! 的妙用如果需要判断一个对象是否是空 可以使用``` javascriptlet required = !!obj// 而不是if (obj) &#123; let required = true&#125; map使用await异步函数 123456789101112131415161718async onGetLocation(datas)&#123; let res = await Promise.all(datas.map(async (item) =&gt; &#123; return await this.convertFrom( [item.lon, item.lat]) &#125;)) this.setState(&#123; pathSimplifierData: res &#125;)&#125;convertFrom(point, type = 'gps') &#123; return new Promise((resolve, reject) =&gt; &#123; window.AMap.convertFrom(point,type, (status,result) =&gt; &#123; if(result.info === 'ok') &#123; resolve ( [result.locations[0].lng,result.locations[0].lat]) &#125; &#125;) &#125;)&#125; 是否js原生方法 123function isNative(Ctor) &#123; return typeof Ctor === 'function' &amp;&amp; /native code/.test(Ctor.toString())&#125; 字符串数字转千位符 123function thousandth(str) &#123; return str.replace(/\\d(?=(?:\\d&#123;3&#125;)+(?:\\.\\d+|$))/g, '$&amp;,');&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"},{"name":"tips","slug":"tips","permalink":"https://haoge744.github.io/tags/tips/"}]},{"title":"css选择器的命名是一个哲学问题","slug":"css选择器的命名是一个哲学问题","date":"2020-01-05T13:56:03.000Z","updated":"2020-03-14T01:37:26.436Z","comments":true,"path":"2020/01/05/css选择器的命名是一个哲学问题/","link":"","permalink":"https://haoge744.github.io/2020/01/05/css%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%93%B2%E5%AD%A6%E9%97%AE%E9%A2%98/","excerpt":"以下内容摘抄、总结于《CSS选择器世界》 不推荐的命名方法根据单词命名:12345.title &#123;&#125;.red &#123;&#125;.box &#123;&#125;.success &#123;&#125;.red &#123;&#125; 以上命名虽然简短，语义也更易懂，但是重名频率太高，不推荐。 使用拼音命名12.cs-tou &#123;&#125;.cs-hezi &#123;&#125; 试用拼音虽然胜利，对功能也没有影响，但却是一个比较傻的行为，因为他会让人感觉你比较业余。你自己命名是省力了，但这样的命名对其他同事而言却苦不堪言，因为可读性较差。 使用id选择器1#box &#123;&#125; id选择器虽然性能很不错，可以和类选择器分庭抗礼，但是他存在以下两个巨大缺陷","text":"以下内容摘抄、总结于《CSS选择器世界》 不推荐的命名方法根据单词命名:12345.title &#123;&#125;.red &#123;&#125;.box &#123;&#125;.success &#123;&#125;.red &#123;&#125; 以上命名虽然简短，语义也更易懂，但是重名频率太高，不推荐。 使用拼音命名12.cs-tou &#123;&#125;.cs-hezi &#123;&#125; 试用拼音虽然胜利，对功能也没有影响，但却是一个比较傻的行为，因为他会让人感觉你比较业余。你自己命名是省力了，但这样的命名对其他同事而言却苦不堪言，因为可读性较差。 使用id选择器1#box &#123;&#125; id选择器虽然性能很不错，可以和类选择器分庭抗礼，但是他存在以下两个巨大缺陷 - 优先级太高，如果需要重置某些样式，必须要对id选择器选择覆盖，再多的类名都没有用，这会使得项目选择器的优先级变得非常混乱。如果非要使用元素的id选择器作为标识，可以用属性选择器替代:`[id=&quot;box&quot;]` - 和Javascript耦合,实际开发时，元素的ID主要用在Javascript中，以方便Dom元素快速获取它，如果ID同时和样式关联，它的可维护性会大打折扣，一旦ID变化，需要同时修改CSS和Javascript，然而实际上开发只会修改一处，这就是很多后期bug产生的原因。使用嵌套选择器以下选择器在项目中经常出现的: 12345.nav a &#123;&#125;.box &gt; div &#123;&#125;.avatar img &#123;&#125;.box .pic .icon &#123;&#125; 特别是在有了Scss、Less、Stylus之类的预编译工具出现后，5、6层嵌套的css选择器也大量出现，这太糟糕了！他们都是特别差的代码，其性质比Javascript使用全局变量还要糟。除了在书写时省电力其他全是缺点，包括: 渲染性能糟糕 优先级混乱 样式布局脆弱 1. 渲染性能糟糕过深的嵌套会对性能产生影响，因为每加深一层嵌套，浏览器在进行选择器匹配的时候回多一层计算，一两个嵌套对性能自然毫无影响，但是，如果数千行CSS都才用了多层嵌套，量变引起质变，此时，光CSS样式的解析就可以到达百毫秒级别。 2. 优先级混乱书写选择器尽量遵循一个原则，那就是尽可能保持比较低的优先级，这样方便以后以较低的成本重置一些样式。然而，一旦选择器开始嵌套，优先级规则就会变得复杂，当我们想要重置某些样式的时候，你会发现一个类名不管用，两个类名也不管用，打开控制台一看，你希望重置的样式居然有6个选择器依次嵌套。如: 1.layer_send_video_v3 .video_upbox dd .dd_succ .pic_default img &#123;&#125; 此时如果想要重置img的样式，只有这几种方法：1.使用同一优先级的选择器，但这个选择器的位置在需要重置的CSS代码后面；2.使用更深的层级，例如 使用7层选择器 这是最常用的方法 3. 使用Id选择器或者!important。他们都是很糟糕的解决方法。 3. 样式布局脆弱1.layer_end_video_v3 .video_upbox dd .dd_succ .pic_default img &#123;&#125; 在实际开发维护的过程中，调整HTML标签是非常常见的事情，例如，将元素换成语义更好的。但是如果使用的是dd和img选择器,HTML标签是不能换的,因为如果标签换了，整个样式都会无效，你必须去CSS文件中找到对应的标签选择器进行同步修改，维护成本巨大。 推荐的命名方法使用类选择器不要使用以下的嵌套选择器和标签选择器了: 1234567&lt;nav class=\"nav\"&gt; &lt;a&gt;链接1&lt;/a&gt; &lt;a&gt;链接2&lt;/a&gt; &lt;a&gt;链接3&lt;/a&gt;&lt;/nav&gt;.nav &#123;&#125;.nav a &#123;&#125; 请换成: 1234567&lt;nav class=\"cs-nav\"&gt; &lt;a class=\"cs-nav-a\"&gt;链接1&lt;/a&gt; &lt;a class=\"cs-nav-a\"&gt;链接2&lt;/a&gt; &lt;a class=\"cs-nav-a\"&gt;链接3&lt;/a&gt;&lt;/nav&gt;.cs-nav &#123;&#125;.cs-nav-a &#123;&#125; 好的命名方法CSS命名结构我们使用一些第三方UI时可以看到别人会以项目名开头去命名css，比如element-ui以el开头,vant-ui使用van开头等等，这种命名方式有效的防止了和我们自己书写的css命名冲突的问题。所以我们也可以效仿。以项目名或者公司名来开头。比如以下格式: 12projectname-module-titlebusiness-module-footer 示例: 1234.cs-shop-panel-header&#123;&#125;.cs-shop-panel-header-title&#123;&#125;.cs-dialog-header&#123;&#125;.cs-dialog-footer&#123;&#125; 不要歧视使用面向属性的命名不少开发者是不认可下面这种基于css属性本身的命名方式的，尤其是Web标准刚兴起的那段时期。 123456789.dn &#123;display: none;&#125;.db &#123;display: block;&#125;.dib &#123;display: inline-block;&#125;....ml20 &#123;margin-left:20px;&#125;....vt &#123;vertial-align: top;&#125;.text-ell &#123;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;&#125;... 为什么呢?因为这类命名本质上和html元素上写style属性没有什么不同。 1&lt;span style=\"display:inline-block;margin-left:20px\"&gt;文字&lt;/span&gt; 效果是一样的，只是前者在书写上更为简洁，优先级更低。 但是我们需要调整样式的时候，改动的是HTML，而非CSS，这不等于HTML和CSS耦合在一起了吗。于是很多人就接受不了了，尤其在推崇内容和样式分离的年代。我们做技术，一定要保持理性，要有自己的思考，最合适的才是最好的。技术的发展也想流行趋势一样是一个圈，转了一圈又回来了。随着React等框架的星期，”CSS in JavaScript”的概念居然也出现了(类似styled-components)。 在某个很深的角落里里有一张图片，你希望这张图片的display设置为block,就算你专门给他命名一个语义化的CSS也没有意义。 1.pic_default_img &#123;display:block;&#125; 类名的意义在于重复利用，如果他只是为了解决某一个单独的问题，那么还不如写style内联样式。 正确使用状态类名页面的交互总是伴随着各种状态变化，包括禁用状态、选中状态、激活状态等 123.cs-content.active&#123;&#125;.cs-check-item.checked&#123;&#125;.cs-input-item.disabled&#123;&#125; .active类名本身没有样式，就是一个状态标识符，用来与其他类名发生关系，让其他类名的样式发生变化。并且与JavaScript代码逻辑分离，可以有效降低日后维护成本。可读性强。 最佳实践1. 命名书写(1) 命名建议小写，使用英文单词或缩写，对于专有名词，可以使用拼音，例如: 1.cs-logo-youku &#123;&#125; 不建议使用驼峰命名，驼峰命名建议专门给JavaScript DOM用，以便和CSS样式类名区分开。 1.csLogoYouku&#123;&#125; /* 不建议 */ (2) 对于组合命名，可以短横线或下划线连接，可以组合使用短横线和下划线，也可以连续短横线或下划线连接，任何方式都可以，只要在项目中保持一致就可以: 1234.cs-logo-youku &#123;&#125;.cs_logo_youku &#123;&#125;.cs-logo--youku &#123;&#125;.cs-logo__youku &#123;&#125; 组合格式没有必要超过5个，5个是极限。 (3) 设置统一前缀，强化品牌同时避免样式冲突: 123.cs-header &#123;&#125;.cs-log &#123;&#125;.cs-logo-a &#123;&#125; 这样，CSS代码的美观度也会提升很多 2. 选择器类型根据选择器的使用类型，我将网站CSS分成3个部分，分别是CSS重置样式，CSS基础样式和CSS交互变化样式。 无论那种样式都不推荐使用ID选择器，实在要用，使用属性选择器代替，他的优先级和类选择器一模一样。 1[id=\"someId\"] &#123;&#125; CSS样式的重置可以使用标签选择器或者属性选择器: 1234567body,p &#123;margin:0;&#125;[type=\"radio\"],[type=\"checkbox\"] &#123; position:absolute; clip: rect(0 0 0 0)&#125; 所有CSS基础样式全部使用类选择器，没有层级，没有标签。 12.cs-module .img &#123;&#125; /* 不推荐*/.cs-module-ul &gt; li &#123;&#125; /* 不推荐*/ 在所有HTML的标签上都写上不会冲突的类名 12.cs-module-img &#123;&#125;.cs-module-li &#123;&#125; 所有HTML都需要重新命名的问题可以通过面向属性命名的CSS样式库得到解决。 所有选择器嵌套或者级联，所有的伪类全部都在CSS交互样式发生变化的时候使用。例如: 123456.cs-content.active&#123; height: auto;&#125;.active &gt; .cs-content-more&#123; display: none;&#125; 例如 123456.cs-button:active&#123; filter: hue-rotate(5deg);&#125;.cs-input:focus &#123; border-color: var(--blue);&#125; 状态类名本身不包含任何CSS样式，他就是一个标识符。 如果我们无法修改HTML。例如无法通过修改class属性添加新的类名，则级联、嵌套，以及各种高级伪类的使用都不受上面使用规则的限制。 再和目前很多人的实现对比一下，最佳实践的不同之处在于： 无标签，无层级； 状态类名标识符； 面向属性命名的CSS样式库。","categories":[{"name":"css","slug":"css","permalink":"https://haoge744.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://haoge744.github.io/tags/css/"}]},{"title":"nginx部署vue项目及配置路由模式","slug":"nginx部署vue项目及配置路由模式","date":"2020-01-02T15:10:31.000Z","updated":"2020-01-27T15:32:49.181Z","comments":true,"path":"2020/01/02/nginx部署vue项目及配置路由模式/","link":"","permalink":"https://haoge744.github.io/2020/01/02/nginx%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"vue的默认路由模式采用的是hash模式，使用URL的hash值来模拟路径，于是url改变时，页面不会重载。如果不想要很丑的#号，可以使用路由的history模式,但是部署至服务器后，刷新页面会404找不到页面。原因是浏览器刷新后根据路由的地址是找不到相关资源的，所以我们要给服务器设置相关配置。 警告正确的做法是给服务器设置把所有相关请求都转发到对应的index.html页面就可以了，但是也有个注意的地方，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。 123456const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;)","categories":[{"name":"nginx","slug":"nginx","permalink":"https://haoge744.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://haoge744.github.io/tags/nginx/"}]},{"title":"vue cli2.x及3.x多环境打包配置","slug":"vue-cli2-x及3-x多环境打包配置","date":"2019-12-28T09:23:38.000Z","updated":"2019-12-28T15:52:07.056Z","comments":true,"path":"2019/12/28/vue-cli2-x及3-x多环境打包配置/","link":"","permalink":"https://haoge744.github.io/2019/12/28/vue-cli2-x%E5%8F%8A3-x%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE/","excerpt":"前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。 俗话说懒是程序员三大美德之一，我们不希望每次切换环境都修改参数,我们希望的效果是:每次构建时传入不同的参数来访问不同环境的全局变量。","text":"前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。 俗话说懒是程序员三大美德之一，我们不希望每次切换环境都修改参数,我们希望的效果是:每次构建时传入不同的参数来访问不同环境的全局变量。 vue cli2.x的配置vue cli2.x的配置对比3.x来说复杂一点，因为2.x中默认使用的是webpack3.x,配置项比较多。没有webpack4那么简洁。如果你当前的项目没有安装cross-env需要安装一下: 1npm install cross-env --save-dev 假设我们除了生产环境还需要增加一个测试环境test和预生产环境pre-prod。并且每种环境的后台调用的api接口地址不一样。 一. config目录中复制两个prod.env.js 分别修改为test.env.js和pre.prod.env.js1234567// test.env.js'use strict'module.exports = &#123; NODE_ENV: '\"production\"', BASE_API: '\"http://test.api.com\"', ENV_CONFIG: '\"test\"'&#125; 1234567// pre.prod.env.js'use strict'module.exports = &#123; NODE_ENV: '\"production\"', BASE_API: '\"http://pd.api.com\"', ENV_CONFIG: '\"pre-prod\"'&#125; 修改prod.env.js: 123456'use strict'module.exports = &#123; NODE_ENV: '\"production\"', BASE_API: '\"http://prod.api.com\"', ENV_CONFIG: '\"prod\"' // 设置这个参数对打包没有影响，它的作用是方便访问当前是什么环境&#125; 二. 修改 build/webpack.prod.conf.js12345678const envConfigMap = &#123; 'prod': require('../config/prod.env'), 'test': require('../config/test.env'), 'pre-prod': require('../config/pre.prod.env')&#125;// const env = require('../config/prod.env')const env = envConfigMap[process.env.ENV_CONFIG] || require('../config/prod.env') 三. 修改package.json中的脚本命令12345678910&#123; //... \"scripts\": &#123; // ... // ENV_CONFIG的变量要和上面map中的一致 \"build\": \"cross-env ENV_CONFIG=prod node build/build.js\", \"build--test\": \"cross-env ENV_CONFIG=test node build/build.js\", \"build--pre-prod\": \"cross-env ENV_CONFIG=pre-prod node build/build.js\" &#125;,&#125; 四. 修改build/build.js 添加打包环境提示1const spinner = ora('正在打包...' + process.env.ENV_CONFIG + '环境') 五. 运行命令实现打包123npm run buildnpm run build--testnpm run build--pre-prod 六. 测试运行 npm run build--pre-prod在初始化时打印process.env环境变量,可以看到读取到的配置文件是匹配上的。 vue cli3.x的配置vue-cli3.0之后默认没有提供开发和生产环境的全局变量，需要自己新建。 配置开发、生产环境变量 123// 项目根目录新建 '.env.development' 文件# api地址VUE_APP_BASE_API = '/development/api' 123// 项目根目录新建 '.env.production' 文件# api地址VUE_APP_BASE_API = '/production/api' 代码中使用process.env.VUE_APP_BASE_API去访问它们 注意: 只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。 自定义模式假如我们要创建一个预演的环境需要另外一套参数配置,比如说叫做staging。 在package.json中添加一个命令(也可以在启动时添加 —mode参数) 12345678910\"scripts\": &#123; \"scripts\": &#123; \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", // 启动本地环境 \"staging\": \"vue-cli-service serve --mode staging\" // 打包 \"build-staging\": \"vue-cli-service build --mode staging\" &#125;, 注意:创建 .env.staging, 文件后缀需要与 --mode 后面跟的值一样 12NODE_ENV &#x3D; &#39;production&#39;VUE_APP_BASE_API &#x3D; &#39;&#x2F;staging&#x2F;api&#39; 如果需要再增加配置的话只需要增加一行命令，然后新建一个.env.xxx的文件就ok了，是不是比老版本方便很多呢。 关于环境变量和模式的更多配置信息可以访问官方介绍文档","categories":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/categories/webpack/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/tags/webpack/"},{"name":"前端构建化","slug":"前端构建化","permalink":"https://haoge744.github.io/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%8C%96/"}]},{"title":"Notification的使用","slug":"Notification的使用","date":"2019-12-22T13:12:53.000Z","updated":"2019-12-22T14:52:12.040Z","comments":true,"path":"2019/12/22/Notification的使用/","link":"","permalink":"https://haoge744.github.io/2019/12/22/Notification%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"最近注意到一些网站上渐渐会弹出一个框，提示你是否显示通知，这也意味着这项功能以后会越来越普遍了，像微博、邮箱、爱奇艺等网站已经开始用起来了，如果点击同意显示通知的话，那么前台可能会开启MQ或者使用轮询的方式，去获取你关注的人或者视频有没有更新，如果有则弹起通知，更加提高了用户的体验性。其实有关于通知的相关api之前也有了解过，但是并不深入，今天学习后总结一下，以便自己加深影响。","text":"最近注意到一些网站上渐渐会弹出一个框，提示你是否显示通知，这也意味着这项功能以后会越来越普遍了，像微博、邮箱、爱奇艺等网站已经开始用起来了，如果点击同意显示通知的话，那么前台可能会开启MQ或者使用轮询的方式，去获取你关注的人或者视频有没有更新，如果有则弹起通知，更加提高了用户的体验性。其实有关于通知的相关api之前也有了解过，但是并不深入，今天学习后总结一下，以便自己加深影响。 基础介绍构造方法1let notification = new Notification(title, options) 调用new Notification()之后windows就会弹出一个框，他的参数有以下这些: title通知的标题。 options 可选 dir: 文字的方向.它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左） lang: 指定通知中所使用的语言。这个字符串必须在 BCP 47 language tag 文档中是有效的。 body: 通知中额外显示的字符串 tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。 icon: 一个图片的URL，将被用于显示通知的图标。 属性 Notification.permission 只读属性，用于读取用户是否授权显示通知，可能的值包括: denied (用户拒绝显示);granted(用户允许显示通知);default(未询问过用户，这种状态浏览器也会拒绝显示通知). Notification.title只读属性, 在构造方法中传入的title参数 notification.dir 只读属性,文本显示方向 notification.lang 只读属性,通知的语言 notification.body只读属性,通知中额外显示的字符串 Notification.icon 显示的图标图片的url地址 事件处理 Notification.onclick 处理 click 事件的处理。每当用户点击通知时被触发。 Notification.onshow 处理 show 事件的处理。当通知显示的时候被触发。 Notification.onerror 处理 error 事件的处理。每当通知遇到错误时被触发。 Notification.onclose 处理 close 事件的处理。当用户关闭通知时被触发。 方法静态方法 Notification.requestPermission(callback) 请求用户是否显示通知,传入一个回调函数，回调函数参数的值为denied 和granted 实例方法 Notification.close() 用于手动关闭通知 Notification.addEventListener() 添加事件监听 Notification.removeEventListener() 移除事件监听 EventTarget.DispatchEvent 手动触发事件 案例12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt;window.onload = () =&gt; &#123; showNotify(\"Hello 你好\", &#123; dir: 'auto', lang: 'zh_CN', data: &#123;a: 'ss'&#125;, body: '你的xxx更新了,快去瞧瞧吧！', icon: 'https://developer.mozilla.org/static/img/favicon32.7f3da72dcea1.png' &#125;).then( notifyInstance =&gt; &#123; notifyInstance.onclick = (e) =&gt; &#123; console.log('通知被点击了' + e.target) &#125; notifyInstance.onshow = (e) =&gt; &#123; console.log('通知被显示了' + e.target.data) &#125; notifyInstance.onerror = (e) =&gt; &#123; console.log('通知异常' + e) &#125; notifyInstance.onclose = (e) =&gt; &#123; console.log('通知被关闭' + e) &#125; &#125;)&#125;// 发送通知function showNotify (title, options) &#123; return new Promise((resolve, reject) =&gt; &#123; if (!(\"Notification\" in window)) &#123; reject('Your browser does not support desktop Notification') &#125; if (Notification.permission === 'granted') &#123; // 如果用户已经同意显示通知，直接显示 resolve(new Notification(title, options)) &#125; else if (Notification.permission === 'default') &#123; Notification.requestPermission((permission) =&gt; &#123; if (permission === 'granted') // 用户同意 resolve(new Notification(title, options)) else reject() &#125;) &#125; &#125;) &#125;&lt;/script&gt; 在调试中发现options还可以传入一个参数data,有了这个data属性可以方便我们做点击通知后的处理事件了。不知道为什么MDN中的api并没有说这个参数。MDN文档还有一点就是Notifiction在服务器下的页面才有用,像file:///这样双击打开的是不能弹出通知来的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"}]},{"title":"vue使用jsx","slug":"vue使用jsx","date":"2019-12-14T04:05:31.000Z","updated":"2020-03-14T05:30:42.172Z","comments":true,"path":"2019/12/14/vue使用jsx/","link":"","permalink":"https://haoge744.github.io/2019/12/14/vue%E4%BD%BF%E7%94%A8jsx/","excerpt":"实际上，如果是要编写一些复杂和好用的组件，vue的render会经常出现,例如element的el-tree和el-tabs里面就用到了。有时间想写一些关于element的源码解析的文章，他们的组件写的很出色。之前写过一篇关于vue render函数的相关文章,今天写一篇关于jsx在vue的应用场景及实战。","text":"实际上，如果是要编写一些复杂和好用的组件，vue的render会经常出现,例如element的el-tree和el-tabs里面就用到了。有时间想写一些关于element的源码解析的文章，他们的组件写的很出色。之前写过一篇关于vue render函数的相关文章,今天写一篇关于jsx在vue的应用场景及实战。 使用场景目前vue-cli3.0构建的项目是默认支持jsx语法的，如果是2.x的项目，可能需要调整下.babelrc,jsx的使用场景，目前我知道的只有两个，一个是当组件参数传过去，一个就是写render方法。 例如使用el-tree的时候可以传一个render-content参数来手动渲染，或者其他渲染比较复杂的时候，jsx是扩展性更好的方案。 如果在写render函数的时候,组件、参数比较多的情况下，会发现整个函数写的很长，并且很难维护，这时候使用jsx更加简单直观，并且更利于维护 实际运用参数使用jsx上期我写了一篇文章封装了一个菜单栏，其中有一个参数使用了render函数,接下来把它改为jsx的写法我的上期文章 1234567891011121314151617181920212223export default &#123; data() &#123; return &#123; menuList: [&#123; key: 'home', name: '首页', content_render: (h,item) =&gt; &#123; // console.log(h,item) // return h('span', [ // 使用函数的写法 // h('span', &#123;class: 'el-icon-location'&#125;), // item.name // ]) return &lt;span&gt; &lt;span class=\"el-icon-location\"&gt;&lt;/span&gt; &lt;span&gt;&#123;item.name&#125;&lt;/span&gt; &lt;/span&gt; &#125; // ... ] &#125; &#125;&#125; 实战中使用之前在项目中根据el-table再封装了一下，把分页给封装了进去，并且会自动计算屏幕剩余高度，避免出现屏幕滚动条。这个组件的难点在于如何适配多表头，如果没有多表头的情况下，使用template封装就可以满足,如果要适配多表头,那么要不使用组件递归，要么使用render函数，在函数里面递归，我自然是不想使用组件递归的了，是使用jsx完成了render函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144export default &#123; name: 'dataTable', props: &#123; head: &#123; type: Array, required: true &#125;, tableData: &#123; // 表格数据 type: Array, default: () =&gt; [] &#125;, showNumber: &#123; type: Boolean, default: () =&gt; true &#125;, paging: &#123; // 是否显示分页 type: Boolean, default: () =&gt; true &#125;, pageProps: &#123; type: Object, default: () =&gt; &#123; return &#123; pageNum: 1, pageSize: 10, total: 0&#125; &#125; &#125;, height: &#123; type: String, default: 'auto' &#125; &#125;, data() &#123; return &#123; tableHeight: 500 &#125; &#125;, render(h) &#123; const _this = this // 渲染表格列 function renderCol(cols) &#123; return ( cols.map((item, index) =&gt; &#123; &#123;/* 是否有子节点， 有的话递归渲染 el-table-column组件 */&#125; return !item.hasOwnProperty('children') || item.children.length === 0 ? &lt;el-table-column prop=&#123;item.prop&#125; &#123;/* v-bind=\"item\" 代替成 &#123;...&#123;attrs: item&#125;&#125; */&#125; &#123;...&#123;attrs: item&#125;&#125; label=&#123;item.label || item.prop&#125; &#123;/* 这一点有点复杂 渲染一个作用域插槽，如果列的type属性不为'slot'或者没有传递item.prop的作用域具名插槽那么直接渲染当前表格的值 否则渲染具名作用域插槽 */&#125; scopedSlots = &#123;&#123;default: (scope) =&gt; ( item.type !== 'slot' || !_this.$scopedSlots[item.prop] ? &lt;span&gt;&#123;scope.row[scope.column.property]&#125;&lt;/span&gt; : _this.$scopedSlots[item.prop](&#123; data: scope.row &#125;) ) &#125;&#125; &gt; &lt;/el-table-column&gt; : &#123;/* 渲染多表头 */&#125; &lt;el-table-column align=\"center\" label=&#123;item.label || item.prop&#125;&gt; &#123; renderCol(item.children)&#125; &lt;/el-table-column&gt; &#125;) ) &#125; return ( &lt;div&gt; &lt;el-table height=&#123;this.getTableHeight&#125; ref=\"dataTable\" &#123;...&#123;attrs: this.$attrs&#125;&#125; data=&#123;this.tableData&#125; style=\"width: 100%\" border&gt; &#123; this.showNumber ? &lt;el-table-column type=\"index\" align=\"center\" label=\"序号\" width=\"50\"&gt; &lt;/el-table-column&gt; : '' &#125; &#123; /* 把传过来的head参数用上面定的方法进行渲染 */ renderCol(this.head) &#125; &lt;/el-table&gt; &#123; this.paging ? &lt;el-pagination class=\"pagin-wrapper\" ref=\"pagination\" current-page=&#123;this.pageProps.pageNum&#125; page-size=&#123;this.pageProps.pageSize&#125; total=&#123;this.pageProps.total&#125; pager-count=&#123;5&#125; page-sizes=&#123;[5,10,20,50]&#125; layout=\"total, sizes, prev, pager, next, jumper\" on-size-change=&#123;this.pageSizeChangHandler&#125; on-current-change=&#123;this.pageChangeHandler&#125;/&gt; : '' &#125; &lt;/div&gt; ) &#125;, methods: &#123; pageSizeChangHandler (val) &#123; this.$emit('sizeChanged', val) &#125;, pageChangeHandler (val) &#123; this.$emit('pageChanged', val) &#125;, doLayout () &#123; this.$refs.dataTable.doLayout() &#125;, computedHeight () &#123; if (this.$refs.dataTable.$el) &#123; const top = this.$refs.dataTable.$el.getBoundingClientRect().top const pageHeight = this.paging ? this.$refs.pagination.$el.offsetHeight : 0 this.tableHeight = document.body.clientHeight - top - pageHeight - 48 + 'px' &#125; &#125; &#125;, updated() &#123; this.$nextTick(() =&gt; &#123; this.doLayout() &#125;) &#125;, computed: &#123; getTableHeight() &#123; if (this.height === 'auto') &#123; return this.tableHeight &#125; else if (this.height) &#123; return this.height &#125; else &#123; return null &#125; &#125;, &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this.computedHeight() &#125;) &#125;&#125; 比较难的一部分，在renderCol方法那里，至于jsx绑定数据和绑定事件都是用花括号比较简单。使用组件: 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;!-- ... --&gt; &lt;dataTable :head&#x3D;&quot;head&quot; :tableData&#x3D;&quot;tableData&quot; @sizeChanged&#x3D;&quot;sizeChanged&quot; @pageChanged&#x3D;&quot;pageChanged&quot; :pageProps&#x3D;&quot;pageForm&quot;&gt; &lt;template v-slot:rate&#x3D;&quot;&#123;data&#125;&quot;&gt; &#123;&#123; data.rate ? (data.rate * 100).toFixed(2) + &#39;%&#39; : &#39;-&#39; &#125;&#125; &lt;&#x2F;template&gt; &lt;&#x2F;dataTable&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;ffff&#39;, mixins: [dataTableMixin], components: &#123; dataTable, card &#125;, data() &#123; return &#123; tableData: [], head: [&#123; prop: &#39;name&#39;, label: &#39;xxx&#39;, align: &#39;center&#39;, &#125;, &#123; prop: &#39;rate&#39;, label: &#39;占比&#39;, align: &#39;center&#39;, type: &#39;slot&#39; &#125; ] &#125;&#125;&lt;&#x2F;script&gt; 至此已经对jsx封装组件有一定经验了，以后封装组件更有自己的想法。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"},{"name":"jsx","slug":"jsx","permalink":"https://haoge744.github.io/tags/jsx/"}]},{"title":"vue全局注册filters骚操作","slug":"vue全局注册filters骚操作","date":"2019-12-07T11:22:03.000Z","updated":"2019-12-07T11:22:03.000Z","comments":true,"path":"2019/12/07/vue全局注册filters骚操作/","link":"","permalink":"https://haoge744.github.io/2019/12/07/vue%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8Cfilters%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"注册全局Filters骚操作123456789101112131415161718192021222324252627282930313233// 新建 src/filters/index.jsconst filtersMap = &#123; dateFormatter: function (date, fmtExp) &#123; if (!date) return '-' var date = new Date(date) var o = &#123; \"M+\": date.getMonth() + 1, //月份 \"D+\": date.getDate(), //日 \"h+\": date.getHours(), //小时 \"m+\": date.getMinutes(), //分 \"s+\": date.getSeconds(), //秒 \"q+\": Math.floor((date.getMonth() + 3) / 3), //季度 \"S\": date.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmtExp))&#123; fmtExp = fmtExp.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length)); console.log(fmtExp); &#125; for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmtExp)) fmtExp = fmtExp.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmtExp; &#125;&#125;export default (Vue) =&gt; &#123; for(key in filtersMap) &#123; Vue.filter(key, filtersMap[key]) &#125;&#125;","text":"注册全局Filters骚操作123456789101112131415161718192021222324252627282930313233// 新建 src/filters/index.jsconst filtersMap = &#123; dateFormatter: function (date, fmtExp) &#123; if (!date) return '-' var date = new Date(date) var o = &#123; \"M+\": date.getMonth() + 1, //月份 \"D+\": date.getDate(), //日 \"h+\": date.getHours(), //小时 \"m+\": date.getMinutes(), //分 \"s+\": date.getSeconds(), //秒 \"q+\": Math.floor((date.getMonth() + 3) / 3), //季度 \"S\": date.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmtExp))&#123; fmtExp = fmtExp.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length)); console.log(fmtExp); &#125; for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmtExp)) fmtExp = fmtExp.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmtExp; &#125;&#125;export default (Vue) =&gt; &#123; for(key in filtersMap) &#123; Vue.filter(key, filtersMap[key]) &#125;&#125; 在main.js中使用: 123import Vue from Vueimport filters from './filters'Vue.use(filters) 使用require.context动态注册上面的方法有个缺点就是如果filter方法数量太多的话，js代码会很长，不易于维护，如果多的话也可以用js来划分不同的模块，然后使用webpack的require.contextapi自动导入，而不需要手动的import。首先在filters文件夹下创建modules文件夹然后根据需要创建对应的js文件，比如这样: 里面的js都导出一个对象 index.js写好自动导出的代码: 1234567891011const modules = require.context('./modules', true, /\\.js$/)let filters = modules.keys().reduce((prev, key) =&gt; &#123; return Object.assign(prev,modules(key).default)&#125;, &#123;&#125;)export default (Vue) =&gt; &#123; for(let key in filters) &#123; Vue.filter(key, filters[key]) &#125;&#125; 使用方法直接Vue.use即可 关于require.context()目前了解的不深，不作太多讲解。以后会专门写一篇文章总结它。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue渲染函数render","slug":"vue渲染函数render","date":"2019-12-04T12:24:03.000Z","updated":"2019-12-04T12:24:03.000Z","comments":true,"path":"2019/12/04/vue渲染函数render/","link":"","permalink":"https://haoge744.github.io/2019/12/04/vue%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0render/","excerpt":"Vue Render函数基础render函数即渲染函数，它的的参数为createElement，也是个函数，它的返回值为VNode, render函数必须返回一个VNode对象。 createElement的参数: 标签名、组件选项对象。必填。类型:{String | Object | Function} 为node添加属性的数据对象。非必填。类型:{Object} 子级虚拟节点，由 createElement()构建而成，也可以直接使用字符串。类型: {String | Array} createElement()的返回值是VNode对象，而且render()需要返回的正是VNode对象。","text":"Vue Render函数基础render函数即渲染函数，它的的参数为createElement，也是个函数，它的返回值为VNode, render函数必须返回一个VNode对象。 createElement的参数: 标签名、组件选项对象。必填。类型:{String | Object | Function} 为node添加属性的数据对象。非必填。类型:{Object} 子级虚拟节点，由 createElement()构建而成，也可以直接使用字符串。类型: {String | Array} createElement()的返回值是VNode对象，而且render()需要返回的正是VNode对象。 深入数据对象在模板中我们给组件设置一些参数、响应事件 一般使用的是 v-bind:或者v-on开头的语法,但在render函数中它们都变成了一个个的属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; // 与 `v-bind:class` 的 API 相同， // 接受一个字符串、对象或字符串和对象组成的数组 'class': &#123; foo: true, bar: false &#125;, // 与 `v-bind:style` 的 API 相同， // 接受一个字符串、对象，或对象组成的数组 style: &#123; color: 'red', fontSize: '14px' &#125;, // 普通的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 prop props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器在 `on` 属性内， // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。 // 需要在处理函数中手动检查 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽的格式为 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其它组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其它特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中给多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 官方示例如果封装一个组件，根据传入的level来决定渲染h1~h6的标题元素，那么用模板代码太冗余，尝试使用render函数效果会好很多: 1234567891011121314export default &#123; props: &#123; level: &#123; type: Number, default: () =&gt; 1 &#125; &#125;, render (h) &#123; return h( 'h'+ this.level, // 标签名称 this.$slots.default // 子节点数据 ) &#125;&#125; 实际运用比如我们要在element-ui基础上封装一个导航组件，根据传入的菜单数据生成菜单像这样: 如果说没有子菜单还好，有子菜单的话就必须要拆成两个组件了，然后递归循环了，可是我并不像那样，这个时候使用render函数就可以避免。 直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 新建 /components/navMenu/index.jsexport default &#123; name: 'navMenu', props: &#123; menuList: &#123; type: Array, required: true &#125; &#125;, created() &#123; &#125;, render (h) &#123; const _this = this // 渲染子菜单的方法 function renderSubItem(list, h) &#123; return list.map(item =&gt; &#123; // 判断有没有children属性 如果没有直接渲染el-menu-item组件 if (!item.hasOwnProperty('children') || item.children.length === 0) &#123; return h('el-menu-item', &#123; props: &#123; index: item.key, ...item &#125;, key: item.key &#125;, item.name ) &#125; else &#123; // 有子节点的情况渲染el-submenu节点 并且给一个具名插值'title' return h('el-submenu', &#123; props: &#123; index: item.key, ...item // 属性扩展符可以把属性自动设置成组件的参数 &#125;, key: item.key &#125;, [ h('template', &#123; slot: 'title' &#125;,item.name), // 递归渲染子节点 ...renderSubItem(item.children, h) ] ) &#125; &#125;) &#125; // 首先渲染外部的el-menu节点 参数和事件使用$attrs和$listeners传递 return h('el-menu', &#123; props: &#123; ...this.$attrs &#125;, on: &#123; ...this.$listeners &#125; &#125;, [ ...renderSubItem(this.menuList, h) ]) &#125;&#125; 使用: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;navMenu background-color&#x3D;&quot;#545c64&quot; text-color&#x3D;&quot;#fff&quot; active-text-color&#x3D;&quot;#ffd04b&quot; mode&#x3D;&quot;horizontal&quot; :menuList&#x3D;&quot;menuList&quot;&gt;&lt;&#x2F;navMenu&gt;&lt;&#x2F;template&gt;&lt;script&gt;import navMenu from &#39;@&#x2F;components&#x2F;navMenu&#x2F;index.js&#39;export default &#123; name: &#39;home&#39;, components: &#123; navMenu &#125;, data() &#123; return &#123; menuList: [&#123; key: &#39;home&#39;, name: &#39;首页&#39;, content_render: (h,item) &#x3D;&gt; &#123; &#x2F;&#x2F; console.log(h,item) return &lt;span&gt;&#123;item.name&#125;&lt;&#x2F;span&gt; &#125;, &#125;,&#123; key: &#39;categories&#39;, name: &#39;web前端&#39;, children: [&#123; key: &#39;book&#39;, name: &#39;书籍&#39;, &#125;,&#123; key: &#39;tools&#39;, name: &#39;工具&#39;, &#125;,&#123; key: &#39;javascript&#39;, name: &#39;javascript&#39;, &#125;,&#123; key: &#39;vue&#39;, name: &#39;vue&#39;, &#125;,&#123; key: &#39;css&#39;, name: &#39;css&#39;, children: [&#123; key: &#39;css3&#39;, name: &#39;css3&#39;, &#125;,&#123; key: &#39;stylus&#39;, name: &#39;stylus&#39;, &#125;,&#123; key: &#39;scss&#39;, name: &#39;scss&#39;, &#125;] &#125;] &#125;,&#123; key: &#39;dashboard&#39;, name: &#39;控制面板&#39;, children: [&#123; key: &#39;ip&#39;, name: &#39;域名管理&#39; &#125;,&#123; key: &#39;server&#39;, name: &#39;服务器管理&#39; &#125;] &#125;,&#123; key: &#39;about&#39;, name: &#39;关于&#39; &#125;] &#125; &#125;&#125;&lt;&#x2F;script&gt; 使用效果: 还是有点瑕疵，菜单没有图标，我理想的状态是能够使用插槽并且设置图标。所以需要把这个功能加上。我的想法是每个菜单item可以提供一个content_render方法，这个方法的参数为(h,item)，这个方法的返回值需要为VNode。这样就可以实现相同的效果辣。 修改一下renderSubItem()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function renderSubItem(list, h) &#123; return list.map(item =&gt; &#123; if (item.hasOwnProperty('content_render') &amp;&amp; item.content_render) &#123; console.log(item.content_render(h,item)) &#125; if (!item.hasOwnProperty('children') || item.children.length === 0) &#123; return h('el-menu-item', &#123; props: &#123; index: item.key, ...item &#125;, key: item.key &#125;, // 使用三目运算符判断菜单项是否有渲染函数 [item.content_render ? h('template', &#123; slot: 'title', &#125;, [item.content_render(h,item)]) : h('template', &#123; slot: 'title', &#125;, [item.name]) ] ) &#125; else &#123; return h('el-submenu', &#123; props: &#123; index: item.key, ...item &#125;, key: item.key &#125;, [ // 使用三目运算符判断菜单项是否有渲染函数 item.content_render ? h('template', &#123; slot: 'title', &#125;, [item.content_render(h,item)]) : h('template', &#123; slot: 'title', &#125;, [item.name]), ...renderSubItem(item.children, h) ] ) &#125; &#125;) &#125; 然后修改data中绑定的值: 123456789101112131415161718export default &#123; data() &#123; return &#123; menuList: [&#123; key: 'home', name: '首页', content_render: (h,item) =&gt; &#123; // console.log(h,item) return h('span', [ h('span', &#123;class: 'el-icon-location'&#125;), item.name ]) &#125; // ... ] &#125; &#125;&#125; 效果: 如果觉得上面content_render写法太复杂也可以改成下面jsx的方法实现: 12345678content_render: (h, item) =&gt; &#123; return ( &lt;span&gt; &lt;span class=\"el-icon-location\"&gt;&lt;/span&gt; &lt;span&gt;&#123;item.name&#125;&lt;/span&gt; &lt;/span&gt; )&#125; 修改完后的效果和上图是一致的。 实际上上面的navMenu组件也可以使用jsx来重构，使用jsx的话代码更简洁和易维护一点，但是有关在vue中使用jsx的内容太多，打算再另外写一篇文章进行总结。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue插件总结","slug":"vue插件总结","date":"2019-11-30T15:40:44.000Z","updated":"2019-11-30T15:40:44.000Z","comments":true,"path":"2019/11/30/vue插件总结/","link":"","permalink":"https://haoge744.github.io/2019/11/30/vue%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93/","excerpt":"Vue三方插件集合前几天在网上看到一个vue插件列表，觉得还不错分享一下。找不到插件的时候可以回来看下哦。","text":"Vue三方插件集合前几天在网上看到一个vue插件列表，觉得还不错分享一下。找不到插件的时候可以回来看下哦。 UI件框架 element - 饿了么出品的Vue2的web UI工具套件 mint-ui - Vue 2的移动UI元素 iview - 基于 Vuejs 的开源 UI 组件库 Keen-UI - 轻量级的基本UI组件合集 vue-material - 通过Vue Material和Vue 2建立精美的app应用 muse-ui - 三端样式一致的响应式 UI 库 vuetify - 为移动而生的Vue JS 2组件框架 vonic - 快速构建移动端单页应用 vue-blu - 帮助你轻松创建web应用 vue-multiselect - Vue.js选择框解决方案 VueCircleMenu - 漂亮的vue圆环菜单 vue-chat - vuejs和vuex及webpack的聊天示例 radon-ui - 快速开发产品的Vue组件库 vue-waterfall - Vue.js的瀑布布局组件 vue-carbon - 基于 vue 开发MD风格的移动端 vue-beauty - 由vue和ant design创建的优美UI组件 bootstrap-vue - 应用于Vuejs2的Twitter的Bootstrap 4组件 vueAdmin - 基于vuejs2和element的简单的管理员模板 vue-ztree - 用 vue 写的树层级组件 vue-tree - vue树视图组件 vue-tabs - 多tab页轻型框架 编辑器 markcook - 好看的markdown编辑器 eme - 优雅的Markdown编辑器 vue-syntax-highlight - Sublime Text语法高亮 vue-quill-editor - 基于Quill适用于Vue2的富文本编辑器 Vueditor - 所见即所得的编辑器 vue-html5-editor - html5所见即所得编辑器 vue2-editor - HTML编辑器 vue-simplemde - VueJS的Markdown编辑器组件 vue-quill - vue组件构建quill编辑器 slider vue-awesome-swiper - vue.js触摸滑动组件 vue-slick - 实现流畅轮播框的vue组件 vue-swipe - VueJS触摸滑块 vue-swiper - 易于使用的滑块组件 vue-images - 显示一组图片的lightbox组件 vue-carousel-3d - VueJS的3D轮播组件 vue-slide - vue轻量级滑动组件 vue-slider - vue 滑动组件 vue-m-carousel - vue 移动端轮播组件 dd-vue-component - 订单来了的公共组件库 vue-easy-slider - Vue 2.x的滑块组件 图表 vue-table - 简化数据表格 vue-chartjs - vue中的Chartjs的封装 vue-charts - 轻松渲染一个图表 vue-chart - 强大的高速的vue图表解析 vue-highcharts - HighCharts组件 chartjs - Vue Bulma的chartjs组件 vue-chartkick - VueJS一行代码实现优美图表 日历 vue-calendar - 日期选择插件 vue-datepicker - 日历和日期选择组件 vue-datetime-picker - 日期时间选择控件 vue2-calendar - 支持lunar和日期事件的日期选择器 vue-fullcalendar - 基于vue.js的全日历组件 vue-datepicker - 漂亮的Vue日期选择器组件 datepicker - 基于flatpickr的时间选择组件 vue2-timepicker - 下拉时间选择器 vue-date-picker - VueJS日期选择器组件 vue-datepicker-simple - 基于vue的日期选择器 地址选择 vue-city - 城市选择器 vue-region-picker - 选择中国的省份市和地区 地图 vue-amap - 基于Vue 2和高德地图的地图组件 vue-google-maps - 带有双向数据绑定Google地图组件 vue-baidu-map- 基于 Vue 2的百度地图组件库 vue-cmap - Vue China map可视化组件 播放器 vue-video-player - VueJS视频及直播播放器 vue-video - Vue.js的HTML5视频播放器 vue-music-master - vue手机端网页音乐播放器 滚动scroll vue-scroller - Vonic UI的功能性组件 vue-mugen-scroll - 无限滚动组件 vue-infinite-loading - VueJS的无限滚动插件 vue-virtual-scroller - 带任意数目数据的顺畅的滚动 vue-infinite-scroll - VueJS的无限滚动指令 vue-scrollbar - 最简单的滚动区域组件 vue-scroll - vue滚动 vue-pull-to-refresh - Vue2的上拉下拉 mint-loadmore - VueJS的双向下拉刷新组件 vue-smoothscroll - smoothscroll的VueJS版本 文件上传 vue-upload-component - Vuejs文件上传组件 vue-core-image-upload - 轻量级的vue上传插件 vue-dropzone - 用于文件上传的Vue组件 图片处理 vue-lazyload-img - 移动优化的vue图片懒加载插件 vue-image-crop-upload - vue图片剪裁上传组件 vue-svgicon - 创建svg图标组件的工具 vue-img-loader - 图片加载UI组件 vue-image-clip- 基于vue的图像剪辑组件 vue-progressive-image - Vue的渐进图像加载插件 提示 vue-toast-mobile - VueJS的toast插件 vue-msgbox - vuejs的消息框 vue-tooltip - 带绑定信息提示的提示工具 vue-verify-pop - 带气泡提示的vue校验插件 进度条 vue-radial-progress - Vue.js放射性进度条组件 vue-progressbar - vue轻量级进度条 vue2-loading-bar - 最简单的仿Youtube加载条视图 其他 vue-dragging- 使元素可以拖拽 Vue.Draggable- 实现拖放和视图模型数组同步 vue-picture-input- 移动友好的图片文件输入组件 rubik- 基于Vuejs2的开源 UI 组件库 VueStar- 带星星动画的vue点赞按钮 vue-tables-2- 显示数据的bootstrap样式网格 DataVisualization- 数据可视化 vue-drag-and-drop-list- 创建排序列表的Vue指令 vuwe- 基于微信WeUI所开发的专用于Vue2的组件库 vue-typer- 模拟用户输入选择和删除文本的Vue组件 vue-impression- 移动Vuejs2 UI元素 vue-datatable- 使用Vuejs创建的DataTableView vue-instant- 轻松创建自动提示的自定义搜索控件 vue-slider-component- 在vue1和vue2中使用滑块 vue-touch-ripple- vuejs的触摸ripple组件 coffeebreak- 实时编辑CSS组件工具 vue-datasource- 创建VueJS动态表格 handsontable- 网页表格组件 vue-bootstrap-table- 可排序可检索的表格 vue-google-signin-button- 导入谷歌登录按钮 vue-float-label- VueJS浮动标签模式 vue-tagsinput- 基于VueJS的标签组件 vue-social-sharing- 社交分享组件 vue-popup-mixin- 用于管理弹出框的遮盖层 cubeex- 包含一套完整的移动UI vue-fullcalendar- vue FullCalendar封装 vue-material-design- Vue MD风格组件 vue-morris- Vuejs组件封装Morrisjs库 we-vue- Vue2及weui1开发的组件 vue-form-2- 全面的HTML表单管理的解决方案 vue-side-nav- 响应式的侧边导航 mint-indicator- VueJS移动加载指示器插件 vue-ripple- 制作谷歌MD风格涟漪效果的Vue组件 vue-touch-keyboard- VueJS虚拟键盘组件 vue-parallax- 整洁的视觉效果 vue-typewriter- vue组件类型 vue-ios-alertview- iOS7+ 风格的alertview服务 paco-ui-vue- PACOUI的vue组件 vue-button- Vue按钮组件 开发框架 vue.js - 流行的轻量高效的前端组件化方案 vue-admin - Vue管理面板框架 electron-vue - Electron及VueJS快速启动样板 vue-2.0-boilerplate - Vue2单页应用样板 vue-webgulp - 仿VueJS Vue loader示例 vue-bulma - 轻量级高性能MVVM Admin UI框架 vue-spa-template - 前后端分离后的单页应用开发 Framework7-Vue - VueJS与Framework7结合 vue-element-starter - vue启动页 实用库 vuelidate - 简单轻量级的基于模块的Vue.js验证 qingcheng - qingcheng主题 vuex - 专为 Vue.js 应用程序开发的状态管理模式 vue-axios - 将axios整合到VueJS的封装 vue-desktop - 创建管理面板网站的UI库 vue-meta - 管理app的meta信息 avoriaz - VueJS测试实用工具库 vue-framework7 - 结合VueJS使用的Framework7组件 vue-lazy-render - 用于Vue组件的延迟渲染 vue-svg-icon - vue2的可变彩色svg图标方案 vue-online - reactive的在线和离线组件 vue-password-strength-meter - 交互式密码强度计 vuep - 用实时编辑和预览来渲染Vue组件 vue-bootstrap-modal - vue的Bootstrap样式组件 element-admin - 支持 vuecli 的 Element UI 的后台模板 vue-shortkey - 应用于Vue.js的Vue-ShortKey 插件 cleave - 基于cleave.js的Cleave组件 vue-events - 简化事件的VueJS插件 http-vue-loader - 从html及js环境加载vue文件 vue-electron - 将选择的API封装到Vue对象中的插件 vue-router-transition - 页面过渡插件 vuemit - 处理VueJS事件 vue-cordova - Cordova的VueJS插件 vue-qart - 用于qartjs的Vue2指令 vue-websocket - VueJS的Websocket插件 vue-gesture - VueJS的手势事件插件 vue-local-storage - 具有类型支持的Vuejs本地储存插件 lazy-vue - 懒加载图片 vue-lazyloadImg - 图片懒加载插件 vue-bus - VueJS的事件总线 vue-observe-visibility - 当元素在页面上可见或隐藏时检测 vue-notifications - 非阻塞通知库 v-media-query - vue中添加用于配合媒体查询的方法 vuex-shared-mutations - 分享某种Vuex mutations vue-lazy-component - 懒加载组件或者元素的Vue指令 vue-reactive-storage - vue插件的Reactive层 vue-ts-loader - 在Vue装载机检查脚本 vue-pagination-2 - 简单通用的分页组件 vuex-i18n - 定位插件 Vue.resize - 检测HTML调整大小事件的vue指令 vue-zoombox - 一个高级zoombox leo-vue-validator - 异步的表单验证组件 modal - Vue Bulma的modal组件 Famous-Vue - Famous库的vue组件 vue-input-autosize - 基于内容自动调整文本输入的大小 vue-file-base64 - 将文件转换为Base64的vue组件 Vue-Easy-Validator - 简单的表单验证 vue-truncate-filter - 截断字符串的VueJS过滤器 服务端 vue-ssr - 结合Express使用Vue2服务端渲染 nuxt.js - 用于服务器渲染Vue app的最小化框架 vue-ssr - 非常简单的VueJS服务器端渲染模板 vue-easy-renderer - Nodejs服务端渲染 express-vue - 简单的使用服务器端渲染vue.js 辅助工具 DejaVue - Vuejs可视化及压力测试 vue-generate-component - 轻松生成Vue js组件的CLI工具 vscode-VueHelper - 目前vscode最好的vue代码提示插件 vue-play - 展示Vue组件的最小化框架 VuejsStarterKit - vuejs starter套件 vue-multipage-cli - 简单的多页CLI 应用实例 pagekit - 轻量级的CMS建站系统 vuedo - 博客平台 koel - 基于网络的个人音频流媒体服务 CMS-of-Blog - 博客内容管理器 vue-cnode - 重写vue版cnode社区 vue-ghpages-blog - 依赖GitHub Pages无需本地生成的静态博客 swoole-vue-webim - Web版的聊天应用 fewords - 功能极其简单的笔记本 jackblog-vue - 个人博客系统 vue-blog - 使用Vue2.0 和Vuex的vue-blog vue-dashing-js - nuvo-dashing-js的fork rss-reader - 简单的rss阅读器 Demo示例 eleme - 高仿饿了么app商家详情 NeteaseCloudWebApp - 高仿网易云音乐的webapp vue-zhihu-daily - 知乎日报 with Vuejs Vue-cnodejs - 基于vue重写Cnodejs.org的webapp vue2-demo - 从零构建vue2 + vue-router + vuex 开发环境 vue-wechat - vue.js开发微信app界面 vue-music - Vue 音乐搜索播放 maizuo - vue/vuex/redux仿卖座网 vue-demo - vue简易留言板 spa-starter-kit - 单页应用启动套件 zhihudaily-vue - 知乎日报web版 douban - 模仿豆瓣前端 vue-Meizi - vue最新实战项目 vue-demo-kugou - vuejs仿写酷狗音乐webapp vue2.0-taopiaopiao - vue2.0与express构建淘票票页面 node-vue-server-webpack - Node.js+Vue.js+webpack快速开发框架 VueDemo_Sell_Eleme - Vue2高仿饿了么外卖平台 vue-leancloud-blog - 一个前后端完全分离的单页应用 vue-fis3 - 流行开源工具集成demo mi-by-vue - VueJS仿小米官网 vue-demo-maizuo - 使用Vue2全家桶仿制卖座电影 vue2.x-douban - Vue2实现简易豆瓣电影webApp vue-adminLte-vue-router - vue和adminLte整合应用 vue-zhihudaily - 知乎日报 Web 版本 Zhihu-Daily-Vue.js - Vuejs单页网页应用 vue-axios-github - 登录拦截登出功能 vue2.x-Cnode - 基于vue全家桶的Cnode社区 hello-vue-django - 使用带有Django的vuejs的样板项目 websocket_chat - 基于vue和websocket的多人在线聊天室 x-blog - 开源的个人blog项目 vue-cnode - vue单页应用demo vue-express-mongodb - 简单的前后端分离案例 photoShare - 基于图片分享的社交平台 notepad - 本地存储的记事本 vue-zhihudaily-2.0 - 使用Vue2.0+vue-router+vuex创建的zhihudaily vueBlog - 前后端分离博客 Zhihu_Daily - 基于Vue和Nodejs的Web单页应用 vue-ruby-china - VueJS框架搭建的rubychina平台 vue-koa-demo - 使用Vue2和Koa1的全栈demo life-app-vue - 使用vue2完成多功能集合到小webapp vue-trip - vue2做的出行webapp github-explorer - 寻找最有趣的GitHub库 vue-ssr-boilerplate - 精简版的ofvue-hackernews-2 vue-bushishiren - 不是诗人应用 houtai - 基于vue和Element的后台管理系统 ios7-vue - 使用vue2.0 vue-router vuex模拟ios7 Framework7-VueJS - 使用移动框架的示例 cnode-vue - 基于vue和vue-router构建的cnodejs web网站SPA vue-cli-multipage-bootstrap - 将vue官方在线示例整合到组件中 vue-cnode - 用 Vue 做的 CNode 官网 seeMusic - 跨平台云音乐播放器 HyaReader - 移动友好的阅读器 zhihu-daily - 轻松查看知乎日报内容 vue-cnode - 使用cNode社区提供的接口 zhihu-daily-vue - 知乎日报 vue-dropload - 用以测试下拉加载与简单路由 vue-cnode-mobile - 搭建cnode社区 Vuejs-SalePlatform - vuejs搭建的售卖平台demo vue-memo - 用 vue写的记事本应用 sls-vuex2-demo - vuex2商城购物车demo v-notes - 简单美观的记事本 vue-starter - VueJs项目的简单启动页 原文地址: http://www.javanx.cn/20180720/vue-plug/","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"Typescript的类型断言","slug":"Typescript的类型断言","date":"2019-11-29T11:19:45.000Z","updated":"2020-11-29T11:24:40.537Z","comments":true,"path":"2019/11/29/Typescript的类型断言/","link":"","permalink":"https://haoge744.github.io/2019/11/29/Typescript%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/","excerpt":"ts类型断言写给自己看的类型断言笔记。。 之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：","text":"ts类型断言写给自己看的类型断言笔记。。 之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法： 123456789101112131415interface Cat &#123; name: string; run(): void;&#125;interface Fish&#123; name: string; swim: void;&#125;function isFish(animal: Cat|Fish) &#123; if(typeof animal.swim === 'function')&#123; return true; &#125; return false;&#125; 此时可以使用类型断言，将animal断言成Fish 123456function isFish(animal: Cat|Fish)&#123; if((animal as Fish).swim === 'function')&#123; return true; &#125; return false;&#125; 需要注意的是，类型断言只能够欺骗ts编译器,无法避免运行时的错误，所以滥用类型断言可能会导致运行时错误: 12345678910111213141516171819interface Cat &#123; name: string; run(): void;&#125;interface Fish&#123; name: string; swim: void;&#125;function swim(animal: Cat|Fish)&#123; (animal as Fish).swim()&#125;const tom:Cat=&#123; name: 'tom', run() &#123;console.log('tom run')&#125;&#125;swim(tom); // Uncaught TypeError: animal.swim is not a function` 将任意一个类型断言成any理想情况下，Typescript的类型系统运转良好，每个值的类型都具体而精确。当我们引用一个在此类型上不存在的属性或方法时，就会报错: 123const foo: number = 1;foo.length = 1;// index.ts:2:5 - error TS2339: Property 'length' does not exist on type 'number'. 这种错误提示显然是非常有用的。 但有的时候，我们非常确定这段代码不会出错，比如下面这个例子： 123window.foo = 1;// index.ts:1:8 - error TS2339: Property 'foo' does not exist on type 'Window &amp; typeof globalThis'. 上面的例子中，我们需要将 window 上添加一个属性 foo，但 TypeScript 编译时会报错，提示我们 window 上不存在 foo 属性。 此时我们可以使用 as any 临时将 window 断言为 any 类型： 1(window as any).foo = 1; 在 any 类型的变量上，访问任何属性都是允许的。 需要注意的是，将一个变量断言为 any 可以说是解决 TypeScript 中类型问题的最后一个手段。 它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 as any。 将 any 断言为一个具体的类型在日常的开发中，我们不可避免的需要处理 any 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。 遇到 any 类型的变量时，我们可以选择无视它，任由它滋生更多的 any。 我们也可以选择改进它，通过类型断言及时的把 any 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。 举例来说，历史遗留的代码中有个 getCacheData，它的返回值是 any： 123function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125; 那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作： 12345678910function getCacheData(key: string): any&#123; return (window as any).cache[key]&#125;interface Cat&#123; name:string; run():void;&#125;const tom = getCacheData('tom') as Cattom.run() 上面的例子中，我们调用完 getCacheData 之后，立即将它断言为 Cat 类型。这样的话明确了 tom 的类型，后续对 tom 的访问时就有了代码补全，提高了代码的可维护性。 类型断言的限制是不是任何一个类型都可以被断言成任何的另一个类型呢？答案是否定的——并不是任务一个类型都可以被断言成任何另一个类型 12345678910interface Cat &#123; run(): void;&#125;interface Fish &#123; swim(): void;&#125;return testCat(cat: cat) &#123; return (cat as Fish) // error 两个接口无相同属性互不兼容&#125; 双重断言既然： 任何类型都可以被断言为 any any 可以被断言为任何类型 那么我们是不是可以使用双重断言 as any as Foo 来将任何一个类型断言为任何另一个类型呢？ 12345678910interface Cat &#123; run(): void;&#125;interface Fish &#123; swim(): void;&#125;function testCat(cat: Cat) &#123; return (cat as any as Fish);&#125; 在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容。 但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。 若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。 除非迫不得已，千万别用双重断言。 类型断言 vs 类型声明在这个例子中： 1234567891011function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData('tom') as Cat;tom.run(); 我们使用 as Cat 将 any 类型断言为了 Cat 类型。 但实际上还有其他方式可以解决这个问题： 1234567891011function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom: Cat = getCacheData('tom');tom.run(); 上面的例子中，我们通过类型声明的方式，将 tom 声明为 Cat，然后再将 any 类型的 getCacheData(&#39;tom&#39;) 赋值给 Cat 类型的 tom。 这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom 在接下来的代码中都变成了 Cat 类型。 类型断言 vs 类型声明1234567891011121314interface Animal &#123; name: string;&#125;interface Cat &#123; name: string; run(): void;&#125;const tom: Cat = &#123; name: '123', run: () =&gt; &#123;&#125;&#125;const a1: Animal = tom; // okconst tom2: Cat = a1; // errorconst tom3: Cat = a1 as Animal; // error 这很容易理解，Animal 可以看作是 Cat 的父类，当然不能将父类的实例赋值给类型为子类的变量。有点和面向对象中多态的思想一样。 类型断言 vs 泛型还是这个例子： 1234567891011function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData('tom') as Cat;tom.run(); 我们还有第三种方式可以解决这个问题，那就是泛型： 1234567891011function getCacheData&lt;T&gt;(key: string): T &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData&lt;Cat&gt;('tom');tom.run(); 通过给 getCacheData 函数添加了一个泛型 &lt;T&gt;，我们可以更加规范的实现对 getCacheData 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。","categories":[{"name":"typescript","slug":"typescript","permalink":"https://haoge744.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://haoge744.github.io/tags/typescript/"}]},{"title":"vue中name的作用","slug":"vue中name的作用","date":"2019-11-23T14:43:39.000Z","updated":"2019-11-23T14:43:39.000Z","comments":true,"path":"2019/11/23/vue中name的作用/","link":"","permalink":"https://haoge744.github.io/2019/11/23/vue%E4%B8%ADname%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"我们在写vue项目的时候会遇到给组件命名。 123export default &#123; name: 'xxx'&#125; 这里的name非必选项，看起来好像没啥用处，但是实际上这里用处还挺多的","text":"我们在写vue项目的时候会遇到给组件命名。 123export default &#123; name: 'xxx'&#125; 这里的name非必选项，看起来好像没啥用处，但是实际上这里用处还挺多的 当项目需要使用keep-alive时，可以进行缓存过滤使用keep-alive组件时,它的includes和exclude属性中使用的正是component的name 做递归组件时使用，比如当我们需要做层级菜单的时候，递归时需要用到name属性list.vue: 12345678910111213141516171819&lt;div&gt; &lt;div v-for&#x3D;&quot;(item,index) of list&quot; :key&#x3D;&quot;index&quot;&gt; &lt;div&gt; &lt;span class&#x3D;&quot;item-title-icon&quot;&gt;&lt;&#x2F;span&gt; &#123;&#123;item.title&#125;&#125; &lt;&#x2F;div&gt; &lt;div v-if&#x3D;&quot;item.children&quot; &gt; &lt;detail-list :list&#x3D;&quot;item.children&quot;&gt;&lt;&#x2F;detail-list&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;script&gt;export default &#123; name:&#39;DetailList&#39;,&#x2F;&#x2F;递归组件是指组件自身调用自身 props:&#123; list:Array &#125;&#125;&lt;&#x2F;script&gt; list数据: 1234567891011121314151617const list = [&#123; \"title\": \"A\", \"children\": [&#123; \"title\": \"A-A\", \"children\": [&#123; \"title\": \"A-A-A\" &#125;] &#125;,&#123; \"title\": \"A-B\" &#125;] &#125;, &#123; \"title\": \"B\" &#125;, &#123; \"title\": \"C\" &#125;, &#123; \"title\": \"D\" &#125;] 使用vue-tools调试工具时，里面的组件标签显示的就是vue的name属性 事件传递时可以用到研究element源码的时候发现有一个mixins/emitter文件，里面写了如何向上和向下的组件传递事件(不限层级)，当然他这里为了避免冲突没有用到name而是componentName,但是是差不多的。mixins/emitter.js 1234567891011121314151617181920212223242526272829303132function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; const name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat([params])); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; let parent = this.$parent || this.$root; let name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue使用mixins提升开发效率","slug":"vue使用mixins提升开发效率","date":"2019-11-12T14:25:09.000Z","updated":"2019-11-12T15:16:22.203Z","comments":true,"path":"2019/11/12/vue使用mixins提升开发效率/","link":"","permalink":"https://haoge744.github.io/2019/11/12/vue%E4%BD%BF%E7%94%A8mixins%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/","excerpt":"混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。","text":"混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。 在开发一些后台系统的时候，像这样的界面随处可见，那么能不能把其中相同的逻辑抽离出来来节省开发效率呢。vue给我们提供了mixins这样的一个混合工具，让我们可以抽离出一部分代码来进行”合并”。 大多数的列表界面都是类似的，不同的地方可能是功能以及数据的列不一样。所以可以把列表的查询条件，查询方法，分页等数据做一个mixins。 开始使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 新建 ListMixins.js// 请求后台的方法，传递url和查询参数即可返回列表值，需要后台统一查询接口import &#123; queryListData &#125; from \"@/api/dataTable\";export default &#123; data () &#123; _url: '', // 请求数据的url list: [], // 数据列表 page: &#123; // 分页参数 pageNum: 1, pageSize: 10, total: 0 &#125;, loading: false, // 加载状态 &#125;, methods: &#123; del() &#123; // 删除提示也可以抽出来，在实际的组件中覆盖 doDelete方法就行了 this.$confirm('是否确认删除?', '提示', &#123; confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' &#125;).then(() =&gt; &#123; this.doDelete() &#125;) &#125;, getQueryParam() &#123; // 获取查询参数 默认是查询条件和分页混合在一起 如果有额外的需求自行添加 return &#123;...this.query, ...this.page &#125; &#125;, queryListData() &#123; // 加载列表数据 const param = this.getQueryParam() // 获取上面定义的参数 return new Promise((resolve, reject) =&gt; &#123; this.loading = true // 设置loading initData(this._url, param).then(res =&gt; &#123; this.loading = false this.page.total = res.data.total // 设置总数 resolve(res.data.list) &#125;).catch(error =&gt; &#123; this.loading = false reject(error) &#125;) &#125;) &#125;, init () &#123;&#125; &#125;, created () &#123; // 初始化函数， 需要在里面做url和数据的处理 this.init() &#125; &#125;&#125; 组件中使用: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div&gt; &lt;!-- 查询部分 --&gt; &lt;div&gt; &lt;el-form :inline&#x3D;&quot;true&quot; size&#x3D;&quot;small&quot; :model&#x3D;&quot;query&quot; class&#x3D;&quot;demo-form-inline&quot;&gt; &lt;el-form-item label&#x3D;&quot;名称&quot;&gt; &lt;el-input v-model&#x3D;&quot;query.name&quot; placeholder&#x3D;&quot;请输入关键字&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item label&#x3D;&quot;电话&quot;&gt; &lt;el-input v-model&#x3D;&quot;query.phone&quot; placeholder&#x3D;&quot;请输入关键字&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-button @click&#x3D;&quot;queryData&quot;&gt;查询&lt;&#x2F;el-button&gt; &lt;&#x2F;el-form&gt; &lt;div class&#x3D;&quot;pull-right&quot;&gt; &lt;el-button type&#x3D;&quot;default&quot;&gt;新增&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;default&quot; @click&#x3D;&quot;edit&quot;&gt;编辑&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;default&quot; @click&#x3D;&quot;del&quot;&gt;删除&lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;!-- 列表部分 --&gt; &lt;el-table :data&#x3D;&quot;list&quot;&gt; &lt;el-table-column label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;name&quot; align&#x3D;&quot;center&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column label&#x3D;&quot;电话&quot; prop&#x3D;&quot;name&quot; align&#x3D;&quot;center&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;&#x2F;el-table&gt; &lt;el-pagination style&#x3D;&quot;text-align: center;&quot; :current-page.sync&#x3D;&quot;page.pageNum&quot; :page-size.sync&#x3D;&quot;page.pageSize&quot; :total&#x3D;&quot;page.total&quot; :page-sizes&#x3D;&quot;[10,20,50]&quot; layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot; @size-change&#x3D;&quot;queryData&quot; @current-change&#x3D;&quot;queryData&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; import ListMixin from &#39;..&#x2F;mixins&#x2F;ListMixins&#39; export default &#123; mixins: [ListMixin], methods: &#123; init () &#123; this._url &#x3D; &#39;xxx&#x2F;xxx&#x2F;query&#39; &#x2F;&#x2F; 覆盖查询的url this.queryData() &#125;, doDelete () &#123; &#x2F;&#x2F; 调用删除接口 &#125;, queryData () &#123; this.queryListData().then(res &#x3D;&gt; &#123; this.list &#x3D; res &#125;) &#125; &#125; &#125;&lt;&#x2F;script&gt; 我这里用的是element-ui，关于el-table和el-pagination的可以自己再封装，这里不演示了，只演示mixins的相关内容。 总结封装好mixins后使用既方便了开发，维护起来也方便了很多，比如说我的默认页要调整到20页，我该一行代码就可以了，关键是把真正项目中公用的地方抽离出来，这个要考虑好。 虽然mixins好用，但是也不是没有缺点，如果说你一个组件引入的mixins过多，那么容易产生我这个数据或方法不知道从哪来的，会产生不确定性。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue3.0之vue-composition-api尝鲜","slug":"vue3-0之vue-composition-api尝鲜","date":"2019-11-05T15:30:34.000Z","updated":"2019-11-10T04:14:00.685Z","comments":true,"path":"2019/11/05/vue3-0之vue-composition-api尝鲜/","link":"","permalink":"https://haoge744.github.io/2019/11/05/vue3-0%E4%B9%8Bvue-composition-api%E5%B0%9D%E9%B2%9C/","excerpt":"简介根据vue作者尤雨溪去年发布的vue3.0开发路线，vue3.0很可能会在2019年下半年推出。 此前vue官方也提供过了vue3.0特性的尝鲜版本，叫做vue-function-api,此后推出的最新版本为vue-composition-api,之前的vue-function-api已经淘汰了不再推荐学习了。 虽然vue3.0还没有正式发布，但是已经可以安装composition-api插件来体验了。 本篇文章将介绍composition-api基础使用以及最重要的一些新特性,例如setup()函数、reactive()、ref()等这些Vue Hooks。","text":"简介根据vue作者尤雨溪去年发布的vue3.0开发路线，vue3.0很可能会在2019年下半年推出。 此前vue官方也提供过了vue3.0特性的尝鲜版本，叫做vue-function-api,此后推出的最新版本为vue-composition-api,之前的vue-function-api已经淘汰了不再推荐学习了。 虽然vue3.0还没有正式发布，但是已经可以安装composition-api插件来体验了。 本篇文章将介绍composition-api基础使用以及最重要的一些新特性,例如setup()函数、reactive()、ref()等这些Vue Hooks。 安装 安装@vue/cli3 1npm install -g @vue&#x2F;cli 创建项目 1vue create my-project 安装composition-api 1npm install @vue/composition-api --save 使用 12345// 在main.js使用import Vue from 'vue'import VueCompositionApi from '@vue/composition-api'Vue.use(VueCompositionapi) 使用setup函数setup函数是vue3中，专门为组件提供的新属性，它为我们使用vue3的Composition API 提供了同意的入口 生命周期: setup会在beforeCreate之后，created之前执行。 1234567891011// comp1.vueexport default&#123; props: &#123; title: String &#125;, setup(props, ctx) &#123; console.log(props.title) &#125;&#125;// 使用&lt;compSetup title=\"access\" aaa=\"app\"&gt;&lt;/compSetup&gt; setup函数的形参props对应的是组件的参数，并且必须在props中声明才能访问的到，否则会出现在Vue inheritAttrs中 ctx对应的是一个上下文对象，包含了一些有用的属性，这些属性在vue2.x中通过this才能访问，在vue3.x中集成到了ctx属性中。如图 注意：在setup()函数中无法访问this reactivereactive()函数接受一个普通的对象，返回一个响应式的数据对象 基本语法等价于Vue2.x中的Vue.observable()函数 12345678import &#123; reactive &#125; from '@vue/composition-api'export default &#123; setup (props, ctx) &#123; const state = reactive(&#123;count : 0&#125;) // 将响应式对象state 返回出去，否则外界访问不到 return state &#125;&#125; 模板中访问 1234567&lt;template&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;span&gt; &lt;!-- 每次点击加1，同时页面也会更新 --&gt; &lt;button @click&#x3D;&quot;count +&#x3D; 1&quot;&gt; +1 &lt;&#x2F;button&gt;&lt;&#x2F;template&gt; 使用方式和原来差不多，只不过原来是data属性，现在集成到了setup函数中，写法有点像react了 refref()函数的作用是根据给定的值创建一个响应式的数据对象，ref()函数调用的返回值是一个对象，且该对象只有一个属性:value 使用:12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;!-- 在模板中使用不需要.value --&gt; &#123;&#123; count &#125;&#125; &lt;button @click&#x3D;&quot;count +&#x3D; 1&quot;&gt; +1 &lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref&#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup(props, ctx) &#123; const count &#x3D; ref(0) count.value++ &#x2F;&#x2F; 在setup中使用需要.value ref返回的是对象 return &#123; count &#125; &#125;&#125;&lt;&#x2F;script&gt; ref的功能和reactive很像，但在vue3中推荐使用ref创建响应式对象 ref和reactive配合使用123456789101112131415&lt;script&gt;import &#123;ref, reactive&#125; from '@vue/composition-api'export default &#123; setup(props, ctx) &#123; const cc = ref(0) const state = reactive&#123; cc &#125; console.log(state.cc) // 输出0 此处不需要.value就能直接访问原始值 state.cc++ console.log(state.cc) // 输出1 return state &#125;&#125;&lt;/script&gt; 注意:在setup创建的任何成员，想要使用必须在setup()中return 新的ref会覆盖就的ref: 1234567891011const a1 = ref(0)const state = reactive(&#123; a1&#125;)const a2 = ref(10)state.a1 = a2 // 将旧ref a1指向 新ref a2state.a1++console.log(state.a1) // 输出 11console.log(a2) // 输出11console.log(a1.value) // 输出0 isRef作用是判断该对象是否是ref方法创建的 12import &#123;isRef&#125; from '@vue/composition-api'const objValue = isRef(obj) ? obj.value : obj toRefs的使用toRefs函数的作用是将reactive()创建出来的对象，转换成普通的对象，只不过这个对象的每一个属性都是ref类型的响应式数据。 应用场景: 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &#123;&#123; count &#125;&#125; &lt;button @click&#x3D;&quot;increment&quot;&gt;+1&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;toRefs, reactive&#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup () &#123; const state &#x3D; reactive(&#123; count: 0 &#125;) &#x2F;&#x2F; 定义页面上的事件处理函数 const increment &#x3D; () &#x3D;&gt; &#123; state.count++ &#125; &#x2F;&#x2F; 在setup中返回一个对象供页面调用 可以包含响应式的数据，也可以包含供页面调用的函数 return &#123; ...toRefs(state), &#x2F;&#x2F; 增加的处理函数 increment &#125; &#125;&#125;&lt;&#x2F;script&gt; 在vue3中推荐在setup中写函数而不是在metods中写， 但是如果要返回响应式的值，又要返回函数的话，直接使用...state会让响应式失去作用，所以就有了toRefs函数，他把对象中所有的属性改为了ref类型，所以给页面提供了响应式的功能。 computed计算属性 computed() 用来创建计算属性，computed() 函数的返回值是一个 ref 的实例。使用 computed 之前需要按需导入： 1import &#123; computed &#125; from '@vue/composition-api' 只读计算属性 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; count的值：&#123;&#123; count &#125;&#125; 计算属性：&#123;&#123; plusOne &#125;&#125; &lt;button @click&#x3D;&quot;count +&#x3D; 1&quot;&gt;+&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; computed,ref &#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup(props, ctx) &#123; const count &#x3D; ref(0) const plusOne &#x3D; computed(() &#x3D;&gt; count.value + 1) return &#123; count, plusOne &#125; &#125;&#125;&lt;&#x2F;script&gt; 可读写的计算属性: 123456789const count = ref(0)const plusOne = computed(&#123; get: () =&gt; count.value + 1 set: (val) =&gt; count.value = val - 1&#125;)//为计算属性赋值会触发set函数plusOne.value = 10console.log(count.value) // 输出9 watch和vue2.x的watch作用一致，只是用法不一样 基础用法1234import &#123; watch, ref &#125; from '@vue/composition-api'const count = ref (0)// 每次改变count 都会打印count的值watch(() =&gt; console.log(count.value)) 监听reactive和ref123456789101112131415161718const state = reactive(&#123;count: 0&#125;)// 监视state.count的数据变化watch( () =&gt; state.count, // 第一个参数设置监听的数据源 (count, oldCount) =&gt; &#123; // 第二个参数为监听方法 // TODO &#125;, &#123; lazy: true, // watch创建的时候会自动执行一次，设置lazy可以关闭 &#125;)// 监听refconst c2 = ref(0)watch(c2, (val, oldVal) =&gt; &#123; // TODO &#125; ) 在vue2.x中监听多个数据源，需要写多个watch,在vue3中支持监听多个数据源: 监听多个数据源:1234567891011121314151617181920const state = reactive(&#123; count: 0, name: 'zs' &#125;)watch( [() =&gt; state.count, () =&gt; state.name], // Object.values(toRefs(state)), ([count, name], [oldCount, oldName]) =&gt; &#123; // 按顺序解构赋值 console.log(count) // 新的 count 值 console.log(name) // 新的 name 值 console.log('------------') console.log(oldCount) // 旧的 count 值 console.log(oldName) // 新的 name 值 &#125;, &#123; lazy: true &#125;)setTimeout(() =&gt; &#123; state.count++ state.name = 'ls'&#125;, 1000) 监听多个ref: 123456789101112131415161718192021const count = ref(0)const name = ref('zs')watch( [count, name], // 需要被监视的多个 ref 数据源 ([count, name], [oldCount, oldName]) =&gt; &#123; console.log(count) console.log(name) console.log('-------------') console.log(prevCount) console.log(prevName) &#125;, &#123; lazy: true &#125;)setTimeout(() =&gt; &#123; count.value++ name.value = 'xiaomaolv'&#125;, 1000) 清除watch监视在组件销毁的时候会自动清除watch的监听，但是如果需要手动清除的话可以用以下的方法 123const stop &#x3D; watch(() &#x3D;&gt; &#123;&#125;)&#x2F;&#x2F; 调用watch的返回值就可以停止监听stop() 清除无效的异步任务 有时候，当被 watch 监视的值发生变化时，或 watch 本身被 stop 之后，我们期望能够清除那些无效的异步任务，此时，watch 回调函数中提供了一个 cleanup registrator function 来执行清除的工作。这个清除函数会在如下情况下被调用： watch 被重复执行了 watch 被强制 stop 了 Template 中的代码示例如下： 1/* template 中的代码 */ &lt;input type=\"text\" v-model=\"keywords\" /&gt; Script 中的代码示例如下： 1234567891011121314151617181920212223242526272829// 定义响应式数据 keywordsconst keywords = ref('')// 异步任务：打印用户输入的关键词const asyncPrint = val =&gt; &#123; // 延时 1 秒后打印 return setTimeout(() =&gt; &#123; console.log(val) &#125;, 1000)&#125;// 定义 watch 监听watch( keywords, (keywords, prevKeywords, onCleanup) =&gt; &#123; // 执行异步任务，并得到关闭异步任务的 timerId const timerId = asyncPrint(keywords) // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务 onCleanup(() =&gt; clearTimeout(timerId)) &#125;, // watch 刚被创建的时候不执行 &#123; lazy: true &#125;)// 把 template 中需要的数据 return 出去return &#123; keywords&#125; 实现之后的效果是,等输入框输入暂停时才会触发打印，有了这个功能防抖就好做了 (;￢＿￢) New LifeCycle Hooks新的生命周期方法，可以按需导入到组件中，且只能在 setup() 函数中使用，代码示例如下： 123456789101112131415import &#123; onMounted, onUpdated, onUnmounted &#125; from '@vue/composition-api'const MyComponent = &#123; setup() &#123; onMounted(() =&gt; &#123; console.log('mounted!') &#125;) onUpdated(() =&gt; &#123; console.log('updated!') &#125;) onUnmounted(() =&gt; &#123; console.log('unmounted!') &#125;) &#125;&#125; 下面的列表，是 vue 2.x 的生命周期函数与新版 Composition API 之间的映射关系： beforeCreate =&gt; use setup() created =&gt; use setup() beforeMount =&gt; onBeforeMount mounted =&gt; onMounted beforeUpdate=&gt; onBeforeUpdate updated =&gt; onUpdated beforeDestroy =&gt; onBeforeUnmount destroyed =&gt; onUnmounted errorCaptured =&gt; onErrorCaptured provide和injectprovide()和inject()用于实现嵌套组件之间的数据传递，这两个函数只能在setup中使用。 父组件使用provide向下分享数据，inject在子组件中进行接收数据 用法父组件传递主题颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;&#x2F; 父组件&lt;template&gt; &lt;div&gt; &lt;h1 :style&#x3D;&quot;&#123;color: color&#125;&quot;&gt;父节点&lt;&#x2F;h1&gt; &lt;comp1 &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; provide,ref &#125; from &#39;@vue&#x2F;composition-api&#39;import inject1 from &#39;.&#x2F;inject1&#39;export default &#123; components: &#123; &#39;comp1&#39;: inject1 &#125;, setup(props, ctx) &#123; const color &#x3D; ref(&#39;#fad0c4&#39;) provide(&#39;textColor&#39;, color) setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 2秒后变为淡蓝色 color.value &#x3D; &#39;#8fd3f4&#39; &#125;,2000) return &#123; color &#125; &#125;&#125;&lt;&#x2F;script&gt;&#x2F;&#x2F; 子组件 inject1.vue&lt;template&gt; &lt;div&gt; &lt;h2 :style&#x3D;&quot;&#123;color: color&#125;&quot;&gt;子组件&lt;&#x2F;h2&gt; &lt;inject2 &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;injectimport &#123;inject&#125; from &#39;@vue&#x2F;composition-api&#39;import inject2 from &#39;.&#x2F;inject2&#39;export default &#123; components: &#123; &#39;inject2&#39;: inject2 &#125;, setup(props, ctx) &#123; const color &#x3D; inject(&#39;textColor&#39;) return &#123; color &#125; &#125;&#125;&lt;&#x2F;script&gt;&#x2F;&#x2F; 孙组件 inject2.vue&lt;template&gt; &lt;div&gt; &lt;h3 :style&#x3D;&quot;&#123;color: color&#125;&quot;&gt;孙组件&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;inject&#125; from &#39;@vue&#x2F;composition-api&#39;export default &#123; setup(props, ctx) &#123; const color &#x3D; inject(&#39;textColor&#39;) return &#123; color &#125; &#125;&#125;&lt;&#x2F;script&gt; template refsref也支持vue2.x中的 ref属性，下面看看是怎么实现的 引用页面元素和组件1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;h1 ref&#x3D;&quot;refTitle&quot;&gt;&lt;&#x2F;h1&gt; &lt;comp1 ref&#x3D;&quot;refComp&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;ref, onMounted&#125; from &#39;@vue&#x2F;composition-api&#39;impot comp1 from &#39;.&#x2F;comp&#39;export default &#123; components: &#123; comp1 &#125;, setup(props, ctx) &#123; const refTitle &#x3D; ref(null) const refComp &#x3D; ref(null) onMounted(() &#x3D;&gt; &#123; &#x2F;&#x2F; onMounted后dom才渲染完成 refTitle.value.style.color &#x3D; &#39;red&#39; &#125;) return &#123; &#x2F;&#x2F; 保持和元素中的ref一致 refTitle, refComp &#125; &#125;&#125;&lt;&#x2F;script&gt; createComponent 这个函数是非必须的，除非你想要结合typescript进行vue项目的开发 123456789import &#123;createComponent&#125; '@vue/composition-api'export default createComponent(&#123; props: &#123; foo: String &#125;, setup(props) &#123; props.foo &#125;&#125;) 总结把composition-api都体验了一遍，虽然没有做像样的例子，但是感觉还是比较容易上手的，特别如果是有2.x经验的话。看的出来使用this的地方变少或者没有了。还有就是在vue3中应该不能像以前那样用Mixins了，Mixins本身有个缺点就是数据来源不明，如果引用的多的话更是如此。还有就是对ts的支持更加友好了,这里我还没体验过不作过多说明。 TipsVue 3将支持全局tree-shaking,这意味着如果你不使用它的某些功能，这些则不会出现在你打包的文件中。 123import &#123;nextTick, observable&#125; from 'Vue'nextTick(() =&gt; &#123;&#125;)const obj = objservable(&#123;&#125;) Vue3的响应式由Object.defineProperty换为Proxy后给对象，数组赋值不需要再使用Vue.set方法 123Vue.set(obj, key, value)=&gt;this.obj[key] = value","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"axios下载文件","slug":"axios下载文件","date":"2019-10-22T13:26:12.000Z","updated":"2019-09-22T13:26:12.000Z","comments":true,"path":"2019/10/22/axios下载文件/","link":"","permalink":"https://haoge744.github.io/2019/10/22/axios%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/","excerpt":"","text":"由于有些文件需要做权限处理，下载需要所以权限 12345678910111213141516171819202122232425262728function downloadFile (file) &#123; const fileId = file.id || file.response.data.id const url =`$&#123;this.downUrl&#125;/$&#123;fileId&#125;` axios(&#123; method: 'get', url: url, responseType: 'arraybuffer', headers: &#123; Authentication: this.token, filename:'utf-8' &#125; &#125;).then(res =&gt; &#123; const fileStr = res.headers['content-disposition'] const fileName = decodeURI(fileStr.substr(fileStr.indexOf('filename=')+9)) let url = window.URL.createObjectURL(new Blob([res.data])) let link = document.createElement('a') link.style.display = 'none' link.href = url document.body.appendChild(link) link.setAttribute('download', fileName) link.target = '_blank' link.click() document.body.removeChild(link); //下载完成移除元素 window.URL.revokeObjectURL(url); //释放掉blob对象 &#125;).catch(error =&gt; &#123; console.log(error) &#125;)&#125;","categories":[{"name":"axios","slug":"axios","permalink":"https://haoge744.github.io/categories/axios/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/tags/javascript/"},{"name":"axios","slug":"axios","permalink":"https://haoge744.github.io/tags/axios/"}]},{"title":"Vue inheritAttrs的使用","slug":"Vue-inheritAttrs的使用","date":"2019-10-17T15:49:41.000Z","updated":"2019-10-17T15:49:41.000Z","comments":true,"path":"2019/10/17/Vue-inheritAttrs的使用/","link":"","permalink":"https://haoge744.github.io/2019/10/17/Vue-inheritAttrs%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"介绍Vue inheritAttrs诞生于vue2.4.0版本,目的是为了解决父孙组件传递参数的问题。在以前如果要父组件要给孙组件传值只能给子组件设置一套值，然后再给孙组件再设置一套相同的值，这样代码太过冗余并且工作量，还有一个方法就是用provide和inject,但是貌似这个方法也不是很好，组件多的话很难控制。所以vue2.4发布后解决了这个问题，还增加了关于事件向上传递的相关api $listeners","text":"介绍Vue inheritAttrs诞生于vue2.4.0版本,目的是为了解决父孙组件传递参数的问题。在以前如果要父组件要给孙组件传值只能给子组件设置一套值，然后再给孙组件再设置一套相同的值，这样代码太过冗余并且工作量，还有一个方法就是用provide和inject,但是貌似这个方法也不是很好，组件多的话很难控制。所以vue2.4发布后解决了这个问题，还增加了关于事件向上传递的相关api $listeners 如果你使用的是vue2.4之后的版本，那么当前的vue组件实例中会默认带一个属性，这个就是$attrs属性,这个属性用来保存没有在props中声明的参数属性。什么意思呢，就是你定义一个组件，这个组件的props只有一个count，但是我父组件调用的时候除了给了count，比如说还传递了一个:age=”12”,那么子组件就可以通过$attrs来获取到age。 123456789101112131415&#x2F;&#x2F; parent.vue&lt;template&gt; &lt;div&gt; &lt;children :count&#x3D;&quot;10&quot; :age&#x3D;&quot;15&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import children from &#39;.&#x2F;children&#39;export default &#123; components: &#123; children &#125;&#125;&lt;&#x2F;script&gt; 1234567891011121314151617&#x2F;&#x2F; children.vue&lt;template&gt; &lt;div&gt; &#123;&#123; count &#125;&#125; &#123;&#123; $attrs.age &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: &#123; count: Number &#125;, mounted() &#123; console.log(this) &#125;&#125;&lt;&#x2F;script&gt; 把children.vue实例打印出来如下图。 比如说项目中有这样有个功能，弹出一个有table的dialog，只是表格的字段和查询条件不一样。并且很多地方用得到，这样最好是封装成一个组件，然后我要用element的dialog和table进行封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;template&gt; &lt;el-dialog &lt;!-- sync是不支持的,所以要额外写参数 --&gt; :visible.sync&#x3D;&quot;visible&quot; &lt;!-- 给dialog组件传递参数 --&gt; v-bind&#x3D;&quot;$attrs&quot;&gt; &lt;div style&#x3D;&quot;padding: 5px;&quot;&gt; &lt;el-table class&#x3D;&quot;data-table-container&quot; :data&#x3D;&quot;tableData&quot; style&#x3D;&quot;width: 100%&quot; v-loading&#x3D;&quot;loading&quot; border&gt; &lt;el-table-column type&#x3D;&quot;index&quot; align&#x3D;&quot;center&quot; label&#x3D;&quot;序号&quot; v-if&#x3D;&quot;showNumber&quot; width&#x3D;&quot;50&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;!-- 循环表格的列，并且给表格列设置绑定属性为item --&gt; &lt;el-table-column v-for&#x3D;&quot;(item, index) in head&quot; v-bind&#x3D;&quot;item&quot; :key&#x3D;&quot;index&quot;&gt; &lt;template v-slot&#x3D;&quot;scope&quot;&gt; &lt;!-- 如果类型是slot的话给表格的列设置插槽 --&gt; &lt;slot :name&#x3D;&quot;item.prop&quot; v-if&#x3D;&quot;item.type &#x3D;&#x3D;&#x3D; &#39;slot&#39;&quot; :data&#x3D;&quot;scope.row&quot;&gt;&lt;&#x2F;slot&gt; &lt;template v-else&gt; &#123;&#123; scope.row[scope.column.property] &#125;&#125; &lt;&#x2F;template&gt; &lt;&#x2F;template&gt; &lt;&#x2F;el-table-column&gt; &lt;&#x2F;el-table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;el-dialog&gt;&lt;&#x2F;template&gt;&lt;script&gt; import request from &#39;@&#x2F;utils&#x2F;request&#39; export default &#123; name: &#39;tableGridDialog&#39;, props: &#123; head: &#123; &#x2F;&#x2F; 表格的列 required: true &#125;, showNumber: &#123; type: Boolean, default: true &#125;, url: &#123; type: String &#125;, params: &#123; type: Object &#125;, httpMethod: &#123; type: String, default: &#39;get&#39; &#125;, show: &#123; type: Boolean &#125;, formatDataMethod: &#123; type: Function &#125; &#125;, data() &#123; return &#123; tableData: [], loading: false, visible: false, &#125; &#125;, methods: &#123; initList() &#123; const queryData &#x3D; &#123; url: this.url, method: this.httpMethod &#125; if (this.params) &#123; if (this.httpMethod.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;get&#39;) &#123; queryData.params &#x3D; this.params &#125; else &#123; queryData.data &#x3D; this.params &#125; &#125; this.loading &#x3D; true request(queryData).then(res &#x3D;&gt; &#123; this.loading &#x3D; false if (res.status &#x3D;&#x3D;&#x3D; 200) &#123; &#x2F;&#x2F; 如果有数据格式化方法，执行完之后赋值 if (this.formatDataMethod) &#123; this.tableData &#x3D; this.formatDataMethod(res.data) &#125; else &#123; this.tableData &#x3D; res.data &#125; &#125; &#125;).catch(error &#x3D;&gt; &#123; console.log(error) this.loading &#x3D; false &#125;) &#125; &#125;, created() &#123; &#125;, watch: &#123; params: &#123; handler(val) &#123; if (val) this.initList() &#125;, immediate: true &#125;, url (val) &#123; if (val) this.initList() &#125;, show: &#123; handler(val) &#123; if (val !&#x3D;&#x3D; this.visible) &#123; this.visible &#x3D; val &#125; &#125;, immediate: true &#125;, visible(val) &#123; if (val !&#x3D;&#x3D; this.show) &#123; this.$emit(&#39;update:show&#39;, val) &#125; &#125; &#125; &#125;&lt;&#x2F;script&gt; 使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;tableGridDialog :url&#x3D;&quot;changeUrl&quot; width&#x3D;&quot;740px&quot; title&#x3D;&quot;xx明细&quot; :params&#x3D;&quot;param&quot; :head&#x3D;&quot;changeDesignHead&quot; :show.sync&#x3D;&quot;showchangeDesign&quot;&gt; &lt;template v-slot:createTime&#x3D;&quot;&#123;data&#125;&quot;&gt; &#123;&#123; data.createTime | dateFormat&#125;&#125; &lt;&#x2F;template&gt; &lt;&#x2F;tableGridDialog&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; changeUrl: &#39;xxx&#39;, param: &#123; queryId: &#39;xxx&#39; &#125;, changeDesignHead: [ &#123; prop: &#39;createTime&#39;, label: &#39;日期&#39;, align: &#39;center&#39;, type: &#39;slot&#39; &#125;, &#123; prop: &#39;name&#39;, label: &#39;变更名称&#39;, align: &#39;center&#39;, type: &#39;slot&#39; &#125;, &#123; prop: &#39;content&#39;, label: &#39;内容&#39;, align: &#39;center&#39;, width: &#39;200px&#39; &#125; ] &#125;, &#x2F;&#x2F; ...&#125;&lt;&#x2F;script&gt; 使用的话代码也比较简单，不作太多讲解了。总结来说在组件嵌套这块解决了很大的问题。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"win10更新后提示未安装任何音频设备","slug":"win10更新后提示未安装任何音频设备","date":"2019-10-10T06:54:00.000Z","updated":"2019-10-10T06:57:41.835Z","comments":true,"path":"2019/10/10/win10更新后提示未安装任何音频设备/","link":"","permalink":"https://haoge744.github.io/2019/10/10/win10%E6%9B%B4%E6%96%B0%E5%90%8E%E6%8F%90%E7%A4%BA%E6%9C%AA%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E9%9F%B3%E9%A2%91%E8%AE%BE%E5%A4%87/","excerpt":"","text":"某天正常开启自己的笔记本电脑发现右上角的音量图标划伤了叉号，明明前几天用的好好的，最多就是windows自动更新了下系统，没想到就给更新挂了!!!∑(ﾟДﾟノ)ノ 点击了音量图标，然后弹出个框一直在loading,读取完之后提示我重启之后就好了，但是每次重启之后还是这样提示我重启(╬￣皿￣)=○，无限循环。。。 最后百度后找到了一下三种解决方法 更新声卡驱动下载了驱动精灵安装,并更新声卡驱动到最新版本，并没有啥用￣へ￣ 卸载声卡设备操作步骤是这样的： 右键此电脑 =&gt; 管理 左侧菜单切换到设备管理器 找到声音、视频和游戏控制器 把里面关于声音的设备全部卸载了 重启电脑 再回到设备管理器右键选择 扫描检测硬件改动 但是我试了这种方法也不行 秘之方法最后在csdn的秘之方法，据说是国外大神的。 直接在命令行输入 12net localgroup Administrators /add networkservicenet localgroup Administrators /add localservice 没想到意外解决了，所以记下此次记录，希望帮助更多人。","categories":[{"name":"生活","slug":"生活","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"webpack基础使用及配置","slug":"webpack基础使用及配置","date":"2019-10-06T16:34:46.000Z","updated":"2019-10-06T17:00:46.365Z","comments":true,"path":"2019/10/07/webpack基础使用及配置/","link":"","permalink":"https://haoge744.github.io/2019/10/07/webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/","excerpt":"VueCli用的比较多了，但是没有系统性的学过webpack,今天不基于任何脚手架工具单纯用webpack搭建一个小项目,加深自己对webpack的理解,以及一些常用配置。另外本文使用的是webpack4.41.0,在一些插件的使用上用了最新的方案。","text":"VueCli用的比较多了，但是没有系统性的学过webpack,今天不基于任何脚手架工具单纯用webpack搭建一个小项目,加深自己对webpack的理解,以及一些常用配置。另外本文使用的是webpack4.41.0,在一些插件的使用上用了最新的方案。 初始化12345678910111213-- 创建一个项目文件夹名字任意-- 新建src/main.js-- 新建src/index.htmlcd 项目文件夹-- 初始化package.jsonnpm init -y -- 安装相关组件yarnyarn add webpack --devyarn add html-webpack-plugin --devyarn add webpack-dev-server --devyarn add webpack-cli --dev 创建配置文件1234567891011121314151617// 创建webpack.config.jsconst path = require('path')const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: path.join(__dirname, './src/index.js'),// 入口文件 output: &#123; // 输出文件 path: path.join(__dirname, './dist'), filename: 'bundle.js' &#125;, plugins: [ // 插件 new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'), filename: 'index.html' &#125;) ]&#125; 配置启动命令行123456789// package.json&#123; ... \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", // --open自动打开浏览器 端口 3000, 热修复 \"dev\": \"webpack-dev-server --open --port 3000 --hot\" &#125;,&#125; 添加模式作用是为了区分生产环境和测试环境 12345678&#x2F;&#x2F; package.json&#123; ... &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --hot --mode development&quot;, &quot;prod&quot;: &quot;&quot;webpack-dev-server --open --port 3000 --hot --mode production&quot; &#125;,&#125; mode属性是webpack4.0.0后增加的，内容可以是development和production,在dev和prod环境下process.env.NODE_ENV打印的值分别为development和production。 项目是可以跑起来了,但是还有一些欠缺，没有对css/scss、图片资源等资源进行处理；还有没有对es6语法进行兼容性问题处理。这个时候就需要用到webpack的loader了。 添加loader在src中新建css/index.scss文件和目录,然后给一个div设置背景图片 在main.js中引入 1import &#39;.&#x2F;css&#x2F;index.scss&#39; 然后运行后设置的css是无效的，因为没有给css和scss配置对应的loader，代码没有转换，所以会出现错误。 配置样式loader1yarn add style-loader css-loader sass-loader node-sass url-loader file-loader --dev 修改webpack.config.js 1234567891011module.exports = &#123; // 入口、输出、插件等配置在这里省略... module: &#123; rules: [ //some rule loaders... , &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|gif|bmp|jpg)$/, use: ['url-loader?limit=5000']&#125;, ] &#125;&#125; 配置babel1yarn add babel-core babel-loader babel-plugin-transform-runtime babel-preset-env babel-preset-stage-0 --dev 修改webpack.config.js 12345678910module.exports = &#123; // 入口、输出、插件等配置在这里省略... module: &#123; rules: [ //some rule loaders... , // 对js文件使用babel-loader, 排除node_modules中的文件 &#123; test: /\\.js$/, use 'babel-loader', exclude: /node_modules/ &#125; ] &#125;&#125; 在根目录新建.babelrc文件 1234567// json格式&#123; // 刚刚装的babel-preset-x 在这里写上 \"presets\": [\"env\", \"stage-0\"], // 使用的插件 babel-plugin-transform-runtime \"plugins\": [\"transform-runtime\"]&#125; 关于babel相关的配置及.babelrc文件的编写可以查看这篇文章 配置完后就可以使用scss、图片、es6等最新语法了 打包打包前需要安装几个全局依赖(如果没有安装的话) 12npm install webpack -gnpm install webpack-cli -g 然后直接在当前目录执行webpack命令就可以打包到dist目录下了 打包相关配置优化很多时候我们开发和打包的相关配置希望单独存放 复制webpack.config.js重命名webpack.config.build.js 在package.json中添加build命令 12345678&#123; // ... \"scripts\": &#123; // ... some scripts // 自定义设置文件 \"build\": \"webpack --config webpack.config.build.js --mode production\" &#125;&#125; 然后运行 npm run build就okl了 优化图片路径及名称1234&#123; test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000] &#125;// 改为// 图片名称改为8为哈希值-图片名.后缀名, 路径生成到images下面 &#123; test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000&amp;name=images/[hash:8]-[name].[ext]'] &#125; 每次打包前删除dist文件安装插件 1yarn add clean-webpack-plugin --dev 在config中添加 12345678910111213141516171819const clearWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; // ... plugins: [ // 数组中传入需要删除的文件夹名 new clearWebpackPlugin(['dist']) ]&#125;------------- 新写法----------------------const &#123;CleanWebpackPlugin&#125; = require('clean-webpack-plugin')module.exports = &#123; // ... plugins: [ // 数组中传入需要删除的文件夹名 new clearWebpackPlugin() ]&#125; 抽取第三方包在开发项目中会用到各种各样的第三方包,我们目前的这个打包方式会把第三方包和自己写的业务代码都放在bundle.js文件中，这样太臃肿了。 1234567891011121314151617181920212223242526272829303132// 修改webpack.config.build.js文件const webpack = require('webpack') // 导入webpack// 修改entry入口节点 把原来的入口文件改为对象module.exports = &#123; entry: &#123; // 配置入口节点 app: path.join(__dirname, './src/main.js'), // 这个名字要和chunk插件中的name对应 vendors: ['jquery','moment'] // 数组内为要分割的第三方包 &#125;,// 修改plugins// ------------------ 这是 webpack 3.x.x的写法 ----------------------- plugins: [ ... new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendors', // 指定要抽离的入口名称 filename: 'vendors.js' // 打包时除了会有一个bundle.js还有一个vendors.js文件里面存放了第三方包 &#125;) ]// ------------------ webpack 4.x.x的写法 ----------------------- // 配置optimization(和entry同级的属性) optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; name: \"vendors\", chunks: \"initial\", minChunks: 2 &#125; &#125; &#125; &#125;,&#125; 随着webpack4升级chunk得配置也发生了变化 相关链接 html-webpack-plugin的优化1234567891011121314&#x2F;&#x2F; 修改打包配置文件&#123; plugins: [ new htmlWebpackPlugin(&#123; template: path.join(__dirname, &#39;.&#x2F;src&#x2F;index.html&#39;), filename: &#39;index.html&#39;, minify: &#123; &#x2F;&#x2F; html优化项 collapseWhitespace: true,&#x2F;&#x2F; 清除多余的空格 removeComments: true, &#x2F;&#x2F; 清除注释 removeAttributeQuotes: true &#x2F;&#x2F; 清除属性上的双引号 &#125; &#125;), ]&#125; 还有更多选项Github css相关优化抽取css文件安装插件webpack 3.x.x使用extract-text-webpack-plugin(这里不做介绍) 1npm install --save-dev mini-css-extract-plugin github webpack 4.x.x使用mini-css-extract-plugin github地址 1npm install --save-dev mini-css-extract-plugin 修改配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// webpack.build.config.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin') // 引入插件module.exports = &#123; plugins: [ // ... some another plugins new MiniCssExtractPlugin(&#123; filename: '[hash:8]-[name].css', chunkFilename: '[id],css', ignoreOrder: false, // Enable to remove warnings about conflicting order &#125;) ], module: &#123; rules: [ &#123; test: /\\.css$/, // use: ['style-loader', 'css-loader'] // 注释之前的loader use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: (resourcePath, context) =&gt; &#123; // 资源路径，如果你的css打包至css/xxx.css中，那么要返回../ return './'; &#125;, &#125; &#125;, // style-loader不能引入否则会报错 'css-loader' ] &#125;, &#123; test: /\\.scss$/, // 配置scss // use: ['style-loader', 'css-loader', 'sass-loader'] use: [ &#123; loader:MiniCssExtractPlugin.loader, options: &#123; publicPath: (resourcePath, context) =&gt; &#123; return './'; &#125;, hmr: process.env.NODE_ENV === 'development' &#125;, &#125;, // style-loader不能引入否则会报错 'css-loader', 'sass-loader' ] &#125;, ] &#125;&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/tags/webpack/"}]},{"title":"typescript随手笔记1","slug":"typescript随手笔记1","date":"2019-10-02T15:33:15.000Z","updated":"2019-10-05T15:34:14.034Z","comments":true,"path":"2019/10/02/typescript随手笔记1/","link":"","permalink":"https://haoge744.github.io/2019/10/02/typescript%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B01/","excerpt":"介绍TypeScript是Javascript的超集，具有静态类型特性，旨在简化大型JavaScript应用程序的开发，也被称为Javascript that scales(可扩展的JavaScript)","text":"介绍TypeScript是Javascript的超集，具有静态类型特性，旨在简化大型JavaScript应用程序的开发，也被称为Javascript that scales(可扩展的JavaScript) 优点 在开发周期中能更早地捕获潜在的错误。 管理大型代码库 更易于重构 更易于团队合作：代码的耦合性越强，不同开发人员访问代码库时越不容易造成无意的破坏 文档特性：类型本身就是一种文档信息，方便日后开发者本人或者其他开发者查询。 缺点 需要学习周期 类型错误多种多样 配置极大地影响运行 TS的类型Boolean1const loading: boolean = true; Number12const decimal: number = 1;const binary: number = 0b110; String1const str: string = 'hello world' Array123let arr: Array = [2,4,5,6]// 使用泛型let arr2: Array&lt;number&gt; = [2,6,55] Tuple(元组)数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。 1let tom: [string, number] = ['Tom', 25]; Any (任意类型)123let variable: any = 123variable = 'bbb'variable = [12,23] void 空值void表示没有任何类型。它通常用作没有返回值的函数的返回类型 123function sayHello(name: string): void &#123; console.log(`hello $&#123;name&#125;`)&#125; Neverneverl类型表示的是那些用不存在的值得类型。一般用于错误处理函数 123function error(message: string): never &#123; throw new Error(message);&#125; 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 12var a: string | number = 'abc'a = 212 Null &amp; Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： 12let u: undefined = undefined;let n: null = null; undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12345678&#x2F;&#x2F; 这样不会报错let num: number &#x3D; undefined;&#x2F;&#x2F; 这样也不会报错let u: undefined;let num: number &#x3D; u;&#x2F;&#x2F; 这样会报错let u: void;let num: number &#x3D; u;&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;. 下一篇会写些关于接口和类相关的内容 更多详细内容推荐阅读此篇教程","categories":[{"name":"typescript","slug":"typescript","permalink":"https://haoge744.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://haoge744.github.io/tags/typescript/"}]},{"title":"react事件this指向问题","slug":"react事件this指向问题","date":"2019-10-02T13:09:32.000Z","updated":"2019-10-02T13:09:32.000Z","comments":true,"path":"2019/10/02/react事件this指向问题/","link":"","permalink":"https://haoge744.github.io/2019/10/02/react%E4%BA%8B%E4%BB%B6this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/","excerpt":"react 在事件绑定和html不同的几点: react事件命名使用驼峰命名法，onclick要写成onClick,onchange写成onChange 事件赋值要加{}而不是属性赋值的方式如: 1234dom:&lt;button onclick=\"clickHandler()\"&gt;按钮&lt;/button&gt;react:&lt;button onClick=&#123;clickButton&#125;&gt;按钮&lt;/button&gt;","text":"react 在事件绑定和html不同的几点: react事件命名使用驼峰命名法，onclick要写成onClick,onchange写成onChange 事件赋值要加{}而不是属性赋值的方式如: 1234dom:&lt;button onclick=\"clickHandler()\"&gt;按钮&lt;/button&gt;react:&lt;button onClick=&#123;clickButton&#125;&gt;按钮&lt;/button&gt; 事件处理 12345678910111213141516171819202122class MyComponent extends React.Component &#123; construct (props)&#123; super(props) this.setState &#x3D; &#123; count: 0 &#125; &#125; handlerClick (event) &#123; const number &#x3D; ++ this.state.number; this.setState &#x3D; &#123; count: number &#125; &#125; render () &#123; return ( &lt;button onClick&#x3D;&#123;this.handlerClick(event)&#125;&gt;按钮&lt;&#x2F;button&gt; ) &#125;&#125; this指向问题 使用es6箭头函数 123456789101112131415class MyComponent extends React.Component &#123; constructor (props) &#123; super(props); this.setState = &#123; count: 0 &#125; &#125; render () &#123; return ( &lt;button onClick=&#123;(event) =&gt; &#123;console.log(this.state.count)&#125;&#125;&gt;按钮&lt;/button&gt; ) &#125; &#125; 注：直接在render方法中定义事件处理函数的最大问题是，每次render调用时都会创建一个新的事件处理函数，给组件带来额外的开销，当组件的层级越低，开销就越大，组件的任何上一层级组件的变化都会触发这个组件的render方法（一般可以忽略）。 使用组件的方法 12345678910111213141516171819202122class MyComponent extends React.Component &#123; constructor (props) &#123; super(props); this.setState = &#123; count: 0 &#125; this.handlerClick = this.handlerClick.bind(this) &#125; handlerClick(event) &#123; const number = ++ this.state.count this.setState = &#123; count: number &#125; &#125; render () &#123; return ( &lt;button onClick=&#123;this.handlerClick&#125;&gt; 按钮 &lt;/button&gt; ) &#125; &#125; 注：这种方法的好处是每次render渲染都不会重新创建一个回调函数，没有额外的性能损失，但是如果在一个组件中有很多的事件函数时这种在构造函数中绑定this的方法会显得繁琐，还可以直接在给事件属性直接赋值时绑定this； 使用bind方法 123456789101112131415161718192021class MyComponent extends React.Component &#123; constructor (props) &#123; super(props); this.setState = &#123; count: 0 &#125; &#125; handlerClick(event) &#123; const number = ++ this.state.count this.setState = &#123; count: number &#125; &#125; render () &#123; return ( &lt;button onClick=&#123;this.handlerClick.bind(this)&#125;&gt; 按钮 &lt;/button&gt; ) &#125;&#125; 12345678910111213141516171819202122232425262728class MyComponent extends React.Component&#123; constructor(props)&#123; super(props); this.setState=&#123; list:[1,2,3,4,5], current:1 &#125; &#125; //每点击一项时，将点击项设置为当前选中项，因此需要将点击项作为参数传递 handleClcik(item，event)&#123; this.setState=&#123; current:item &#125; &#125; render()&#123; &lt;ul&gt; &#123; &#123;/*bind除了绑定this，还绑定item作为参数,供handleClick使用*/&#125; this.state.list.map((item)=&gt;( &lt;li className=&#123;this.state.current==item?\"current\"：\"\"&#125; onClick=&#123;this.handleClick.bind(this,item)&#125;&gt;&#123;item&#125;&lt;/li&gt; )) &#125; &lt;/ul&gt; &#125; 属性初始化语法(property initializer syntax)** 使用es7的property initializers 会自动为class中定义的方法绑定this，列如: 1234567891011121314151617class MyComponent extends React.Component&#123; constructor(props)&#123; super(props); this.setState=&#123;number:0&#125;; &#125; handleClcik=(event)=&gt;&#123; const number=++this.state.number; this.setState=&#123; number &#125; &#125; render()&#123; &lt;div&gt;&#123;this.state.number&#125;&lt;/div&gt; &#123;/*事件属性赋值和this绑定同时*/&#125; &lt;button onClcik=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt; &#125;&#125; 此种方法既不需要再构造函数中绑定this，也不需要担心重复渲染导致重复创建的问题，但： property initializers还处在实验性阶段，默认不支持，不过官方的脚手架create-react-app默认支持这个特性,如果你想要在你的项目中使用这个默认的特性，你可以在项目中引入babel的transform-class-properties插件获取这个特性的支持。 以上为react事件处理的三种方式及this问题的全部内容，如下不当之处欢迎指正。。。。 原文出处链接","categories":[{"name":"react","slug":"react","permalink":"https://haoge744.github.io/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"https://haoge744.github.io/tags/react/"}]},{"title":"moment.js基础使用","slug":"moment-js基础使用","date":"2019-09-28T15:09:16.000Z","updated":"2019-09-28T15:09:16.000Z","comments":true,"path":"2019/09/28/moment-js基础使用/","link":"","permalink":"https://haoge744.github.io/2019/09/28/moment-js%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"moment.js基础使用开发中不可避免的会经常碰到一些对日期的操作，使用moment.js可以很简单的实现很多对日期的一些操作，像日期的格式化，转换，计算，当月的第一天或最后一天等等之类的需求，它都可以快速实现。","text":"moment.js基础使用开发中不可避免的会经常碰到一些对日期的操作，使用moment.js可以很简单的实现很多对日期的一些操作，像日期的格式化，转换，计算，当月的第一天或最后一天等等之类的需求，它都可以快速实现。 安装moment.js也支持使用包管理器安装 123npm install moment// or &lt;script src=\"moment.js\"&gt;&lt;/script&gt; 创建moment对象12345moment() // 当前时间moment().format('YYYY-MM-DD HH:mm:ss') // 当前事件格式化moment('2019-12-12 ', 'YYYY-MM-DD') // 字符串格式化转为对象moment(new Date().getTime()) // 使用时间戳毫秒转const day = moment(\"1995-12-25\"); 格式化1moment().format('YYYY-MM-DD') 日期计算123456moment().days(3) // days函数取得是在周中的天数，比如传入3求的是下个周三的日期moment().day(-7); // 上周三 (0 - 7)// weekday的用法和days大致相同moment().weekday(3) // 获取本周三的日期moment().weekday(-1) // 获取上周末的日期 相当于这周一减1的日期moment().weekday(-10) // 获取上上周周五的日期 本周-10 日期加减12moment().add(1, 'days') // 可以使用简写moment().subtract(1, 'days') // 求昨天的日期 Key Shorthand years y quarters Q months M weeks w days d hours h minutes m seconds s milliseconds ms 日期相减12// 计算当前两个日期相差多少天moment().diff(moment('2019-08-05', 'YYYY-MM-DD'), 'days') 获取最后一天1234567// 获取当月最后一天的日期moment().endOf('month').format('YYYY-MM-DD')// 获取当年最后一天的日期 moment().endOf('year').format('YYYY-MM-DD')// 这样也可以获取当年最后一天的日期moment().month(11).endOf('month')moment('2018-05-24','YYYY-MM-DD').endOf('month') // 2018-05-31 我目前常用的也就是格式化和互相转换,还有日期相减之类的，具体更多方法请参照官方api文档","categories":[{"name":"javascript","slug":"javascript","permalink":"https://haoge744.github.io/categories/javascript/"}],"tags":[{"name":"moment","slug":"moment","permalink":"https://haoge744.github.io/tags/moment/"}]},{"title":"vue-cli3.0升级","slug":"vue-cli3-0升级","date":"2019-09-15T15:29:49.000Z","updated":"2019-09-15T15:29:49.000Z","comments":true,"path":"2019/09/15/vue-cli3-0升级/","link":"","permalink":"https://haoge744.github.io/2019/09/15/vue-cli3-0%E5%8D%87%E7%BA%A7/","excerpt":"全局安装目前执行 install Vue-cli -g命令只会安装到Vue-cli 2.9.6,因为Vue cli以后的版本改了包名 改为了 @vue/cli 所以要先卸载掉Vue-cli 2.x.x的版本,在进行安装 12npm uninstall -g vue-clinpm install -g @vue/cli 12yarn global remove vue-cliyarn global add @vue/cli","text":"全局安装目前执行 install Vue-cli -g命令只会安装到Vue-cli 2.9.6,因为Vue cli以后的版本改了包名 改为了 @vue/cli 所以要先卸载掉Vue-cli 2.x.x的版本,在进行安装 12npm uninstall -g vue-clinpm install -g @vue/cli 12yarn global remove vue-cliyarn global add @vue/cli 创建vue-cli3项目1234567891011vue create &lt;projectName&gt;&#x2F;&#x2F; 之后可以选择以下选项 (空格&#x3D;单选 a&#x3D;全选 i&#x3D; 反选)1. Babel 使用babel做编译以兼容IE浏览器2. TypeScript 支持TypeScript3. Progressive Web App (PWA) support 支持pwa应用4. router 路由5. vuex 状态管理6. Css Pre-processors css 预处理7. Linter &#x2F; Formatter 代码风格校验8. Unit Testing 单元测试9. E2E Testing 端对端测试 除了使用命令行创建项目还可以使用图形化界面创建 1vue ui 运行命令后会自动打开浏览器，点击选择好目录可以点击在此创建新项目创建项目了， 然后输入一些基本信息 然后选择项目配置，我选了手动配置,然后可以选择一些基本功能，router,vuex,linter,css预处理之类的功能，css预处理有scss、less、stylus之类。全部选好之后就会自动创建项目了。 创建完成后可以进入图形化的项目管理界面。功能分为5个大模块 项目仪表盘 可以做一些之运行任务、关闭端口、更新插件依赖的功能(可以自定义菜单) 插件 可以查看、安装插件。 依赖 可以查看、安装依赖。 配置 对Vue Cli、Eslint、Css编译进行配置 任务 一些运行、构建、lint之类的指令。 vue-ui具体更多功能和效果需要自己动手去摸索。 启动123cd &lt;project-name&gt;npm run servenpm run build // 构建 启动参数: 123456789vue-cli-service serve [options] [entry]选项： --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false) 构建参数: 12345678910111213用法：vue-cli-service build [options] [entry|pattern]选项： --mode 指定环境模式 (默认值：production) --dest 指定输出目录 (默认值：dist) --modern 面向现代浏览器带自动回退地构建应用 --target app | lib | wc | wc-async (默认值：app) --name 库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名) --no-clean 在构建项目之前不清除目标目录 --report 生成 report.html 以帮助分析包内容 --report-json 生成 report.json 以帮助分析包内容 --watch 监听文件变化 工程结构 Vue-cli3目录 123456789101112131415┌─src 源码目录│ └─assets 资源目录│ └─components 组件目录│ └─api 后端交互相关模块(需自己手动添加,这里只是建议)│ └─views 所有路由组件│ └─router 所有路由配置文件目录│ └─store 所有状态管理配置文件目录│ └─main.js vue入口文件│ └─App.js 入口vue文件├─package.json 项目基本信息,包依赖信息等├─platforms 存放各平台专用页面的目录，详见├─public public静态资源文件，打包时会被复制到输出目录(dist)中│ └─index.html│ └─favicon.ico├─vue.config.js 可选配置文件，下面会介绍 可以看到Vue Cli3和Vue Cli2相比少了config和build文件夹，少了很多配置文件，变得更加简洁。但是如果要修改webpack相关配置的话需要就用到vue.config.js文件了。 vue.config.js部分属性说明: 12345678910111213141516171819202122232425262728293031323334353637383940module.export&#123; // 做文件打包后部署用的。如果你的公共路径是 http://www.xxx.com 那么使用默认的 '/' // 如果是 http://www.xxx.com/app 则需要修改成'/app' publicPath: '/', // 最新版本使用publicPath替代原来的 baseUrl outputPath: 'dist', // 构建之后 lintOnSave: true, // 是否在保存时执行eslint检查 devServer: &#123; host: '', port: 8181, open: true, //配置自动启动浏览器 proxy: &#123; ... &#125; &#125;, configureWebpack: &#123; // Object | Function plugs: [ new webpack.DefinePlugin(&#123; // 使用definePlugin定义全局变量 'process.env.api_url': '', &#125;) ] &#125;, chainWebpack(config) &#123; // 使用chainWebpack自定义loader config.module .rule('svg') .exclude.add(resolve('src/icons')) .end() config.module // 使用svg-sprite-loader组件加载svg文件 .rule('icons') .test(/\\.svg$/) .include.add(resolve('src/icons')) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options(&#123; symbolId: 'icon-[name]' &#125;) .end() &#125;, pluginOptions: &#123;&#125; // 第三方插件配置 &#125; 关于vue-config的更多配置请参考官方文档 配置环境变量前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。 Vue Cli2.x.x的配置主要是在 config/dev.env.js 和config/prod.env.js中配置,但是到了Vue Cli3后这个配置文件没有了，但是不用担心，到了Vue Cli3中后这个功能变得更加灵活了，可以配置更多种环境变量。 比如说我们配置开发、生产环境的后台地址变量: 123456&#x2F;&#x2F; 新建 &#39;.env.development&#39; 文件# api地址VUE_APP_BASE_API &#x3D; &#39;&#x2F;development&#x2F;api&#39;&#x2F;&#x2F; 新建 &#39;.env.production&#39; 文件# api地址VUE_APP_BASE_API &#x3D; &#39;&#x2F;production&#x2F;api&#39; 新建完成后会自动根据当前运行环境来读取对应配置文件中的变量了。 自定义模式假如我们要创建一个预上线的环境需要另外一套配置,比如说叫做staging。 在package.json中添加一个命令(也可以在启动时添加 —mode参数) 1234567\"scripts\": &#123; \"scripts\": &#123; \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", \"staging\": \"vue-cli-service serve --mode staging\" &#125;, 创建 .env.staging, 文件后缀需要与 --mode 后面跟的值一样 12NODE_ENV &#x3D; &#39;production&#39;VUE_APP_BASE_API &#x3D; &#39;&#x2F;staging&#x2F;api&#39; 注意: 只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中。 关于环境变量和模式的官方介绍文档 Tips安装Vue cli3前必须卸载Vue cli2,如果安装完Vue cli3 之后，还想用Vue-cli2.x 版本呢Vue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 Vue init 功能，你可以全局安装一个桥接工具： 123npm install -g @vue/cli-init// 安装完后 就还可以使用 vue init 命令vue init webpack my_project","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"node学习笔记","slug":"node学习笔记","date":"2019-09-08T13:32:19.000Z","updated":"2019-09-08T13:32:19.000Z","comments":true,"path":"2019/09/08/node学习笔记/","link":"","permalink":"https://haoge744.github.io/2019/09/08/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Node介绍nodejs的显著特性是它的异步和事件驱动机制。以及其短小精悍的标准库。目前nodejs分为两个版本，长期支持版(LTS)和当前版。node内部使用了libuv的库来访问操作系统的非阻塞网络调用。node的动力源自V8 Javascript引擎","text":"Node介绍nodejs的显著特性是它的异步和事件驱动机制。以及其短小精悍的标准库。目前nodejs分为两个版本，长期支持版(LTS)和当前版。node内部使用了libuv的库来访问操作系统的非阻塞网络调用。node的动力源自V8 Javascript引擎 Node Web程序Node Web项目的结构 12345678910┌─package.json 一个包含依赖项列表和运行这个程序的命令的文件├─public&#x2F; 静态资源文件夹,css和客户端js放在这里├─node_modules&#x2F; 项目的依赖项都会撞到这里├─src 放程序代码的文件夹，│ ├─app.js或index.js 设置程序的代码│ ├─modles&#x2F; 数据库模型│ ├─views&#x2F; 用来渲染页面的模板;│ ├─controllers或routes http请求处理器│ └─middleware&#x2F; 中间件组件├─another... 其它 开始一个新的web程序1234567mkdir latercd later npm init -fy-- 安装expressnpm install express --save-- 安装消息体解析器npm install body-parser --save 使用消息体解析器 123456789101112131415const express = require('express')const app = express()const articles = [&#123;title: 'Example'&#125;]const bodyParser = require('body-parser')app.set('port', process.env.PORT || 3000)app.use(bodyParse.json())app.use(bodyParse.urlencoded(extended: true))app.post('/articles', (req, res, next) =&gt; &#123; const article = &#123;title: req.body.title&#125; articles.push() res.send(article)&#125;) 发送http请求12345678910111213141516const http = require('http')http.request(&#123; host: 'localhost', port: '8080', path: '/index.html'&#125;, res =&gt; &#123; const body = '' res.on('data', data =&gt; &#123; body += data &#125;) res.on('end', () =&gt; &#123; // 数据接收完成 console.log(body) &#125;)&#125;) 连接mysql安装mysql模块 1cnpm install mysql --save 连接数据库: 1234567891011121314151617const mysql = require('mysql')const connection = mysql.createConnection(&#123; host: 'localhost', user: 'root', port: '3306', password: '123456', database: 'test', // charset 默认 UTF8_GENERAL_CI&#125;)connection.connect()connection.query('SELECT 1 + 1 AS soluction', (err, results, fields) =&gt; &#123; if (err) throw err; console.log('The solution is :', results[0].solution)&#125;) 查询数据 123456const sql = 'select * from websites'connection.query(sql, (err, result) =&gt; &#123; if (err) &#123;return&#125; console.log(result)&#125;) 插入数据 12345678const addSql = 'INSERT INTO websites(ID,name,url,alexa) VALUES(?,?,?,?)'const addSqlParams = ['zxczxss','菜鸟工具', 'https://www.sss.com','2345']connection.query(addSql,addSqlParams,(err, result) =&gt; &#123; if (err) &#123; console.log(err) &#125; console.log(result)&#125;) 更新、删除用的也是query方法，改了sql而已， result的内容不一样 express 的使用123456789101112const express = require('express')const app = express()app.get('/', (req, res) =&gt; &#123; res.send('Hello World')&#125;)const server = app.listen(8081, () =&gt; &#123; const &#123;address, port&#125; = server.address() console.log('服务器成功:访问地址为 http://%s:%s',address, port) &#125;) res.send()的参数可以是 Buffer、Object、String、Array res.end()参数类型只能是Buffer或String app.get和use的区别 use不区分get和post use 请求路径中只要第一部分只要匹配上即可， 并不要求请求路径完全相等 app.all不限制method，要求路径完全匹配 使用正则匹配123app.get(/^\\/index(\\/.+)*$/, (req, res) =&gt; &#123; res.send('hello world')&#125;) 通过req.params获取路由参数123app.get('/news/:year/:month/:day', (req, res) =&gt; &#123; res.send(req.params)&#125;) 处理静态资源123const path = require('path')app.use('/', app.static(path.join(__dirname, 'public')))// app.use('/public', app.static(path.join(__dirname, 'public'))) res常见方法 res.send() 返回数据 res.json([body]) 返回JSON格式数据 content-type会设置为application/json res.jsonp(body) 返回JSONP数据 res.redirect([status], ‘path’) 重定向状态码非必填。 res.sendFile(path,[,options],[,fn]) 发送文件 res.status(code).end() 设置http返回的状态码 express路由模块封装错误做法: 123456789101112// router.jsmodule.exports = (app) =&gt; &#123; app.get('/index', (req,res) =&gt; &#123;&#125;) // app.get // ...&#125;// main.js:const express = require('express')const router = reqire('./router')const app = express()router(app) 正确做法，解耦app对象: 123456789101112131415161718192021222324// router.jsconst express = require('express')const router = express.Router()router.get('/index',(req,res) =&gt; &#123; req.send('index')&#125;)// 静态资源文件router.use('/resources', exporess.static())// ...module.exports = router// main.jsconst express = require('express')const router = require('router')const app = express()app.use('/public',express.static('./public/' ))app.use(router)app.listen(3000, () =&gt; &#123; console.log('Server Running...')&#125;) 封装handler1234567// handler.jsmodule.exports.index = (req, res) =&gt; &#123; res.send('index')&#125;// router.jsconst handler = require('./handler')router.get('index', handler.index) express 处理表单数据get表单处理1234567app.get('/form_get', (req, res) =&gt; &#123; const response = &#123; 'first_name': req.query.firstName, 'last_name': req.query.lastName &#125; res.send(response)&#125;) post表单处理1234567app.post('/form_post', (req, res) =&gt; &#123; const response = &#123; 'first_name': req.body.firstName, 'last_name': req.body.lastName &#125; res.send(response)&#125;) 处理文件上传 1234&lt;form action=\"/file_upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"image\" size=\"100\" /&gt; &lt;input type=\"submit\" value=\"上传\" /&gt;&lt;/form&gt; 123456789101112131415161718app.post('/file_upload', (req, res) =&gt; &#123; console.log(req.files[0]) // 上传的文件信息 var des_file = __dirname + \"/\" + req.files[0].originalname; fs.readFile( req.files[0].path, function (err, data) &#123; fs.writeFile(des_file, data, function (err) &#123; if( err )&#123; console.log( err ); &#125;else&#123; response = &#123; message:'File uploaded successfully', filename:req.files[0].originalname &#125;; &#125; console.log( response ); res.end( JSON.stringify( response ) ); &#125;); &#125;);&#125;) 静态资源处理1234//将静态文件目录设置为：项目根目录+/publicapp.use(express.static(__dirname + '/public'));//或者app.use(express.static(path.join(__dirname, 'public'))); 使用cookie-parser管理cookie123456789const express = require('express')const cookieParser = require('cookie-parser')const util = require('util')const app = express()app.use(cookieParser)app.get('/', (req, res) =&gt; &#123; console.log('Cookies info:' util.inspect(req.cookies))&#125;) ejs模板引擎安装ejs1cnpm install ejs --save 使用ejs1234const ejs = require('ejs')const html = '&lt;h1&gt;&lt;%= name %&gt;&lt;/h1&gt;'const result = ejs.render(html,&#123;name: '张飞'&#125;)console.log(result) 渲染html文件 index.html 12345678&lt;h1&gt; &lt;%= title%&gt;&lt;/h1&gt;&lt;ul&gt; &lt;% for (var i = 0; i &lt; 5; i++) &#123; %&gt; &lt;li&gt; &lt;%= msg %&gt; &lt;/li&gt; &lt;%&gt; &#125; &lt;/%&gt;&lt;/ul&gt; 12345678const ejs = require('ejs')const path = require('path')ejs.renderFile(path.join(__dirname, 'index.html'), &#123; title: '标题', msg: '你好ejs'&#125;, (err, result) =&gt; &#123; console.log(result)&#125;)","categories":[{"name":"node","slug":"node","permalink":"https://haoge744.github.io/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://haoge744.github.io/tags/node/"}]},{"title":"webpack打包优化配置","slug":"webpack打包优化配置","date":"2019-09-03T03:38:49.000Z","updated":"2019-09-03T03:38:49.000Z","comments":true,"path":"2019/09/03/webpack打包优化配置/","link":"","permalink":"https://haoge744.github.io/2019/09/03/webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/","excerpt":"关闭source-map配置关闭source-map之后可以大大减少打包后文件体积，关掉之后出现的弊端是如果出现报错信息，无法准确判断问题在哪。 1234567// config/index.js// 把productionSourceMap属性的true改成false即可生效module.exports = &#123; build: &#123; productionSourceMap: true =&gt; false &#125;&#125;","text":"关闭source-map配置关闭source-map之后可以大大减少打包后文件体积，关掉之后出现的弊端是如果出现报错信息，无法准确判断问题在哪。 1234567// config/index.js// 把productionSourceMap属性的true改成false即可生效module.exports = &#123; build: &#123; productionSourceMap: true =&gt; false &#125;&#125; gzip压缩优化gzip可以优化页面加载时的速度，这个操作需要后台配合开启gzip,并且安装compression-webpack-plugin的时候要注意版本，像我用的webpack 3.6安装了compression-webpack-plugin 3.0.0然后就出现错误了。 开启gzip后,js会生成js.gz文件，会略微增加打包文件的体积: 123456// Gzip off by default as many popular static hosts such as// Surge or Netlify already gzip all static assets for you.// Before setting to `true`, make sure to:// npm install --save-dev compression-webpack-pluginproductionGzip: false, 服务端开启gzip压缩: 修改服务器的配置，这里的服务器是Nginx找到conf目录下的nginx.conf ,开启gzip,并设置gzip的类型，如下开启后，访问服务器的js文件时，会优先查找.gz文件，如果没有则会查找.js文件 123456gzip on; #开启或关闭gzip on offgzip_disable &quot;msie6&quot;; #不使用gzip IE6gzip_min_length 100k; #gzip压缩最小文件大小，超出进行压缩（自行调节）gzip_buffers 4 16k; #buffer 不用修改gzip_comp_level 5; #压缩级别:1-10，数字越大压缩的越好，时间也越长gzip_types text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png; # 压缩文件类型 HappyPack插件优化由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以Webpack 需要处理的事情需要一件一件的做，不能多件事一起做。我们需要Webpack 能同一时间处理多个任务，发挥多核 CPU 电脑的威力，HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 安装: 1npm i -D happypack 在webpack.config.js中添加plugins 123456789101112131415161718module.exports = &#123; // ... 一些模块配置 plugins: [ // ... 一些插件配置 new HappyPack(&#123; //用id来标识 happypack处理那里类文件 id: 'happyBabel', //如何处理 用法和loader 的配置一样 loaders: [&#123; loader: 'babel-loader?cacheDirectory=true', &#125;], //共享进程池 threadPool: happyThreadPool, //允许 HappyPack 输出日志 verbose: true, &#125;) ]&#125; 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块作用:优化打包速度 因此我们首先需要在我们的项目根目录下创建一个 webpack.dll.config.js 文件。然后配置代码如下： 123456789101112131415161718192021222324252627282930313233343536const path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = &#123; // 入口文件 entry: &#123; // 项目中用到该两个依赖库文件 jquery: ['jquery'], echarts: ['echarts'] &#125;, // 输出文件 output: &#123; // 文件名称 filename: '[name].dll.js', // 将输出的文件放到dist目录下 path: path.resolve(__dirname, 'dist'), /* 存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll 是为了防止全局变量冲突。 */ library: '_dll_[name]' &#125;, plugins: [ // 使用插件 DllPlugin new DllPlugin(&#123; /* 该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。 比如在jquery.manifest文件中有 name: '_dll_jquery' */ name: '_dll_[name]', /* 生成manifest文件输出的位置和文件名称 */ path: path.join(__dirname, 'dist', '[name].manifest.json') &#125;) ]&#125;; 在webpack.config.js中配置它: 1234567891011121314151617// 引入 DllReferencePluginconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');// 使用插件module.exports = &#123; plugins: [ // 告诉webpack使用了哪些第三方库代码 new DllReferencePlugin(&#123; // jquery 映射到json文件上去 manifest: require('./dist/jquery.manifest.json') &#125;), new DllReferencePlugin(&#123; // echarts 映射到json文件上去 manifest: require('./dist/echarts.manifest.json') &#125;) ]&#125; 执行构建： 最后一步就是构建代码了，先生存第三方库文件，因此我们运行如下命令： 1webpack --config webpack.dll.config.js 在package.json中添加如下代码: 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline&quot;, &quot;build&quot;: &quot;webpack --progress --colors --devtool cheap-module-source-map&quot;, &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js&quot;&#125;, 最后运行npm run build:dll打包即可 按需引入组件实现优化打包体积如果只需要一个库的一部分功能，尽量按需导入而不是使用 Vue.use(Plugin)","categories":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://haoge744.github.io/tags/webpack/"}]},{"title":"vue性能优化9法","slug":"vue性能优化","date":"2019-09-01T08:46:07.000Z","updated":"2019-09-01T10:58:14.360Z","comments":true,"path":"2019/09/01/vue性能优化/","link":"","permalink":"https://haoge744.github.io/2019/09/01/vue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"在2019年3月VueConf US大会上，有人分享了一个Vue性能优化9法的相关演讲，在此和大家分享。 演讲视频 http://www.youtube.com/watch?v=5B66qer8cZo 演讲稿 https://slides.com/akryum/vueconfus-2019#/ 演示网站 https://vue-9-perf-secrets.nettlify.com 演示代码 https://github.com/Akryum/vue-9-perf-secrets","text":"在2019年3月VueConf US大会上，有人分享了一个Vue性能优化9法的相关演讲，在此和大家分享。 演讲视频 http://www.youtube.com/watch?v=5B66qer8cZo 演讲稿 https://slides.com/akryum/vueconfus-2019#/ 演示网站 https://vue-9-perf-secrets.nettlify.com 演示代码 https://github.com/Akryum/vue-9-perf-secrets 函数型组件优化前 1234567891011&lt;template&gt; &lt;div class=\"cell\"&gt; &lt;div v-if=\"value\" class=\"on\"&gt;&lt;/div&gt; &lt;section v-else class=\"off\"&gt;&lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; props:['value'] &#125;&lt;/script&gt; 优化后 123456789101112&lt;template functional&gt; &lt;div class=\"cell\"&gt; &lt;div v-if=\"props.value\" class=\"on\"&gt;&lt;/div&gt; &lt;section v-else class=\"off\"&gt;&lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['value']&#125;&lt;/script&gt; 可以看到两段代码的不同仅仅是 template标签加了一个functional属性，加了这个属性有什么用呢，就是把当前组件变成函数组件，他的一系列生命周期的钩子方法不会调用。省去了这些钩子后，性能将会得到优化。 子组件拆分优化前 1234567891011121314&lt;template&gt; &lt;div :style=\"&#123; opacity: number / 300 &#125;\"&gt; &lt;div&gt;&#123;&#123; heavy() &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['number'], methods: &#123; heavy () &#123; /* 非常耗时，计算量大的处理 */ &#125; &#125;&#125;&lt;/script&gt; 优化后 123456789101112131415161718192021&lt;template&gt; &lt;div :style=\"&#123; opacity: number / 300 &#125;\"&gt; &lt;ChildComp/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['number'], components: &#123; ChildComp: &#123; methods: &#123; heavy () &#123; /* 耗时计算逻辑放到子组件当中 */ &#125; &#125;, render (h) &#123; return h('div', this.heavy()) &#125; &#125; &#125;&#125;&lt;/script&gt; 在主组件当中把一个非常耗时耗性能的处理仅仅放在method中，那么每次组件更新时，都会重新调用一下，这样非常耗性能。那么优化之后，把耗时的逻辑放到了子组件中，那么主组件更新，也不会重新计算，提高了性能。 局部变量优化前 123456789101112131415161718192021&lt;template&gt; &lt;div :style=\"&#123; opacity: start / 300 &#125;\"&gt;&#123;&#123; result &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; heavy &#125; from '@/utils'export default &#123; props: ['start'], computed: &#123; base () &#123; return 42 &#125;, result () &#123; let result = this.start for (let i = 0; i &lt; 1000; i++) &#123; result += heavy(this.base) // 每次调用计算属性 &#125; return result &#125; &#125;&#125;&lt;/script&gt; 优化后 1234567891011121314151617181920212223&lt;template&gt; &lt;div :style=\"&#123; opacity: start / 300 &#125;\"&gt; &#123;&#123; result &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; heavy &#125; from '@/utils'export default &#123; props: ['start'], computed: &#123; base () &#123; return 42 &#125;, result () &#123; const base = this.base // 先声明一个常量， let result = this.start for (let i = 0; i &lt; 1000; i++) &#123; result += heavy(base)// 每次计算时使用常量 &#125; return result &#125; &#125;&#125;&lt;/script&gt; 这个例子比较简单，在循环中处理比较复杂的逻辑时，推荐先声明常量，然后每次计算时用常量而不是计算属性。 活用v-show,减少v-if优化前 12345678910&lt;template functional&gt; &lt;div class=\"cell\"&gt; &lt;div v-if=\"props.value\" class=\"on\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/div&gt; &lt;section v-else class=\"off\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; 优化后 12345678910&lt;template functional&gt; &lt;div class=\"cell\"&gt; &lt;div v-show=\"props.value\" class=\"on\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/div&gt; &lt;section v-show=\"!props.value\" class=\"off\"&gt; &lt;Heavy :n=\"10000\"/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; 这个也很简单，v-if显示和隐藏时，是删除和新增dom，而v-show是控制dom的css来隐藏显示，所以隐藏显示频繁的组件最好用v-show。 使用keep-alive优化前 12345&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 优化后 1234567&lt;template&gt; &lt;div id=\"app\"&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 保持页面cache，提高页面加载效率 活用延迟装载(Defer)优化前 123456789&lt;template&gt; &lt;div&gt; &lt;h2&gt;I'm an heavy page&lt;/h2&gt; &lt;Heavy v-for=\"n in 10\" :key=\"n\"/&gt; &lt;Heavy class=\"super-heavy\" :n=\"9999999\"/&gt; &lt;/div&gt;&lt;/template&gt; 优化后 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;h2&gt;I'm an heavy page&lt;/h2&gt; &lt;template v-if=\"defer(2)\"&gt; &lt;Heavy v-for=\"n in 10\" :key=\"n\"/&gt; &lt;/template&gt; &lt;Heavy v-if=\"defer(3)\" class=\"super-heavy\" :n=\"9999999\"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Defer from '@/mixins/Defer'export default &#123; mixins: [ Defer() ]&#125;&lt;/script&gt; 延迟加载各组件，使用户感觉界面加载流畅 123456789101112131415161718192021222324252627282930313233// Defer.jsexport default function (count = 10) &#123; // @vue/component return &#123; data () &#123; return &#123; displayPriority: 0, &#125; &#125;, mounted () &#123; this.runDisplayPriority() &#125;, methods: &#123; runDisplayPriority () &#123; const step = () =&gt; &#123; requestAnimationFrame(() =&gt; &#123; this.displayPriority++ if (this.displayPriority &lt; count) &#123; step() &#125; &#125;) &#125; step() &#125;, defer (priority) &#123; return this.displayPriority &gt;= priority &#125;, &#125;, &#125;&#125; 分批处理(Time Sicing)优化前 1234fetchItems (&#123; commit &#125;, &#123; items &#125;) &#123; commit('clearItems') commit('addItems', items)&#125; 优化后 12345678910111213141516fetchItems (&#123; commit &#125;, &#123; items, splitCount &#125;) &#123; commit('clearItems') const queue = new JobQueue() splitArray(items, splitCount).forEach( chunk =&gt; queue.addJob(done =&gt; &#123; // Commit array chunks on several frames requestAnimationFrame(() =&gt; &#123; commit('addItems', chunk) done() &#125;) &#125;) ) // Start and wait for all the jobs // to finish await queue.start()&#125; 未优化时，同时处理两个提交操作，操作效率慢，把任务分成块执行，按顺序执行，提高渲染性能 非相应模式(non-reactive)优化前 1234567const data = items.map( item =&gt; (&#123; id: uid++, data: item, vote: 0 &#125;)) 优化后 12345678910111213141516const data = items.map( item =&gt; optimizeItem(item))function optimizeItem (item) &#123; const itemData = &#123; id: uid++, vote: 0 &#125; Object.defineProperty(itemData, 'data', &#123; // Mark as non-reactive configurable: false, value: item &#125;) return itemData&#125; 在上面，使用map方法来遍历更改对象，每次在循环中赋值时，会改变原对象。并且会触发vue的监视机制从而更新组件。在优化之后，取消了vue对itemData对象的观察，这样不会触发多余的监视方法。从而提高了效率。 仅渲染可视化部分优化前 12345678&lt;div class=\"items no-v\"&gt; &lt;FetchItemViewFunctional v-for=\"item of items\" :key=\"item.id\" :item=\"item\" @vote=\"voteItem(item)\" /&gt;&lt;/div&gt; 优化后 123456789101112&lt;recycle-scroller class=\"items\" :items=\"items\" :item-size=\"24\"&gt; &lt;template v-slot=\"&#123; item &#125;\"&gt; &lt;FetchItemView :item=\"item\" @vote=\"voteItem(item)\" /&gt; &lt;/template&gt;&lt;/recycle-scroller&gt; 优化前:一下就选软所有数据项。优化后：只渲染24个组件，只渲染用户能看到的数据。提高渲染性能。 总结对于简单的页面，可以忽略优化细节，重点可以放在功能实现上，尤其在工期紧张的时候。而对于页面复杂，计算逻辑过多的应用时，应该充分考虑使用优化技巧。不过在时间充足的情况下，可以考虑把性能以及资源加载这部分优化到极致，这不但使应用变得更好，对自己更是一个提升。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"vue中使用stylus","slug":"vue中使用stylus","date":"2019-08-29T05:38:03.000Z","updated":"2019-08-29T05:55:07.088Z","comments":true,"path":"2019/08/29/vue中使用stylus/","link":"","permalink":"https://haoge744.github.io/2019/08/29/vue%E4%B8%AD%E4%BD%BF%E7%94%A8stylus/","excerpt":"介绍stylus是css的预处理框架。和Sass、Less是一类东西。在stylus中可以 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件。","text":"介绍stylus是css的预处理框架。和Sass、Less是一类东西。在stylus中可以 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件。 安装1cnpm install stylus stylus-loader --save-dev 在组件中使用执行完安装命令之后不需要任何配置就可以使用了。 在组件中使用只要把在style标签中增加lang=&quot;stylus&quot;就可以用了 在vue文件中引用12345&lt;style lang=\"stylus\"&gt; @import \"assets/common.styl\"; .main_wrapper padding 12 20px&lt;/style&gt; stylus 编码风格123456789101112131415161718$shadow = 0px 3px 6px -2px rgba(0,0,0,0.3)// mixinsflexvc() display flex items-align center// methodadd (a,b = 10) a + b // 函数可省略返回值.card.card2 box-shadow $shadow &amp;:hover background-color #F4F5F6 .footer border-top #ededef 可以看到stylus的写法非常简洁，层级关系使用缩进来表示，分号、冒号、大括号都是可选项，可写可不写。 使用语法 选择器stylus选择器规则和css一样.class选择、#id选择、[type=textarea]属性选择器等等 12p color #f00 编译后 123p&#123; color: #f00;&#125; 多个选择器共用 12345.card,.boxor .card.box box-shadow 0px 3px 6px -2px rgba(0,0,0,0.3) 父级引用,stylus中使用&amp;指向父选择器，可以用来做各种伪类选择器，伪元素等等 1234567li background-color #F3F4F5 border-bottom 1px solid #f4f5f6 &amp;:hover background-color #ccc &amp;:last-child border-bottom none 变量 123primary-bg = #3A75E7.main_wrapper background-color primary-bg 标识符（变量名，函数等），也可能包括$字符。例如： 123$font-size = 14pxp font-size $font-size 属性查找 Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下： 12345678#logo position: absolute top: 50% left: 50% width: w = 150px height: h = 80px margin-left: -(w / 2) margin-top: -(h / 2) 我们不使用这里的变量w和h, 而是简单地前置@字符在属性名前来访问该属性名对应的值： 12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 函数一个简单的函数 1234add(a,b) a + b // 省略returnbody padding add(10px, 5) 默认参数 123456add(a, b =a) a = unit(a, px) // unit把单位都变成px b = unit(b, px) a + badd(15%, 10deg) // =&gt; 25 多个返回值 123456paddings() 25px 12px.main padding paddings() // 编译后 =&gt; padding: 25px 12px; 混合混合和函数定义差不多，但是效果不一样。函数有返回值，混合没有。比如我们想定义一个垂直居中的横向flex布局可以像下面这样: 12345flexvc() display flex align-items center.main-list flexvc() 父级引用比如说我们想创建一个条纹表格,even和odd均提供了默认颜色值，每行也指定了background-color属性。我们可以在tr嵌套中使用&amp;来引用tr，以提供even颜色。 123456stripe(even = #fff, odd = #eee) tr background-color odd &amp;.even &amp;:nth-child(even) background-color even 然后利用混合书写,如下: 1234567table stripe()table#data-grid stripe(#212121, #494848) td color white 插值 Stylus支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。例如，-webkit-{&#39;border&#39; + &#39;-radius&#39;}等同于-webkit-border-radius. 比较好的例子就是私有前缀属性扩展： 1234vendor(prop, args) &#123;prop&#125; args.well border-radius 4px 选择器插值 1234table for row in 1 2 3 4 5 tr:nth-child(&#123;row&#125;) height: 10px * row 编译后 123456789101112131415table tr:nth-child(1) &#123; height: 10px;&#125;table tr:nth-child(2) &#123; height: 20px;&#125;table tr:nth-child(3) &#123; height: 30px;&#125;table tr:nth-child(4) &#123; height: 40px;&#125;table tr:nth-child(5) &#123; height: 50px;&#125; 注释 单行注释 1// 单行注释 多行注释 123/* * 多行注释 */ 总结总的来说写法和很多css预处理语言很相似，但是stylus写法更简洁一些，入门也更简单。上面介绍到的功能和用法能满足大部分日常使用需要了。如果还需了解的更加深入的话可以去读下这份文档。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"h5常用新元素","slug":"h5常用新元素","date":"2019-08-25T13:49:03.000Z","updated":"2019-08-25T13:49:03.000Z","comments":true,"path":"2019/08/25/h5常用新元素/","link":"","permalink":"https://haoge744.github.io/2019/08/25/h5%E5%B8%B8%E7%94%A8%E6%96%B0%E5%85%83%E7%B4%A0/","excerpt":"过去的标签书写习惯了，其实有些更有语义化的标签可以代替div、span这些标签的。","text":"过去的标签书写习惯了，其实有些更有语义化的标签可以代替div、span这些标签的。 语义与结构元素: 标签 描述 定义了文档的头部区域 定义导航链接的部分 定义文档或节的页脚 底部 定义文章。潜在来源:论坛帖子、博客文章、新闻故事、评论 定义文档中的节（section、区段） 定义其所处内容之外的内容 侧边(侧边栏或者侧边菜单用的较多) 定义带有记号的文本。 定义日期或时间。(可以用来标记时间，行内元素，无任何样式) 规定独立的流内容（图像、图表、照片、代码等等）。(经常用于展示图片，和figcaption配合的多) 定义 元素的标题 多媒体元素 标签 描述 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API 定义音频内容 定义视频（video 或者 movie） 定义多媒体资源 和 定义嵌入的内容，比如插件。 为诸如 和 元素之类的媒介规定外部文本轨道。","categories":[{"name":"html","slug":"html","permalink":"https://haoge744.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://haoge744.github.io/tags/html/"}]},{"title":"vue自定义指令实现功能级权限","slug":"vue自定义指令实现功能级权限","date":"2019-08-24T01:00:31.000Z","updated":"2019-08-26T15:10:11.487Z","comments":true,"path":"2019/08/24/vue自定义指令实现功能级权限/","link":"","permalink":"https://haoge744.github.io/2019/08/24/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%BA%A7%E6%9D%83%E9%99%90/","excerpt":"自定义指令使用介绍在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。 自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。","text":"自定义指令使用介绍在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。 自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 钩子函数参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 功能实现权限的获取是在登录时获取，获取完之后缓存至cookie和vuex中，防止用户刷新后出现的问题。然后每次刷新初始化时尝试从cookie中取出权限项再次放入vuex。 123456789101112131415161718// store/morules/user.js 用户存储的状态信息import &#123;setRoles, getRoles&#125; from '@/utils/cookieHelper'import Vue from 'vue'const user = &#123; state: &#123; roles: getRoles() &#125;, mutations: &#123; SET_ROLES: (state, val) =&gt; &#123; setRoles(state, val) Vue.set(state,'roles', val) &#125; &#125;, actions: &#123; &#125;&#125;export default user 12345678910111213141516// cookieHelper.js import Cookies from 'js-cookie' // cookie存取使用了js-cookie的组件export function setRoles (roles) &#123; return Cookies.set('roles', roles.split())&#125;export function getRoles () &#123; // const roleStr = Cookies.get('roles') const roleStr = 'admin' // 先写死一个变量 利于测试 if (roleStr) &#123; return roleStr.split(',') &#125; else &#123; return [] &#125;&#125; 实现自定义指令功能1234567891011121314151617181920212223// 新建 directive/auth.jsimport Vue from 'vue'import store from '../store'Vue.directive('permission', &#123; inserted: (el, binding) =&gt; &#123; // 如果使用bind钩子会找不到父元素 const &#123; value &#125; = binding let hasPermission = false const myRoles = store.getters.roles if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0)&#123; hasPermission = value.some(item =&gt; &#123; return myRoles.includes(item) &#125;) &#125;else &#123; throw new Error('参数错误') &#125; if(!hasPermission)&#123; // 没有权限移除该元素 el.parentNode.removeChild(el) &#125; &#125;&#125;) 123 // 在main.js中引入auth.js// 测试成功后，把cookieHelper中的返回的权限改为其他值后，按钮隐藏了&lt;el-button v-permission=\"['add', 'admin']\"&gt;添加&lt;/el-button&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"filco入手评测","slug":"filco入手评测","date":"2019-08-15T12:59:39.000Z","updated":"2019-09-01T14:22:40.853Z","comments":true,"path":"2019/08/15/filco入手评测/","link":"","permalink":"https://haoge744.github.io/2019/08/15/filco%E5%85%A5%E6%89%8B%E8%AF%84%E6%B5%8B/","excerpt":"使用感受话说花一千多块买一把键盘到底值不值？不过我为了体验顶级键盘的手感，还是忍痛割爱了。说实话这款键盘我早就看中了，犹豫了很久。最后还是没忍住哈哈。对于程序猿这种重度使用键盘的人群，给自己一把好一点的键盘，我觉得也是可以奖励给自己的啊。毕竟时不时给自己一个小礼物，有助于提升自己的幸福感呢。 包装图","text":"使用感受话说花一千多块买一把键盘到底值不值？不过我为了体验顶级键盘的手感，还是忍痛割爱了。说实话这款键盘我早就看中了，犹豫了很久。最后还是没忍住哈哈。对于程序猿这种重度使用键盘的人群，给自己一把好一点的键盘，我觉得也是可以奖励给自己的啊。毕竟时不时给自己一个小礼物，有助于提升自己的幸福感呢。 包装图 包装中规中矩吧，上面也显示支持有线和蓝牙连接，赠送了一个拔键器、防尘罩、两节电池、还有两个键帽，这个待会再说有什么用。 键盘整体图 从外观上说我觉得还可以，没有现在游戏键盘那么多花里胡哨的各种灯，各种特效。我比较喜欢这种稳重的黑，也没有背光灯。给人看起来比较低调。filco采用的是Abs材质的键帽，懂行的可能知道，Abs键帽虽然手感好，但是时间长了之后，键帽容易打油。个人更喜欢Abs的键帽，虽然Pbt的键帽不会打油，但是磨砂的手感完全比不上Abs类肤的手感。尤其是filco，键帽的厚度和大键的手感调试的非常好。大键和小键的手感几乎完全一样，一般中低端的樱桃轴键盘，大键的手感要么很肉，要么给人感觉就像黑轴一样 很硬。filco给人的感觉相当完美。 LOGO特写 由于我买的是青轴，声音非常清脆，打字声音比较大，但还可以接受。另外键盘手感比我的 IKBC DC108好了很多。IKBC给我的感觉有点偏硬了。因为我喜欢桌面整洁，所以选了双模版，这款键盘支持4台设备切换，但是它这个蓝牙连接方式，要看说明书才能学会。另外键盘右下方好像没有菜单键，这时候赠送的键帽就派上用场了，可以把右win换成菜单键，开一下键盘底下的一个开关就好了,然后换一下键帽，完美。 总结根据这几个星期的使用感受，我总结了以下优缺点：优点： 手感。filco的手感一直是它最大的卖点，这点我非常满意。 双模 没有线的束缚，如果再配上一个无线鼠标，简直爽的一批。 设计 键帽整体设计给我感觉落落大方，键帽的字体我也很喜欢，还有就是右上角雕刻的LOGO，设计也很棒。 缺点： 贵。 键帽易打油，这是Abs通用的缺点，使用1至2年就需要更换键帽了。","categories":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}],"tags":[{"name":"生活记事","slug":"生活记事","permalink":"https://haoge744.github.io/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E4%BA%8B/"}]},{"title":"v-slot的使用","slug":"v-slot的使用","date":"2019-08-12T15:00:37.000Z","updated":"2019-08-26T15:05:13.003Z","comments":true,"path":"2019/08/12/v-slot的使用/","link":"","permalink":"https://haoge744.github.io/2019/08/12/v-slot%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"v-slot介绍vue2.6.x开始，vue为具名和范围插槽引入了一个全新的语法,即v-slot。目的就是想统一slot和scope-slot语法，使代码更加规范和清晰。 还在2.5.x的小伙伴注意v-slot只支持在vue2.6以上使用，想用的同学请先升级版本哦。 我们看看v-slot和之前的语法区别吧。","text":"v-slot介绍vue2.6.x开始，vue为具名和范围插槽引入了一个全新的语法,即v-slot。目的就是想统一slot和scope-slot语法，使代码更加规范和清晰。 还在2.5.x的小伙伴注意v-slot只支持在vue2.6以上使用，想用的同学请先升级版本哦。 我们看看v-slot和之前的语法区别吧。 局名插槽12345678910111213&lt;!-- base-layout.vue -- &gt;&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 使用 1234567891011&lt;!-- 过时语法 --&gt;&lt;base-layout&gt; &lt;template slot=\"header\"&gt; &lt;h1&gt;ssss&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;12125125&lt;p&gt; &lt;p&gt;198248924&lt;/p&gt; &lt;template slot=\"footer\"&gt; &lt;p&gt;Some Description&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 使用v-slot指令改写: 12345678910111213&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;title&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; or &lt;template v-slot:default&gt; &lt;&#x2F;template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;&#x2F;base-layout&gt; 作用域插槽:12345&lt;!-- 首先定义绑定对象 --&gt;&lt;span&gt; &lt;slot v-bind:user&#x3D;&quot;user&quot;&gt; &lt;&#x2F;slot&gt;&lt;&#x2F;span&gt; 123456&lt;!-- 过时语法 --&gt;&lt;slot-example&gt; &lt;template slot-scope&#x3D;&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.name &#125;&#125; &lt;&#x2F;template&gt;&lt;&#x2F;slot-example&gt; 12345678910111213141516&lt;!-- v-slot的写法 --&gt;&lt;slot-example&gt; &lt;template v-slot&#x3D;&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.name &#125;&#125; &lt;&#x2F;template&gt;&lt;&#x2F;slot-example&gt;&lt;!-- 可解构赋值改写成以下内容 --&gt;&lt;slot-example&gt; &lt;template v-slot&#x3D;&quot;&#123;user&#125;&quot;&gt; &#123;&#123; user.name &#125;&#125; &lt;&#x2F;template&gt;&lt;&#x2F;slot-example&gt;&lt;!-- 可以给结构变量赋默认值,防止未定义 --&gt;v-slot&#x3D;&quot;&#123;user &#x3D; &#123;name: &#39;ghost&#39;&#125; &#125;&quot; 简写形式事件绑定和数据绑定使用的是@和:，v-slot推出后也有一个简写符号，即使用# 代替v-slot例如 12345678910111213&lt;base-layout&gt; &lt;template #header&gt; &lt;h1&gt;title&lt;&#x2F;h1&gt; &lt;&#x2F;template&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; or &lt;template #default&gt; &lt;&#x2F;template&gt; &lt;template #footer&gt; &lt;p&gt;some content&lt;&#x2F;p&gt; &lt;&#x2F;template&gt;&lt;&#x2F;base-layout&gt; 然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的： 1234&lt;!-- 这样会触发一个警告 --&gt;&lt;current-user #&#x3D;&quot;&#123; user &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125;&lt;&#x2F;current-user&gt; 如果你希望使用缩写的话，你必须始终以明确插槽名取而代之： 123&lt;current-user #default=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 实际使用接下来写一个导航组件，每个导航可能会有图标或者badge，这个实际使用要看后台数据。首先先写两个组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!-- NavList.vue 导航的父组件 --&gt;&lt;template&gt; &lt;nav class&#x3D;&quot;nav_wrapper&quot;&gt; &lt;!-- 循环迭代导航列表，默认只显示导航的名称 --&gt; &lt;slot v-for&#x3D;&quot;item in navList&quot; v-bind:item&#x3D;&quot;item&quot;&gt; &lt;NavItem&gt; &#123;&#123; item.name &#125;&#125; &lt;&#x2F;NavItem&gt; &lt;&#x2F;slot&gt; &lt;&#x2F;nav&gt;&lt;&#x2F;template&gt;&lt;script&gt;import NavItem from &#39;.&#x2F;NavItem&#39;export default &#123; components: &#123; NavItem &#125;, props: &#123; navList: &#123; required: true, type: Array &#125; &#125;, name: &#39;NavList&#39;&#125;&lt;&#x2F;script&gt;&lt;style scoped lang&#x3D;&quot;stylus&quot;&gt;.nav_wrapper background-color #545c64 color white display flex flex-flow row nowrap padding 0px 40px height 40px align-items stretch &amp; &gt;&gt;&gt; .nav_item &#x2F;&#x2F; 让子组件的css生效 text-decoration none padding 0 40px cursor: pointer display flex align-items center &amp;:hover background-color black &amp; &gt;&gt;&gt; .nav_item_icon img &lt;!-- 给子组件的导航图标设置的样式 --&gt; width 30px height 30px display flex align-items center margin-right 10px&lt;&#x2F;style&gt; 1234567891011121314151617181920&lt;!-- 导航的子组件 NavItem.vue --&gt;&lt;template&gt; &lt;a class&#x3D;&quot;nav_item&quot;&gt; &lt;!-- 导航的图标,默认没有, 在slot标签上设置class不生效,所以用span包裹一下 --&gt; &lt;span class&#x3D;&quot;nav_item_icon&quot;&gt; &lt;slot name&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;span&gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;slot name&#x3D;&quot;badge&quot; class&#x3D;&quot;nav_item_badge&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;a&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;NavItem&#39;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt; 两个相互搭配的组件写好了，接下来开始使用了: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;NavList :navList&#x3D;&quot;navList&quot;&gt; &lt;template v-slot&#x3D;&quot;&#123;item&#125;&quot;&gt; &lt;NavItem&gt; &lt;!-- 菜单项中有图标则显示、没有则隐藏 --&gt; &lt;template v-slot:icon v-if&#x3D;&quot;item.icon&quot;&gt; &lt;img :src&#x3D;&quot;item.icon&quot; alt&#x3D;&quot;&quot; &gt; &lt;&#x2F;template&gt; &#123;&#123; getName(item) &#125;&#125; &lt;!-- 菜单项中有badge则显示、没有则隐藏 --&gt; &lt;template v-slot:badge v-if&#x3D;&quot;item.badge&quot;&gt; &lt;!-- badge的样式是在父组件中定义的， --&gt; &lt;span class&#x3D;&quot;nav_item_badge&quot;&gt; &#123;&#123; item.badge &#125;&#125; &lt;&#x2F;span&gt; &lt;&#x2F;template&gt; &lt;&#x2F;NavItem&gt; &lt;&#x2F;template&gt; &lt;&#x2F;NavList&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import NavList from &#39;@&#x2F;components&#x2F;NavList&#39;import NavItem from &#39;@&#x2F;components&#x2F;NavItem&#39;export default &#123; name: &#39;index&#39;, components: &#123; NavList, NavItem &#125;, data () &#123; return &#123; navList: [&#123; &#x2F;&#x2F; 导航菜单的列表 name: &#39;home&#39;, icon: require(&#39;..&#x2F;..&#x2F;assets&#x2F;icon.png&#39;) &#125;,&#123; name: &#39;news&#39;, badge: 2 &#125;,&#123; name: &#39;tags&#39; &#125;,&#123; name: &#39;about&#39;, icon: require(&#39;..&#x2F;..&#x2F;assets&#x2F;logo.png&#39;), badge: 3 &#125;] &#125; &#125;, methods: &#123; getName (item) &#123; return item.name.toUpperCase() &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped lang&#x3D;&quot;stylus&quot;&gt; .nav_item_badge width 10px height 10px padding 5px display flex align-items center justify-content center margin-top -12px margin-left 4px font-size 10px border-radius 50% background-color red color: white&lt;&#x2F;style&gt; 效果如下: 可能样式不是很完美，但是今天主题还是v-slot, 为什么不在NavItem里设置badge的样式呢？这是因为badge的宽高设定之后，父组件无法控制其隐藏。我目前暂时没有想到好的办法。另外本身badge这个东西也应该封装成一个组件的，如果在子组件里写死了那么久丧失了灵活性。另外这个导航本身实际项目中应该不会这样写，这只是一个v-slot的使用样例，仅供参考。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"echarts地图钻取位置异常的解决办法","slug":"echarts地图钻取位置异常的解决办法","date":"2019-08-08T15:41:16.000Z","updated":"2019-08-15T10:24:29.904Z","comments":true,"path":"2019/08/08/echarts地图钻取位置异常的解决办法/","link":"","permalink":"https://haoge744.github.io/2019/08/08/echarts%E5%9C%B0%E5%9B%BE%E9%92%BB%E5%8F%96%E4%BD%8D%E7%BD%AE%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"因为有需求要做一个中国地图下钻到市的功能，但是在钻取中放大的时候碰到了地图位置显示异常的问题，切换地图的时候偶尔会出现地图找不到的问题，如下图:","text":"因为有需求要做一个中国地图下钻到市的功能，但是在钻取中放大的时候碰到了地图位置显示异常的问题，切换地图的时候偶尔会出现地图找不到的问题，如下图: 地图下钻逻辑，初始化的时候缓存全国的地图，省的多次加载，我这里实现echarts下钻的核心方法是 registerMap(mapName,geoJson,specialAreas)作用是向echarts内注册一个地图，这个地图的第一个参数是地图名字，可以自定义，第二个是geoJson，可以自己画geojson的数据也可以在echarts的github地址里找到关于中国省市区的地图数据(echarts官网已经下载不了了),访问这个链接可以下载到。第三个是可选参数，具体参考文档。 在官网上看到了地图的series中可以设置center参数，然后在地图json中看到了每个城市也有经纬度的数据所以可以每次钻取的时候给series设置当前城市的中心点来避免问题发生。 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109export default &#123; // ... somecode methods: &#123; // ...somecode init () &#123; // 地图初始化，把画布大小调整为全屏以及注册点击事件 const dom = document.getElementById('map-wrapper') dom.style.width = document.body.clientWidth + 'px' dom.style.height = document.body.clientHeight + 'px' this.chartInstance = echarts.init(dom) this.chartInstance.on('click', this.chartClickHandler) &#125;, chartClickHandler (params) &#123; // 地图点击事件 if (params.name in provinces) &#123; // 点省级或者直辖市 if (special.indexOf(params.name) &gt;= 0) &#123; this.$toast('直辖市不支持放大') return &#125; this.isNational = false const key = provinces[params.name] const name = params.name this.$toast.loading(&#123; mask: true, duration: 0 &#125;) // 请求static路径下城市的geoJSON.json数据 getMapJson(`./static/map/province/$&#123;key&#125;.json`).then(async response =&gt; &#123; let cityData = [] let cityMap = &#123;&#125; console.log(response.data.features[0].properties.name) const lat = response.data.features[0].properties.cp // 获取json里第一个城市的经纬度 response.data.features.forEach(item =&gt; &#123; // 没有数据的展示零 cityMap[item.properties.name] = 0 &#125;) try &#123; if (this.provIdKeyMap.get(name)) &#123; // 根据省的id拿到后台数据展示 let cData = await getCityData(this.provIdKeyMap.get(name).split('_')[0]) // 根据省id 获取市的数据 if (cData.status === 200) &#123; cData.data.forEach(item =&gt; &#123; cityMap[item.cityname] = item.ftreermb &#125;) &#125; &#125; this.$toast.clear() &#125; catch (error) &#123; this.$toast('加载地图数据失败') &#125; for (let a in cityMap) &#123; // 遍历组装所有市的数据 let showLabel = cityMap[a] ? true : false cityData.push(&#123; name: a, value: cityMap[a], label: &#123; show: showLabel &#125; &#125;) &#125; echarts.registerMap(name, response.data) // 注册地图 this.renderMap(name, cityData, lat) // 渲染 &#125;) &#125; else &#123; this.isNational = true this.renderMap('china', this.nationalData) &#125; &#125;, // 渲染地图 renderMap (map, data, lat = [103.754, 34.452]) &#123; // 地图名字, 数据, 经纬度 this.$set(this.option.title, 'subtext', map) const series = [&#123; name: map, type: 'map', mapType: map, roam: true, zoom: 2, nameMap: &#123;'china': '中国'&#125;, left: 20, top: '30%', center: lat, // 设置中心点 默认中国的中心点 showLegendSymbol: false, label: &#123; normal: &#123; show: true, textStyle: &#123;color: '#000', fontSize: 14&#125; &#125;, emphasis: &#123; show: true, textStyle: &#123;color: '#999', fontSize: 14&#125; &#125; &#125;, itemStyle: &#123; normal: &#123; areaColor: '#E6E6FA', borderColor: 'dodgerblue', label: &#123; show: true, formatter: '&#123;b&#125;\\n&#123;c&#125; ' &#125;&#125;, emphasis: &#123; areaColor: 'darkorange' &#125; &#125;, data: data &#125;] //设置option this.$set(this.option, 'series', series) this.chartInstance.setOption(this.option) &#125; &#125;&#125; 完成后效果如下: 不显示数据为零的地名series里的data也可以设置label的样式和隐藏显示,设置标签位置等等等。详细配置请访问链接 1234567&#123; name: a, value: cityMap[a], label: &#123; show: showLabel // 判断数据是否为空或者零 &#125;&#125;","categories":[{"name":"echarts","slug":"echarts","permalink":"https://haoge744.github.io/categories/echarts/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://haoge744.github.io/tags/echarts/"},{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"vue项目使用lottie动画","slug":"vue项目使用lottie动画","date":"2019-08-08T14:45:51.000Z","updated":"2019-08-09T09:31:24.485Z","comments":true,"path":"2019/08/08/vue项目使用lottie动画/","link":"","permalink":"https://haoge744.github.io/2019/08/08/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8lottie%E5%8A%A8%E7%94%BB/","excerpt":"Lottie是一个开源动画框架，支持Android，IOS，ReactNative以及web开发，这篇文章主要讲Lottie在vue项目中如何使用。GitHub地址,我在官方社区看了一下，交互性非常好，动画支持倍速播放，倒放，暂停等功能，能熟练使用的话，交互性能提升很多。 安装在安装目录执行以下命令: 1npm install --save vue-lottie","text":"Lottie是一个开源动画框架，支持Android，IOS，ReactNative以及web开发，这篇文章主要讲Lottie在vue项目中如何使用。GitHub地址,我在官方社区看了一下，交互性非常好，动画支持倍速播放，倒放，暂停等功能，能熟练使用的话，交互性能提升很多。 安装在安装目录执行以下命令: 1npm install --save vue-lottie 使用准备好动画json文件。可以让UI处理好: UI使用AE–安装bodymovin插件-将AE中的动画工程文件通过bodymovin转换为.json文件–发给开发-开发集成Lottie框架-直接在项目中使用。 或者是在官方库里找:链接。 具体代码: 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;Lottie :options=\"defaultOptions\" v-on:animCreated=\"handleAnimation\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Lottie from 'vue-lottie'// 引用动画json文件，在官网下载的。import * as animeData from '../assets/anime.json'export default &#123; name: 'animate', components: &#123; Lottie &#125;, data () &#123; return &#123; // ... some code defaultOptions:&#123; animationData: animeData &#125; &#125; &#125;, methods: &#123; handleAnimation: function (anim) &#123; this.anim = anim &#125; &#125;&#125;&lt;/script&gt;&lt;style scope&gt; ...some code&lt;/style&gt; 效果: 常用配置:以上配置只用到了animationData,下面列出一些常用的，更多配置项请在该链接中查看 animationData: 动画json path: 可直接指定动画json // 路径 loop: true / false / number //循环 autoplay: true / false // 自动播放 name: // 给动画取名字,方便方法调用 renderer: ‘svg’ / ‘canvas’ / ‘html’ //渲染方式 container: the dom element on which to render the animation // 可直接指定dom节点渲染","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"},{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"uni随手笔记一","slug":"uni随手笔记一","date":"2019-08-04T07:34:44.000Z","updated":"2019-08-23T07:45:11.611Z","comments":true,"path":"2019/08/04/uni随手笔记一/","link":"","permalink":"https://haoge744.github.io/2019/08/04/uni%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0%E4%B8%80/","excerpt":"自己看官方文档做的一些笔记，记了一些和vue差异的地方和印象较深的地方。看看就好哈哈。","text":"自己看官方文档做的一些笔记，记了一些和vue差异的地方和印象较深的地方。看看就好哈哈。 编写uni注意事项用uni-app想兼容多端，不能使用带dom、window操作的库，并且最好是纯flex布局，如果只开发h5端，推荐还是用vue-cli构建项目。 新老编译模式:12345678在manifast.json中配置&#123; // ... app-plus: &#123; // app h5+相关 usingComponents: true // 如果是true则是自定义组件模式/否则不是 &#125;, wp-wexin: &#123; // 微信小程序相关 &#125;&#125; 最新版本的XHbuilder默认是自定义组件模式不支持v-slot新语法 // vue2.6新增 npm支持情况初始化项目 初始化 package.json文件 npm init -y 安装依赖 npm install packageName –save 使用 package from 'packageName'123const package &#x3D; require(&#39;packageName&#39;)* 注意非H5端不支持使用含有dom、window等操作的vue组件和js模块,安装的模块及其依赖的模块使用的api必须是uni-app已有的api, 说明npm 的插件极其难找* 支持安装 mpvue组件，但npm方式不支持小程序自定义组件(如wxml格式的vant-weapp) 生命周期:全局生命周期: 属性 类型 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当uni-app 启动，或从后台进入前台显示 onHide 当uni-app 从前台进入后台 onUniNViewMessage 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 组建中新增 onBackPress(event) -- 返回 event ={form: backbutton | navigateBack} 自定义返回键可以看这篇文章:http://ask.dcloud.net.cn/article/35120组件生命周期除了vue的基本生命周期额外增加了一些生命周期 建议使用 uni-app 的 onReady代替 vue 的 mounted。 建议使用 uni-app 的 onLoad 代替 vue 的 created。 static 目录下的 js 文件不会被编译，如果里面有 es6 的代码，不经过转换直接运行，在手机设备上会报错。 条件编译及判断运行环境判断开发环境和生产环境: (方便切换生产环境和正式环境 后台url) 123456&#x2F;&#x2F; uEnvDevif(process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;)&#123; console.log(&#39;开发环境&#39;)&#125;else&#123; console.log(&#39;生产环境&#39;)&#125; 平台条件编译 123&#x2F;&#x2F; #ifdef H5 alert(&quot;只有h5平台才有alert方法&quot;)&#x2F;&#x2F; #endif 注意在css或scss等其他样式中，要使用/* #ifdef MP-WEIXIN */代替ifdef的可取值如下 APP-PLUS、APP-PLUS-NVUE（Weex）、H5、MP-WEIXIN、MP-ALIPAY、MP-BAIDU、MP-TOUTIAO、MP-QQ(qq小程序目前仅cli版支持)、MP(非h5和app+/weex) 样式导入:​ 使用@import 语句导入​ @import “../../common/uni.css”;内联样式以及动态样式​ ​ 注意:​ page相当于body节点，例如:​ page { background-color: #ccc } css 内置变量 快捷键heivar(--status-bar-height) //系统状态栏高度 var(--window-top) //内容区域距离顶部的距离 -- NavagationBar的高度 var(--window-bottom) // 内容区域距离底部的距离 -- tabBar的高度注意导航栏和底部选项卡最好用px作为单位 ##注意:背景图片仅支持以 ~@ 开头的绝对路径(不支持相对路径!) 字体图标支持网络路径图标，网络路径必须加协议头httpsvue 使用注意1.1建议使用 uni-app 的 onReady代替 vue 的 mounted。 1.2建议使用 uni-app 的 onLoad 代替 vue 的 created。事件处理: // 事件映射表，左侧为 WEB 事件，右侧为 uni-app 对应事件 12345678910111213141516171819202122&#123; click: 'tap', touchstart: 'touchstart', touchmove: 'touchmove', touchcancel: 'touchcancel', touchend: 'touchend', tap: 'tap', longtap: 'longtap', input: 'input', change: 'change', submit: 'submit', blur: 'blur', focus: 'focus', reset: 'reset', confirm: 'confirm', columnchange: 'columnchange', linechange: 'linechange', error: 'error', scrolltoupper: 'scrolltoupper', scrolltolower: 'scrolltolower', scroll: 'scroll'&#125; 基本元素:uni-app推荐使用view、text等元素替代原来的html元素 用navigator替代 a ,虽然写div或者a之类的h5标签也不影响使用但是推荐按照官方的来 元素 共同属性类型 属性 类型 说明 id String 组件的唯一标示 保持整个页面唯一 class String 组件的样式类 在对应的 css 中定义的样式类 style String 组件的内联样式 可以动态设置的内联样式 hidden Boolean 组件是否隐藏 所有组件默认是显示的 data-* Any 自定义属性 组件上触发的事件时，会发送给事件处理函数 @* EventHandler 组件的事件 详见各组件详细文档，事件绑定参考 事件处理器","categories":[{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/categories/uni-app/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/tags/uni-app/"}]},{"title":"vue3.0 新特性","slug":"vue3-0-新特性","date":"2019-08-01T02:43:33.000Z","updated":"2019-08-26T15:01:10.276Z","comments":true,"path":"2019/08/01/vue3-0-新特性/","link":"","permalink":"https://haoge744.github.io/2019/08/01/vue3-0-%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"目前vue最新的版本是19年2月份发布的2.6.x,更新了一些插槽、动态参数等，据说3.0也会在下半年发布，下面根据尤大的视频分享总结3.0的新特性。","text":"目前vue最新的版本是19年2月份发布的2.6.x,更新了一些插槽、动态参数等，据说3.0也会在下半年发布，下面根据尤大的视频分享总结3.0的新特性。 Vue3.0即将带来哪些新东西: 更快 更小 更易于维护 更好的多端渲染支持 新功能 判断元素是html原生还是组件的时候把这个动作放到了编译时，提高了运行时的性能。跳过不需要的条件判断，生成更易于被JS引擎优化的代码。 优化Slots生成Vue2.0存在父组件更新时，子组件也关联着也更新了。在vue3.0中优化了这一问题。避免不必要的组件渲染。检测组件更新变得更精确。 静态属性提取跳过整块静态内容的更新及时静态内容在列表中被重复也可以生效。跳过单个元素的patch，但依然处理子元素。 主要意思是避免元素不必要的更新。 内联时间函数提取解决组件重新渲染后 再重新创建函数的问题，3.0中第一次创建后会缓存，那么每次重新渲染之后可以避免这个问题。 数据监听改为Proxy之前的数据监听系统是由Object.definedProperty的，3.0中会修改为Proxy提高了性能。再大规模数据监听的情况下，性能提升明显。 据说提升后组件实例初始化效率加倍，内存占用减半 更小代码结构优化和Tree-shaking(把没有用到的代码，在最后编译时给优化掉)配合，减小包的体积。3.0中内置的模块可以按需引入。只引入最基本模块的情况下,依赖包只有10kb左右。 更易于维护对于vue开发团队而言，更易于维护。用TypeScript完全重写vue的源码。并且不影响用户使用。 源码的各个模块更加解耦。更加利于对阅读源码的理解。 编译器重构使用插件化设计带位置信息的parser(source maps!)为更好的IDE供给链铺路 runtime时出错提示优化 更好的多端渲染支持vue衍生出Wexx、NativeVue、wePy 等小程序终端。vue3会进行更好的优化。推出Custom Renderer API，为多端提供更好的渲染。 12345import &#123; createRenderer &#125; from '@vue/runtime-core'const &#123;render&#125; = createRenderer(&#123; nodeOps, patchData&#125;) 新功能响应式数据监听API12345678import &#123;observable, effect&#125; from 'vue'const state = observable(&#123; count: 0&#125;)effect(() =&gt; &#123; console.log(`count is: $&#123;state.count&#125; `) //每次更改状态时触发的函数&#125;)// count is: 0state.count ++ //count is : 1 可以很简单的在多组件中实现状态共享 轻松排查组件更新的触发原因123456789const Comp = &#123; render(props) &#123; return h('div', props.count) &#125;, renderTriggered(event)&#123; debugger // 可在此检查是在哪触发的组件更新 //event可查看更多信息，更改了那个key，哪行代码做的更改..等 &#125;&#125; 更好的TypeScript支持提升了性能。支持tsx 更好的警告信息 组件堆栈包含函数式组件 可以直接在警告信息中查看组件的props 在更多的警告中提供组件堆栈信息 新加Experimental HooksAPI类似React Hooks,大概率取代mixins。逻辑重用机制。 github上已有Vue Hooks这个项目 Experimental Time Slicing Support把js中复杂的计算切成一帧一帧(每16毫秒)，解决用户界面卡顿的问题。 开启Time Slicing，在js计算的时候每次只占用16毫秒左右的工作量，之后把主动权交还给浏览器，这样浏览器有时间去相应用户的操作 关于IE会有一个专门的版本在IE11中自动降级为旧的getter/setter机制。并对IE中不支持的用法给出警告。但在ie中可能享受不到vue的一些新功能。 整理的比较乱，具体功能以及使用需要参考相关官方文档。","categories":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://haoge744.github.io/tags/vue/"}]},{"title":"uni-app 入坑系列一","slug":"uni-app-入坑系列一","date":"2019-07-31T15:24:42.000Z","updated":"2019-08-05T09:24:42.000Z","comments":true,"path":"2019/07/31/uni-app-入坑系列一/","link":"","permalink":"https://haoge744.github.io/2019/07/31/uni-app-%E5%85%A5%E5%9D%91%E7%B3%BB%E5%88%97%E4%B8%80/","excerpt":"uni的简介和优点 uni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可编译到iOS、Android、H5、以及各种小程序等多个平台。 uni-app的特点和优势在于，跨平台数量多、性能体验好、生态环境好、开发效率高等特点，确实值得现在开发者学习，学习成本也不高。","text":"uni的简介和优点 uni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可编译到iOS、Android、H5、以及各种小程序等多个平台。 uni-app的特点和优势在于，跨平台数量多、性能体验好、生态环境好、开发效率高等特点，确实值得现在开发者学习，学习成本也不高。 项目目录结构一个uni-app工程，默认包含如下目录及文件： 123456789101112131415┌─components uni-app组件目录│ └─comp-a.vue 可复用的a组件├─hybrid 存放本地网页的目录，详见├─platforms 存放各平台专用页面的目录，详见├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此├─wxcomponents 存放小程序组件的目录，详见├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见└─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见 uni-app 和普通Vue项目开发上有什么区别路由vue项目配置路由页面在src/router/index.js文件下配置uni-app在项目根目录下的pages.json文件配置，并且结构和vue不一样。pages.json具体配置项可见详情。 路由跳转vue使用vue-router的router-view和vue-router的api进行页面跳转uni-app使用navigator组件跳转、或者调用API跳转。 组件开发uni-app和vue一样也使用.vue文件来编写组件 但是uni-app的tmeplate层内的标签是使用类似微信小程序的标签元素来编写的，例如用&lt;view&gt;和&lt;text&gt;来替代html中的&lt;div&gt;和&lt;span&gt;标签。 第三方组件引入可以访问进行查看区别。 配置文件uni-app使用manifast.json配置各平台相关信息，vue使用package.json webpack.*.conf.js 等配置文件配置 状态管理uni-app也可以使用vuex来管理生命周期，但是nvue模式下不支持。 生命周期uni-app给app环境下添加了几个全局的生命周期 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onUniNViewMessage 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 webpack 配置uni-app也支持使用webpack安装插件，但是只推荐h5平台使用，其他只支持flex布局和不操作dom的库，制作APP个人不推荐使用webpack安装第三方组件。","categories":[{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/categories/uni-app/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://haoge744.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"uni-app","slug":"uni-app","permalink":"https://haoge744.github.io/tags/uni-app/"}]},{"title":"hexo项目搭建","slug":"hexo项目搭建","date":"2019-07-21T06:59:40.000Z","updated":"2019-08-26T01:30:43.665Z","comments":true,"path":"2019/07/21/hexo项目搭建/","link":"","permalink":"https://haoge744.github.io/2019/07/21/hexo%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","excerpt":"安装 安装Node.js和git 此处不再阐述 执行一下命令全局安装hexo 123$ npm install -g hexo-cli或者$ cnpm install -g hexo-cli","text":"安装 安装Node.js和git 此处不再阐述 执行一下命令全局安装hexo 123$ npm install -g hexo-cli或者$ cnpm install -g hexo-cli 建站安装完成后执行以下命令 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 目录结构安装完成之后会生成以下目录12345678.├── _config.yml &#x2F;&#x2F; 网站的配置信息├── package.json &#x2F;&#x2F; package.json 依赖信息，可查看安装了哪些依赖包├── scaffolds &#x2F;&#x2F; ├── source &#x2F;&#x2F; 资源文件夹| ├── _drafts| └── _posts└── themes &#x2F;&#x2F; 主题文件夹 写作在hexo目录下 执行以下命令: 123456789101112hexo new &quot;post title&quot; &#x2F;&#x2F;写完之后执行 hexo g 生成页面hexo s &#x2F;&#x2F;生成草稿、 草稿不会生成页面hexo new draft &quot;draft title&quot;&#x2F;&#x2F;生成纯页面hexo new page &quot;page title&quot;&#x2F;&#x2F; 发布草稿hexp pulic [layout] &lt;filename&gt; 命令部署: 启动本地服务: 1hexo s -g 1hexo g -d","categories":[{"name":"hexo","slug":"hexo","permalink":"https://haoge744.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://haoge744.github.io/tags/hexo/"}]}]}