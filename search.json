[{"title":"git hooks","url":"/haoge744.github.io/2020/11/15/git-hooks/","content":"\n## git hooks使用\n\n在团队协作开发时，为了保证代码质量和代码风格一致，需要在代码`commit`或`push`前对代码做一些测试和校验，那么就可以使用`git hooks`了。常用的`hook`有`pre-commit`、`pre-push`这些。分别在提交和推送前调用。\n\n<!-- more -->\n\n在提交前做`lint`校验，推送前做测试校验:\n\n``` json\n{\n    \"gitHooks\": {\n        \"pre-commit\": \"lint-staged\",\n        \"pre-push\": \"test\"\n    }\n}\n```\n如果`es-lint`校验没有通过的话那么代码是不会提交成功的，如果说你非得提交，那么是也有办法的。\n\n``` bash\ngit commit --no-verify -m '提交校验'\n```\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"vite的使用","url":"/haoge744.github.io/2020/10/12/vite的使用/","content":"\n目前`vue3.0`已经在9月18号发布正式版本了，目前官方的脚手架有两种，一种是使用`@vue/cli`,需要4.x以上，一种是使用Vite。\n\n<!-- more -->\n\n## Vite介绍\n\n> Vite，一个基于浏览器原生ES Module的开发服务器，利用浏览器去解析模块，在服务端按需编译返回，完全跳过了打包这个概念，服务器随启随用。同时不仅有Vue文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。\n\n他主要有以下特点：\n\n- 更快的冷启动速度\n- 及时的热替换功能\n- 真正的按需编译\n\n在我开发的`vue`项目中只要页面一多的话，那么首次启动需要十几秒，然后修改文件后需要等2、3秒后才能编译完毕，大大降低了开发和调试的效率。\n\n## 初始化\n\n项目初始化\n使用`npm`\n\n``` bash\nnpm init vite-app project-name\ncd project-name\nnpm install\nnpm run dev\n```\n\n使用`yarn`\n\n``` bash\nyarn create vite-app project-name\ncd project-name\nyarn\nyarn dev\n```\n\n### Templates参数:\n\n创建一个vue-ts的项目\n\n``` bash\nyarn create vite-app project-name --template vue-ts\n```\n\n- vue (默认)\n- vue-ts\n- react\n- react-ts\n- preact\n- reason-react\n\n## 项目目录\n这是由`vue-ts`生成项目目录\n\n``` \nindex.html\npackage.json\npublic\nsrc\n--|App.vue\n--|assets\n--|components\n--|index.css\n--|main.ts\n--|vue-app-env.d.ts\ntsconfig.json\nyarn.lock\n```\n\n`vite`生成的项目目录比`vue/cli`生成的目录还简单，没有任何的配置文件，如果需要进行配置的话，需要新建`vite.config.js`，这点和`vue.config.js`类似，配置选项上和`vue/cli`选项差不多，如果对配置有问题的话，可以去看看`vue/cli`的[官方文档](https://cli.vuejs.org/zh/config/)\n\n注意:\n\n> Vite当前仅支持Vue 3.x。这也意味着您不能使用尚未与Vue 3 兼容的库 \n\n## 设置别名的方法\n\n打开vite.config.js\n\n``` javascript\nconst path = require('path')\nexport default {\n    alias: {\n        '/@/':  path.resolve(__dirname, 'src')\n    }\n}\n```\n\n使用:\n\n``` javascript\nimport Hello from '/@/components/Hello.vue'\n```\n\n> 注意不能使用`@`开头去引用，这是一个bug[issues](https://github.com/vitejs/vite/issues/279)\n\n","tags":["vue"],"categories":["vue"]},{"title":"vue拾遗","url":"/haoge744.github.io/2020/08/05/vue拾遗/","content":"\n记录一下vue的一些不太清楚，和之前没了解过的api。\n\n<!-- more -->\n\n##  hookEvent\n在监听生命周期方法时，除了声明生命周期方法也可以使用以下方式\n### 基本用法\n``` javascript\nexport default{\n    created () {\n        window.addEventListener('resize', this.resizeHandler)\n        this.$once('hook:beforeDestory', () => {\n            window.removeEventListener('resize', this.resizeHanlder)\n        })\n    },\n    methods: {\n        resizeHandler() {\n            // brbrbr\n        }\n    }\n}\n```\n### 监听其他组件或第三方组件的生命周期方法\n\n比如说我们想监听第三方组件的`update`事件，但是内部又没有提供`change`事件, 这时候也可以直接在组件上监听其生命周期事件\n\n``` vue\n<Component @hook:update=\"componentUpdateHandler\"></Component>\n```\n\n来看下源码中是怎么调用的\n\n```javascript\nexport function callHook (vm: Component, hook: string) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget()\n  const handlers = vm.$options[hook]\n  const info = `${hook} hook`\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info)\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook)\n  }\n  popTarget()\n}\n```\n\n在`_hasHookEvent`为true的情况下，会调用`hook:`前缀的事件，继续看一下`_hasHookEvent`的条件是什么。\n\n``` javascript\nconst hookRE = /^hook:/ \nVue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {\n  const vm: Component = this\n  if (Array.isArray(event)) {\n    for (let i = 0, l = event.length; i < l; i++) {\n      vm.$on(event[i], fn)\n    }\n  } else {\n    (vm._events[event] || (vm._events[event] = [])).push(fn)\n    // optimize hook:event cost by using a boolean flag marked at registration\n    // instead of a hash lookup\n    if (hookRE.test(event)) {\n      vm._hasHookEvent = true\n    }\n  }\n  return vm\n}\n```\n\n以`hook:`开头的事件监听，会被当成`hookEvent`,那么在生命周期触发的同时也会触发对应的事件。\n\n所以，如果你想给一个`Vue`组件添加生命周期函数有3个办法：\n\n- 在`Vue`组件选项中添加；\n- 在模板中通过`@hooks:created`这种形式；\n- `vm.$on('hooks:created', cb)`或者 `vm.$once('hooks:created', cb)`。\n\n\n\n## 使用Vue.observable管理状态\n\n “如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex”。这时候我们就可以使用`Vue2.6`提供的新API `Vue.observable`手动打造一个`Vuex` \n\n创建store\n\n``` javascript\nimport Vue from 'vue'\n\nexport const store = new Vue.observable({\n    userName: '',\n    roles: []\n})\n\nexport const mutations = {\n    setUserName(userName) {\n        store.userName = userName\n    },\n    setRoles(roles){\n    \tstore.roles = roles\n\t}\n}\n```\n\n组件中使用\n\n``` vue\n<template>\n\t<div>\n        {{ userName }}\n    </div>\n</template>\n<script>\nimport {store,mutations} from '@/store'\nexport default {\n    computed: {\n        userName () {\n            return store.userName\n        }\n    },\n    created() {\n        mutations.setUserName('张三')\n    }\n}\n</script>\n\n```\n\n## $watch监听\n\n在开发过程中有可能会有取消`watch`监听的要求，那么可以使用`$watch`方法取消监听\n\n``` javascript\nexport default {\n    data () {\n        formData: {\n            name: '',\n            password,\n        }\n    },\n    created() {\n        const unwatch = this.$watch('formData',\n          (val, oldVal) => {\n            console.log(val)\n          },\n          { \n             deep: true\n          }\n        )\n    }\n}\n```\n\n`$watch`方法返回的是一个`unwatch`方法，执行后即可取消监听。\n\n## 函数式组件\n\n``` jsx\nexport default {\n    functional: true,\n    props: {\n        title: '',\n    },\n    render(h, context) {\n    \treturn <h1></h1>\n\t}\n}\n\n```\n\n 函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等 \n\n##### 函数式组件与普通组件的区别\n\n1. 函数式组件需要在声明组件是指定functional\n2. 函数式组件不需要实例化，所以没有`this`,`this`通过`render`函数的第二个参数来代替\n3. 函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等\n4. 函数式组件不能通过$emit对外暴露事件，调用事件只能通过`context.listeners.click`的方式调用外部传入的事件\n5. 因为函数式组件是没有实例化的，所以在外部通过`ref`去引用组件时，实际引用的是`HTMLElement`\n6. 函数式组件的`props`可以不用显示声明，所以没有在`props`里面声明的属性都会被自动隐式解析为`prop`,而普通组件所有未声明的属性都被解析到`$attrs`里面，并自动挂载到组件根元素上面(可以通过`inheritAttrs`属性禁止)\n\n``` html\n<!--在template 上面添加 functional属性-->\n<template functional>\n  <img :src=\"props.avatar ? props.avatar : 'default-avatar.png'\" />\n</template>\n<!--根据上一节第六条，可以省略声明props-->\n\n```\n","tags":["vue"],"categories":["vue"]},{"title":"防抖节流","url":"/haoge744.github.io/2020/05/01/防抖节流/","content":"\n在实际开发过程中，处理滚动或者输入框搜索的时候，防抖和节流是非常常见的需求，以下列出我在使用的防抖节流的实现。\n\n<!-- more -->\n\n## 防抖\n``` javascript\n/**\n * 防抖\n * @param {Object} func 方法\n * @param {Object} wait 间隔时长 毫秒\n * @param {Object} immediate 是否事件触发时立即执行一次\n */\nexport function debounce(func, wait, immediate) {\n\n    var timeout;\n\n    return function () {\n        var context = this;\n        var args = arguments;\n\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 如果已经执行过，不再执行\n            var callNow = !timeout;\n            timeout = setTimeout(function(){\n                timeout = null;\n            }, wait)\n            if (callNow) func.apply(context, args)\n        }\n        else {\n            timeout = setTimeout(function(){\n                func.apply(context, args)\n            }, wait);\n        }\n    }\n}\n\n\n```\n\n## 节流\n``` javascript\n/**\n * 节流\n * @param {Object} func 方法\n * @param {Object} wait 间隔时长  毫秒\n */\nexport function throttle(func, wait) {\n    var timeout, context, args, result;\n    var previous = 0;\n\n    var later = function() {\n        previous = +new Date();\n        timeout = null;\n        func.apply(context, args)\n    };\n\n    var throttled = function() {\n        var now = +new Date();\n        //下次触发 func 剩余的时间\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n         // 如果没有剩余的时间了或者你改了系统时间\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout) {\n            timeout = setTimeout(later, remaining);\n        }\n    };\n    return throttled;\n}\n```\n\n使用：\n\n``` javascript\nimport {debounce} from '@/utils'\nexport default{\n\twatch:{\n        tempKeyWord(val) {\n\t\t\tthis.search({ctx: this, keyword: val})\n\t\t}\n    }, \n    methods: {\n        search: debounce(({ctx, keyword}) => {\n\t\t\t// do search...\n\t\t},700)\n    }\n}\n```\n\n原文链接：https://blog.csdn.net/weixin_42333548/article/details/90815258\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"尝试svelte","url":"/haoge744.github.io/2020/04/05/尝试svelte/","content":"\n\n最近才听说有`svelte`这个框架，他最大的卖点就是`no virutal dom`，并且渲染速度非常的快，我也上官网稍微了解了下，感觉蛮有意思的。\n\n接下来我将通过`svelte`来实现一个TODOList\n\n<!-- more -->\n\n## 初始化\n\n```bash\nnpx degit sveltejs/template my-svelte-project\n```\n\n生成的文件目录:\n\n```\npublic\nrollup.config.js\nsrc\npackage.json\nREADME.md\nscripts\n```\n\n可以看出来`svelte`是使用`rollup`来进行模块打包的\n\n## TODOList实现\n\n### 循环遍历\n\n`svelte`的代码风格类似于`vue`,对`vue`开发者来说非常友好;\n实现todo的遍历:\n\n``` html\n<script>\nexport let todoInputText;\nexport let todoList = [];\n</script>\n\n<main>\n<div>\n\t\t<ul>\n\t\t\t{#each todoList as item, i}\n\t\t\t\t<li :class=\"{item.completed ? 'done' : ''}\">\n\t\t\t\t\t{item.name}\n\t\t\t\t</li>\n\t\t\t{/each}\n\t\t</ul>\n\t</div>\n</main>\n\n<style>\n</style>\n\n```\n\n遍历需要使用`{ each }`代码块包裹需要循环的元素, `as`后面可以跟变量名和下标,并且可以支持解构\n\n```\n{#each todoList as {name, complete}, index}\n{/each}\n```\n\n`class`绑定和`vue`的差不多，这里就不详细讲解了\n\n`svelte`使用`.svelte`文件实现单文件组件，文件大致分为三块`script` js代码块、`main`模板、`style`样式。并且样式是会自动css模块化，而不需要像vue那样写`scoped`标签。\n\n### 双向绑定和事件触发\n\n列表做完之后，需要做的是列表项的添加和删除了，这里就需要增加一个input, 并且处理回车事件了， 每个列表项后面增加一个删除按钮，处理删除事件，在这里碰到了一个问题是点击删除按钮时调用的方法，不能把模板当中的下标当参数传到方法内，官网也没有写对应的样例，最后试了试用`react`的方式去处理，结果就OK了。\n\n``` html\n<script>\n\texport let name;\n\texport let todoInputText;\n\texport let todoList = [];\n\n\texport function keyupHandler(e) {\n\t\tif(e.keyCode === 13) {\n\t\t\ttodoList = todoList.concat([{\n\t\t\t\tname: todoInputText,\n\t\t\t\tcompleted: false\n\t\t\t}])\n\t\t}\n\t}\n\n\texport function remoteTodo(index) {\n\t\ttodoList.splice(index, 1)\n\t\ttodoList = todoList\n\t}\n\n</script>\n\n<div>\n        <input on:keydown=\"{keyupHandler}\" bind:value=\"{todoInputText}\" type=\"text\" placeholder=\"请输入待办事项\">\n        <button on:click=\"{log}\">clickme</button>\n        <ul>\n            {#each todoList as item, i}\n                <li :class=\"{item.completed ? 'done' : ''}\">\n                    <input type=checkbox bind:checked={item.completed}>\n                    {item.name}\n                    <button on:click={remoteTodo.bind(this,i)}>删除</button>\n                </li>\n            {/each}\n        </ul>\n    </div>\n```\n\n碰到的还有另外一个问题，貌似`svelte`没有给Array的事件做观察，所以当我们调用`splice`、`push`、`pop`这样的方法时，并不能响应式的触发视图更新，只能重新赋一遍值。目前还没有找到好的思路。\n\n## 总结\n\n尝试了以下`svelte`的使用，感觉还是不错的，据说他在渲染的性能上是强过`react`、`vue`、`augular`的，同时它也是打包后体积最小的一个框架了。然后在代码编写上也比较简洁，不用像react那样继承`class`也不用像`vue`那样写那么多 data methods等。目前svelte也推出了`状态管理`的解决方案，不知道有没有路由相关的。多尝试些不同的框架也能增加自己的见识，开阔视野吧。如果有兴趣的话，可以看看[官方文档](https://svelte.dev/)。","tags":["javascript"],"categories":["javascript"]},{"title":"vuex持久化插件","url":"/haoge744.github.io/2020/03/15/vuex持久化插件/","content":"\nvuex里存储的也只是一个全局变量，页面刷新之后，数据则会丢失。\n\n<!-- more -->\n\n编写vuex插件进行持久化, [原地址]( https://www.cnblogs.com/mengfangui/p/9698263.html )\n\n``` javascript\n// 新建 storage.js\n/**\n * vuex localStorage plugin\n */\n/**\n * \n * @param \n *   namespace 命名空间\n *   storage 存储对象\n *   persistence 持久化的state名\n */\nexport default function storagePlugin({\n  namespace = 'mfg-vux-',\n  storage = localStorage,\n  persistence = []\n} = {}) {\n  let serialize = JSON.stringify,\n    deserialize = JSON.parse,\n    isAll = persistence.length === 0 // 传入空数组代表存储所有的值\n  /**\n   * 获取持久化的state\n   * @param  {[type]} state [description]\n   * @return {[type]}       [description]\n   */\n  function getState(state) {\n    let data = {},\n      keys = isAll ? Object.keys(state) : persistence,\n      i = 0,\n      len = keys.length\n    for (; i < len; i++) {\n      let key = keys[i],\n        value = deserialize(storage.getItem(namespace + key))\n\n      data[key] = value === null ? state[key] : value\n    }\n    return data\n  }\n\n  /**\n   * 持久化state\n   * @param  {[type]} state [description]\n   */\n  function setState(state) {\n    let keys = isAll ? Object.keys(state) : persistence,\n      i = 0,\n      len = keys.length\n\n    for (; i < len; i++) {\n\n      let key = keys[i]\n\n      storage.setItem(namespace + key, serialize(state[key]))\n    }\n  }\n  return store => {\n\n    let state = store.state\n\n    // 初始化state\n    store.replaceState(\n      _.merge(\n\n        {},\n        state,\n        getState(state)\n      )\n    )\n    // 持久化state\n    store.subscribe((mutation, state) => {\n\n      setState(state)\n    })\n  }\n}\n```\n\nvuex中使用插件\n\n``` javascript\n// vuex部分代码\nimport storage from './plugins/storage'\n\nexport defualt new Vuex.Store({\n    state,\n    mutations,\n    getters,\n    actions,\n    plugins: [storage({\n        persistence: ['testText']\n    })] ,\n    strict: process.env.NODE_ENV !== 'production'\n})\n```\n\n// 还有个跟简单的方法 [转载至]( https://www.cnblogs.com/chenfan19941111/p/9970946.html )\n\n``` javascript\nexport default {\n  name: 'App',\n  created () {\n    //在页面加载时读取sessionStorage里的状态信息\n    if (sessionStorage.getItem(\"store\") ) {\n　　　　　　　//this.$store.replaceState()替换 store 的根状态\n        this.$store.replaceState(Object.assign({}, this.$store.state,JSON.parse(sessionStorage.getItem(\"store\"))))\n    } \n\n    //在页面刷新时将vuex里的信息保存到sessionStorage里\n    window.addEventListener(\"beforeunload\",()=>{\n        sessionStorage.setItem(\"store\",JSON.stringify(this.$store.state))\n    })\n  }\n}\n```\n\n","tags":["vue","vuex"],"categories":["vuex"]},{"title":"date-fns的使用","url":"/haoge744.github.io/2020/03/15/date-fns的使用/","content":"\n\n由于使用 Webpack 打包 moment.js 时，会将 moment.js 所有的 locale 全部打包进去。这样会让包的体积很大，现在有个比较好的替代方案就是使用`date-fns`\n<!-- more -->\n## 安装\n``` bash\nnpm install date-fns --save\n```\n## 常用api\n\ndate-fns的所有方法都是按模块化加载的所以需要像下面这样使用，这样做的好处是对`webapck treeShaking`更加友好，然后在打包的时候体积可以做到最小。\n\n``` javascript\nimport {format} from 'date-fns'\nformat(new Date(), 'yyyy-MM-dd')\n\n```\n\n1. ### format\n\n   ``` javascript\n   import { format } from 'date-fns'\n   // 格式化，非常常用的方法\n   console.log(format(new Date(), 'yyyy-MM-dd hh:mm:ss'))\n   // => 2019-03-15 11:19:56\n   ```\n\n2. ### add\n\n   ``` javascript\n   // 日期加 年月日小时分秒 等\n   var result = add(new Date(2014, 8, 1, 10, 19, 50), {\n     years: 2,\n     months: 9,\n     weeks: 1,\n     days: 7,\n     hours: 5,\n     minutes: 9,\n     seconds: 30,\n   })\n   //=> Thu Jun 15 2017 15:29:20\n   // 此外还有对应的 addYears() addMonths() addDays() addHours() addMinutes() addSeconds()\n   ```\n\n3. ### sub\n\n   ``` javascript\n   // 当前日期减 同上\n   const result = sub(new Date(2017, 5, 15, 15, 29, 20), {\n     years: 2,\n     months: 9,\n     weeks: 1,\n     days: 7,\n     hours: 5,\n     minutes: 9,\n     seconds: 30\n   })\n   //=> Mon Sep 1 2014 10:19:50\n   // 也有类似的subYears()等方法同add\n   ```\n\n4. ### closestIndexTo & closestTo\n\n   ``` javascript\n   // 传入一个日期和一个日期数组，返回最接近的那一个的对象/索引\n   var dateToCompare = new Date(2015, 8, 6)\n   var datesArray = [\n     new Date(2015, 0, 1),\n     new Date(2016, 0, 1),\n     new Date(2017, 0, 1)\n   ]\n   var result = closestIndexTo(dateToCompare, datesArray)\n   //=> 1\n   var result = closestTo(dateToCompare, datesArray)\n   /=> 2016-01-01\n   ```\n\n5. ### isToday & isTomorrow & isYesterday\n\n   ``` javascript\n   // 判断传入的日期是否是今天/明天/昨天\n   // If today is 6 October 2014, is 6 October 14:00:00 today?\n   var result = isToday(new Date(2014, 9, 6, 14, 0))\n   // => true\n   ```\n\n6. ### parse\n\n   ``` javascript\n   // 把字符串转换为Date类型 // v2.x.x\n   // 接收参数dateString formatString , referenceDate options 转换失败会返回第三个参数， 注意第三个参数是必填的\n   parse('2019-08-08', 'yyyy-MM-dd',new Date())\n   ```\n\n7. ### isEqual\n\n   ``` javascript\n   // 判断两个日期是否相等\n   var result = isEqual(\n     new Date(),\n     new Date()\n   )\n   // true\n   ```\n\n8. ### max & min\n\n   ``` javascript\n   // 获取日期数组中最大/最小的日期\n   max([new Date(1989, 6, 10),new Date(1987, 1, 11)])\n   // => 1989, 6, 10\n   min([new Date(1989, 6, 10),new Date(1987, 1, 11)])\n   // => 1987, 1, 11\n   ```\n\n9. ###  startOfMonth  &  endOfMonth:\n\n   ``` javascript\n   // 获取日期月份的第一天和最后一天\n   console.log(endOfMonth(new Date(2020, 1)))\n   console.log(startOfMonth(new Date(2020,1)))\n   // Sat Feb 29 2020 23:59:59 GMT+0800 (中国标准时间)\n   // Sat Feb 01 2020 00:00:00 GMT+0800 (中国标准时间)\n   // 还有些类似startOfDay startOfToday startOfHours等的api可以方便的获取各种开始、结束时间\n   ```\n\n10. ### startOfWeek & endOfWeek\n\n    ``` javascript\n    // 获取传入日期的一周的第一天和最后一天， 周日是第一天 周六是最后一天\n    console.log(startOfWeek(new Date(2020, 1)))\n    console.log(endOfWeek(new Date(2020,1)))\n    // Sun Jan 26 2020 00:00:00 GMT+0800 (中国标准时间)\n    // Sat Feb 01 2020 23:59:59 GMT+0800 (中国标准时间)\n    // tips：如果需要从周一开始 需要添加参数\n    endOfWeek(new Date(2020,1),{weekStartsOn: 1})\n    ```\n\n11. ###  differenceInDays\n\n    ``` javascript\n    // 获取两个时间相差多少天\n    differenceInDays(new Date(),addDays(new Date(),1))\n    // => -1\n    ```\n\n    其他时间的方法:\n\n    - differenceInHours();获得两个时间相差的小时. \n    - differenceInMinutes(): 获得两个时间相差的分钟 \n    - differenceInMonths():获得两个时间相差月份 \n    - differenceInWeeks(): 获得两个时间相差的周数\n    - differenceInYears():获得两个时间相差的年数 \n\n12. ### isBefore & isAfter\n\n    ``` javascript\n    // 判断两个时间是否在之前、之后\n    var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))\n    var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))\n    // 1.false 2.true\n    ```\n\n我认为比较常用的就是上面这些，很多时候原生的api也可以满足需要。引入api按需引入就好，不要直接`import *` 。\n更多详细的api可以去他的[官网](https://date-fns.org/ )看。","tags":["javascript"],"categories":["javascript"]},{"title":"vue缓存问题","url":"/haoge744.github.io/2020/03/14/vue缓存问题/","content":"## 关于vue路由缓存问题\n\n之前在工作中遇到了个关于页面跳转相关的缓存问题，没想到解决起来意外的挺简单的。\n\n需求是这样的，有个移动webApp，下面有4个tab可以切换，然后其中有个页面有个列表，在列表页点击某些功能可以跳转至页面B、页面C,页面C返回的时候列表不能刷新，滚动条需要在原来的位置，然而在C页面做了一些操作的时候是会影响列表项的值的，做了这些操作的话，返回列表页需要刷新数据。\n\n我的解决方案当然是用`keep-alive`了，然后把他的`includes`绑定到状态中去，这样可以方便的进行增加、删除。然后在列表页面中添加路由守卫，当判断要跳转到B、C页面的时候，把当前页面添加到缓存中，如果在二级页面需要删除缓存，则在状态管理里把缓存删掉，这样回到列表页之后就会刷新了。\n\n需要注意的是includes中使用的是组件的名称进行缓存的，所以组件的命名要规范，有语义，最好不要重复。\n\n<!-- more -->\n\n### 在状态管理中添加缓存的状态和一些动作\n\n新建cache.js\n\n``` javascript\nimport Vue from 'vue'\nconst cache = {\n    state: {\n        cacheComps: [] // 缓存组件\n    },\n    mutations: {\n        addCacheComp: (state, name) => {\n            if (!state.cacheComps.includes(name)) {\n                state.cacheComps.push(name)\n            }\n        },\n        removeCacheComp: (state, name) => {\n            const index = state.cacheComps.indexOf(name)\n            console.log('index:' + index)\n            if (index > -1) {\n                Vue.set(state, 'cacheComps', state.cacheComps.splice(index, 1))\n            }\n        }\n    }\n}\n\nexport default cache\n```\n\n### 添加路由守卫\n\n``` javascript\nbeforeRouteLeave (to, from, next) { // 缓存策略，当页面离开前判断 是不是以下几个路由，如果是，添加至状态，不是则清空\n        console.log(to)\n        const cachePath = ['a','b']\n        const needCache = cachePath.some(item => to.path.indexOf(item) >= 0)\n        if (needCache) {\n            // 由于我是嵌套路由实现的tab 所以需要缓存父子的组件\n            this.$store.commit('addCacheComp', 'layout')\n            this.$store.commit('addCacheComp','list')\n        } else {\n            this.$store.commit('removeCacheComp', 'layout')\n            this.$store.commit('removeCacheComp','list')\n        }\n        next()\n}\n```\n\n### 适当情况下清空缓存\n\n在B或C页面做了某些提交操作，影响列表数据时需要删除缓存：\n\n``` javascript\ncommit(){\n    doCommit().then(() => {\n        // ...\n        this.$store.commit('removeCacheComp', 'layout')\n        this.$store.commit('removeCacheComp','list')\n    })\n}\n```\n\n\n\n","tags":["vue"],"categories":["vue"]},{"title":"vue插件开发","url":"/haoge744.github.io/2020/02/15/vue插件开发/","content":"\n## Vue插件化\n\n我们注意到在使用一些Vuex、Vue-router或者是像element-ui等库的时候。 使用到的`Vue.use()`方法。在调用use方法内部做了哪些事呢，还有为什么Vue.use(element-ui) 就可以使用el开头的组件了呢。\n\n<!-- more -->\n\n`Vue.use`方法的形参是一个函数，或者一个对象，为对象时，需要有一个叫`install`的方法，还有一个可选参数`options`，Vue在初始化时会调用`use`方法接收的对应的方法，并传入`Vue`对象,和`options`(如果有的话)，那么我们就可以利用Vue做全局组件、指令的注册:\n\n``` javascript\t\nlet myPlugin = {}\nmyPlugin.install = function (Vue, options) {\n    // 判断插件是否已经注册\n    if (myPlugin.install.installed) return\n    \n    Vue.prototype.ss = () => { // 注册全局方法\n\t\t\n\t}\n    \n    const component = Vue.extend({\n        propsData: {\n         \t// propData: ...  \n        },\n        template: `<li>{{ text }}</li>`,// 也可以使用render\n        data () {\n            return { text: '123' }\n        }\n    })\n    \n    Vue.component('component-name', component)\n    \n    // 注册自定义指令\n    Vue.directive('my-directive', {\n        bind (el, binding, vnode, oldVnode) {\n            // something\n        }\n    })\n    \n    Vue.mixin({ // 混入全局对象 可以混入data和生命周期方法\n        data () {\n            aaa: '12'\n        },\n        created() {\n            // dosomething\n        }\n    })   \n}\nexport default myPlugin\n```\n\n### 添加全局插件二\n\n创建组件\n\n``` javascript\n<template>\n  <div>\n    <el-dialog\n      width=\"70%\"\n      top=\"7vh\"\n      :visible.sync=\"dialogFormVisible\"\n      :close-on-click-modal=\"false\"\n      :show-close=\"false\"\n    >\n      <div slot=\"title\">\n        <span class=\"result-check-tips\">{{title}}</span>\n      </div>\n      <c-table\n        :isPage=\"false\"\n        :data=\"list\"\n        :columns=\"header\"\n        dragTableKey=\"dragTableKeyCheckResult\"\n      >\n        <template slot=\"num\" slot-scope=\"item\">\n          <div>{{item.bodyItemIndex+1}}</div>\n        </template>\n      </c-table>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"cancel\" size=\"mini\">返 回</el-button>\n      </div>\n    </el-dialog>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      dialogFormVisible: false,\n      title: \"\",\n      list: [],\n      header: []\n    };\n  },\n  methods: {\n    getProductCheckResult(options) {\n     this.type=options.type;\n      this.title = options.msg;\n      this.list = options.data;\n      this.dialogFormVisible = true;\n    },\n    cancel() {\n      this.dialogFormVisible = false;\n    }\n  }\n};\n</script>\n```\n\n\n\n``` javascript\n// productCheckResult.js文件\nimport productCheckResult from './productCheckResult.vue'\nexport default {\n  install: function (Vue) {\n    const productCheckResultInstance = Vue.extend(productCheckResult)\n    let productCheckResultInit;\n    const initInstance = () => {\n      // 实例化vue实例\n      productCheckResultInit = new productCheckResultInstance();\n      let productCheckResultEl = productCheckResultInit.$mount().$el;\n      document.body.appendChild(productCheckResultEl);\n    };\n    Vue.prototype.$Dialog = {\n      getProductCheckResult(options) {\n        if (!productCheckResultInit) {\n          initInstance();\n        }\n        console.log(options)\n        productCheckResultInit.getProductCheckResult(options)\n      }\n    }\n  }\n}\n// 在main.js中注册 省略...\n```","tags":["vue"],"categories":["vue"]},{"title":"express设置跨域和自定义Header","url":"/haoge744.github.io/2020/02/01/express设置跨域和自定义Header/","content":"\n有些时候服务器和前端服务器部署在不同的地方，这个时候需要处理跨域问题，而且为了安全，一些接口必须要传token才能访问通过，可以把它放在`header`中。\n\n<!-- more -->\n\n## express的设置\n\nexpress设置允许跨域及设置自定义请求头:\n\n``` javascript\nconst express = require('express')\nconst app = express()\n\nvar allowCrossDomain = function(req, res, next) {\n    // 允许跨域的主机，这里暂时设置*\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header(\"Access-Control-Allow-Methods\", \"GET,POST,DELETE,PUT,OPTIONS,HEAD,FETCH\");\n    res.header(\"Access-control-max-age\", 1000);       //测试通过\n    // 如果需要支持cookie，就要加入\n    res.header('Access-Control-Allow-Credentials', true);\n    res.header('Access-Control-Allow-Headers', 'Content-Type,Content-Length, Authentication,Origin,Accept,X-Requested-With');\n    res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');\n    // res.header('X-Powered-By', ' 3.2.1');\n    // res.header('Content-Type', 'application/json;charset=utf-8');\n    // 自定义header的话web端会先发一个预请求OPTIONS，必须要返回200,告诉前台可以访问\n    if (req.method === 'OPTIONS') {\n        res.sendStatus(200);\n    } else {\n        next();\n    }\n};\napp.use(allowCrossDomain);\n```\n\n## 编写接口\n\n``` javascript\napp.all('/getData', (req, res) => {\n    console.log(req.method)\n    const token = req.get('Authentication')\n    console.log('token:',req.get('Authentication'))\n    if (!token) {\n        console.log('token is gone')\n        res.status(401).end('Token invaildate')\n        return\n    }\n    // 在确认有token的情况下我们可以根据token在redis获取到用户信息..\n})\n```\n\n","tags":["node","express"],"categories":["express"]},{"title":"vueTips","url":"/haoge744.github.io/2020/01/25/vueTips/","content":"\n前面发过一篇javascript的tips这次发布一些vue相关的,如果以后还有相关的会更新。\n\n## 生命周期Tip:\nbeforeCreate和created触发时，dom还不存在。\n服务端渲染时，beforeMount和mounted不会触发，因为服务端不会创建节点。\nrenderError 渲染错误时触发\n\n测试和正式环境可以使用errorCaptured来收集错误, 子组件会向父组件冒泡，一直冒到最上层(App.vue)。\n\n## watch深入观察对象/数组变化\nwatch: {\n\t'obj.a': // 监听对象中某个属性的变化。。\n\tfirstName: {\n\t\thandler(newName, oldNme){\n\t\t\tthis.fullName = newName + \" \" + this.lastName\n\t\t},\n\t\timmediate: true, // 初始化就执行一次\n\t\tdeep: true // 深入观察，会观察对象或数组的变化 比如想监听对象中某一个属性的变化,开销大不推荐\n\t}\n}\n\n<!-- more -->\n\n## 父组件和子/孙组件共享值\nprovide的用法，本人不是很常用。\n\n// 父组件\nexport default {\n  provide () {\n    return {\n       yeye: this\n     }\n  }\n}\n\n// 子组件\nexport default {\n  inject: ['yeye']\n  mounted () {\n    console.log(this.yeye)\n  }\n}\n\n## v-bind\n\n父组件\n<todo v-bind=\"options\"></todo>\n\n子组件\nthis.$attrs\n\n## 模板语法\n绑定属性时也可以使用模板语法\n:placeholder=\"$attrs.disabled?'':placeholder || `请输入${label}`\"\n事件传递 @change=\"handler($event, 2)\"\n\n## Vue强制渲染\nthis.$forceUpdate();进行强制渲染\n\n## Object.freeze()冻结对象\n如果你有一个巨大的数组或Object，并且确信数据不会修改，使用Object.freeze()可以让性能大幅提升。\nnew Vue({\n    data: {\n        // vue不会对list里的object做getter、setter绑定\n        list: Object.freeze([\n            { value: 1 },\n            { value: 2 }\n        ])\n    },\n    mounted () {\n        // 界面不会有响应\n        this.list[0].value = 100;\n\n        // 下面两种做法，界面都会响应\n        this.list = [\n            { value: 100 },\n            { value: 200 }\n        ];\n        this.list = Object.freeze([\n            { value: 100 },\n            { value: 200 }\n        ]);\n    }\n})\n\n## 跳转相同路由页面不刷新 (需要判断跳转其它路由的情况)\nwatch: {\n    '$route': (to, from) {\n        this.$router.go(0);\n    }\n},\n\n## 事件绑定使用计算属性\n\n``` vue\n<template>\n\t<componentA v-bind=\"$attrs\" :value=\"value\" v-on=\"bindListeners\">\n    </componentA>\n</template>\n\n<script>\nexport default{\n\tcomputed: {\n    \t   bindListeners() {\n              const events = this.$attrs.listeners\n              if (events && Object.keys(events).includes('input')) {\n                this.$delete(events,'input')\n              }\n              return Object.assign(this.$listeners,events)\n            }\n    }\n}\n</script>\n\n```\n\n","tags":["vue"],"categories":["vue"]},{"title":"jsTips","url":"/haoge744.github.io/2020/01/18/jsTips/","content":"\n小本本记录了一些关于js的小tips，下面整理一下发出来，内容可能会有过时。\n\n<!-- more -->\n\n1. 打印变量类型\n判断是否是对象\n``` javascript\nObject.prototype.toString.call(obj) === '[object Object]'\n```\n2. 判断变量是不是无穷的\n``` javascript\nisFinite(val)\n```\n3. 删除数组元素\n``` javascript\nfunction remove (arr, item) {\n    if (arr.length) {\n        var index = arr.indexOf(item);\n        if (index > -1) {\n        return arr.splice(index, 1)\n        }\n    }\n}\n```\n4. replace高级应用及占位符_\n``` javascript\nstr.replace(/-(\\w)/g, function (_, c) { return c ? c.toUpperCase() : ''; })\n \nstr.replace(hyphenateRE, '-$1').toLowerCase(\n// 1.$i (i:1-99) : 表示从左到右正则子表达式所匹配的文本。 // 2.$&:表示与正则表达式匹配的全文本。 // 3.$`(`:切换技能键)：表示匹配字符串的左边文本。 // 4.$'(‘:单引号)：表示匹配字符串的右边文本。\n\n// 5.$$：表示$转移。\n``` \n\n5. // Firefox has a \"watch\" function on Object.prototype...\n火狐浏览器对象的原型链上都有watch函数\n\n6. void 0 得到纯正的undefined\n\n7. 常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate。而常见的 micro task 有 MutationObsever 和 Promise.then。\n\n8. DocumentFragment \ndocumentFragment的作用是创建临时的dom节点，当append的时候才真正渲染dom从而可以提升效率\n``` javascript\nwindow.requestAnimationFrame(function(){\n        let fragment = document.createDocumentFragment();\n        for(let i = 0; i < pageCount; i++){\n            let li = document.createElement('li');\n            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)\n            fragment.appendChild(li)\n        }\n        ul.appendChild(fragment)\n        loop(curTotal - pageCount,curIndex + pageCount)\n    })\n```\n\n9. 获取元素离顶部的距离\n``` javascript\ndocument.getElementById('aa').getBoundingClientRect().top\n```\n10. window.scrollY 页面滚动y距离\n\n11. 获取对象类型属性\n``` javascript\nconst _toString = Object.prototype.toString\n            function toRawType(value) {\n                return _toString.call(value).slice(8, -1)\n            }\nconsole.log(toRawType({}))//Object\n```\n12. 字符串占位符\n``` javascript\nString.prototype.format = function() {\n    if(arguments.length == 0) return this;\n    var param = arguments[0];\n    var s = this;\n    if(typeof(param) == 'object') {\n        for(var key in param)\n            s = s.replace(new RegExp(\"\\\\{\" + key + \"\\\\}\", \"g\"), param[key]);\n        return s;\n    } else {\n        for(var i = 0; i < arguments.length; i++)\n            s = s.replace(new RegExp(\"\\\\{\" + i + \"\\\\}\", \"g\"), arguments[i]);\n        return s;\n    }\n}\n \nvar str = \"{one}{two}{three}\".format({one: \"1\",two: \"2\",three: \"3\"}); //123\nvar str2 = \"{0} {1} {2}\".format(\"how\",\"are\",\"you\"); //how are you\n``` \n13. 如果需要在数组循环时跳出循环 推荐使用every函数而不是forEacth\n\n14. !! 的妙用\n如果需要判断一个对象是否是空 可以使用\n``` javascript\nlet required = !!obj\n// 而不是\nif (obj) {\n  let required = true\n}\n```\n15. map使用await异步函数\n``` javascript\nasync onGetLocation(datas){\n    let res = await Promise.all(datas.map(async (item) => {\n        return await this.convertFrom( [item.lon, item.lat])\n    }))\n    this.setState({\n        pathSimplifierData: res\n    })\n}\n\nconvertFrom(point, type = 'gps') {\n    return new Promise((resolve, reject) => {\n        window.AMap.convertFrom(point,type, (status,result) => {\n            if(result.info === 'ok') {\n            resolve ( [result.locations[0].lng,result.locations[0].lat])\n            }\n        })\n    })\n}\n```\n\n\n16. 是否js原生方法\n``` javascript\nfunction isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n```\n\n17. 字符串数字转千位符\n\n``` javascript\nfunction thousandth(str) {\n  return str.replace(/\\d(?=(?:\\d{3})+(?:\\.\\d+|$))/g, '$&,');\n}\n```","tags":["javascript","tips"],"categories":["javascript"]},{"title":"css选择器的命名是一个哲学问题","url":"/haoge744.github.io/2020/01/05/css选择器的命名是一个哲学问题/","content":"\n> 以下内容摘抄、总结于《CSS选择器世界》\n\n## 不推荐的命名方法\n\n### 根据单词命名:\n\n``` css\n.title {}\n.red {}\n.box {}\n.success {}\n.red {}\n```\n\n以上命名虽然简短，语义也更易懂，但是重名频率太高，**不推荐**。\n\n### 使用拼音命名\n\n``` css\n.cs-tou {}\n.cs-hezi {}\n```\n\n试用拼音虽然胜利，对功能也没有影响，但却是一个比较傻的行为，因为他会让人感觉你比较业余。你自己命名是省力了，但这样的命名对其他同事而言却苦不堪言，因为可读性较差。\n\n### 使用id选择器\n\n``` css\n#box {}\n```\n\nid选择器虽然性能很不错，可以和类选择器分庭抗礼，但是他存在以下两个巨大缺陷\t\n\n<!-- more -->\n\n\t- 优先级太高，如果需要重置某些样式，必须要对id选择器选择覆盖，再多的类名都没有用，这会使得项目选择器的优先级变得非常混乱。如果非要使用元素的id选择器作为标识，可以用属性选择器替代:`[id=\"box\"]`\n\t- 和Javascript耦合,实际开发时，元素的ID主要用在Javascript中，以方便Dom元素快速获取它，如果ID同时和样式关联，它的可维护性会大打折扣，一旦ID变化，需要同时修改CSS和Javascript，然而实际上开发只会修改一处，这就是很多后期bug产生的原因。\n\n### 使用嵌套选择器\n\n以下选择器在项目中经常出现的:\n\n```css\n.nav a {}\n.box > div {}\n.avatar img {}\n\n.box .pic .icon {}\n```\n\n特别是在有了Scss、Less、Stylus之类的预编译工具出现后，5、6层嵌套的css选择器也大量出现，这太糟糕了！他们都是特别差的代码，其性质比Javascript使用全局变量还要糟。除了在书写时省电力其他全是缺点，包括:\n\n- 渲染性能糟糕\n- 优先级混乱\n- 样式布局脆弱\n\n#### 1. 渲染性能糟糕\n过深的嵌套会对性能产生影响，因为每加深一层嵌套，浏览器在进行选择器匹配的时候回多一层计算，一两个嵌套对性能自然毫无影响，但是，如果数千行CSS都才用了多层嵌套，量变引起质变，此时，光CSS样式的解析就可以到达百毫秒级别。\n#### 2. 优先级混乱\n书写选择器尽量遵循一个原则，那就是尽可能保持比较低的优先级，这样方便以后以较低的成本重置一些样式。\n然而，一旦选择器开始嵌套，优先级规则就会变得复杂，当我们想要重置某些样式的时候，你会发现一个类名不管用，两个类名也不管用，打开控制台一看，你希望重置的样式居然有6个选择器依次嵌套。如:\n``` css\n.layer_send_video_v3 .video_upbox dd .dd_succ .pic_default img {}\n```\n此时如果想要重置img的样式，只有这几种方法：1.使用同一优先级的选择器，但这个选择器的位置在需要重置的CSS代码后面；2.使用更深的层级，例如 使用7层选择器 这是最常用的方法 3. 使用Id选择器或者!important。他们都是很糟糕的解决方法。\n#### 3. 样式布局脆弱\n``` css\n.layer_end_video_v3 .video_upbox dd .dd_succ .pic_default img {}\n```\n在实际开发维护的过程中，调整HTML标签是非常常见的事情，例如，将<dd>元素换成语义更好的<section>。但是如果使用的是dd和img选择器,HTML标签是不能换的,因为如果标签换了，整个样式都会无效，你必须去CSS文件中找到对应的标签选择器进行同步修改，维护成本巨大。\n\n## 推荐的命名方法\n\n### 使用类选择器\n\n不要使用以下的嵌套选择器和标签选择器了:\n\n``` html\n<nav class=\"nav\">\n    <a>链接1</a>\n    <a>链接2</a>\n    <a>链接3</a>\n</nav>\n.nav {}\n.nav a {}\n```\n\n请换成:\n\n``` html\n<nav class=\"cs-nav\">\n    <a class=\"cs-nav-a\">链接1</a>\n    <a class=\"cs-nav-a\">链接2</a>\n    <a class=\"cs-nav-a\">链接3</a>\n</nav>\n.cs-nav {}\n.cs-nav-a {}\n```\n\n\n\n### 好的命名方法\n\n#### CSS命名结构\n\n我们使用一些第三方UI时可以看到别人会以项目名开头去命名css，比如element-ui以**el**开头,vant-ui使用**van**开头等等，这种命名方式有效的防止了和我们自己书写的css命名冲突的问题。所以我们也可以效仿。以项目名或者公司名来开头。\n比如以下格式:\n```css\nprojectname-module-title\nbusiness-module-footer\n```\n示例:\n```css\n.cs-shop-panel-header{}\n.cs-shop-panel-header-title{}\n.cs-dialog-header{}\n.cs-dialog-footer{}\n```\n\n#### 不要歧视使用面向属性的命名\n\n不少开发者是不认可下面这种基于css属性本身的命名方式的，尤其是Web标准刚兴起的那段时期。\n\n``` css\n.dn {display: none;}\n.db {display: block;}\n.dib {display: inline-block;}\n...\n.ml20 {margin-left:20px;}\n...\n.vt {vertial-align: top;}\n.text-ell {text-overflow:ellipsis;white-space:nowrap;overflow:hidden;}\n...\n```\n\n为什么呢?因为这类命名本质上和html元素上写style属性没有什么不同。\n\n``` html\n<span style=\"display:inline-block;margin-left:20px\">文字</span>\n```\n\n效果是一样的，只是前者在书写上更为简洁，优先级更低。\n\n但是我们需要调整样式的时候，改动的是HTML，而非CSS，这不等于HTML和CSS耦合在一起了吗。于是很多人就接受不了了，尤其在推崇内容和样式分离的年代。我们做技术，一定要保持理性，要有自己的思考，最合适的才是最好的。技术的发展也想流行趋势一样是一个圈，转了一圈又回来了。随着React等框架的星期，\"CSS in JavaScript\"的概念居然也出现了(类似styled-components)。\n\n在某个很深的角落里里有一张图片，你希望这张图片的display设置为block,就算你专门给他命名一个语义化的CSS也没有意义。\n\n``` css\n.pic_default_img {display:block;}\n```\n\n类名的意义在于重复利用，如果他只是为了解决某一个单独的问题，那么还不如写style内联样式。\n\n#### 正确使用状态类名\n\n页面的交互总是伴随着各种状态变化，包括禁用状态、选中状态、激活状态等\n\n```css\n.cs-content.active{}\n.cs-check-item.checked{}\n.cs-input-item.disabled{}\n```\n\n`.active`类名本身没有样式，就是一个状态标识符，用来与其他类名发生关系，让其他类名的样式发生变化。并且与JavaScript代码逻辑分离，可以有效降低日后维护成本。可读性强。\n\n## 最佳实践\n\n#### 1. 命名书写\n\n(1) 命名建议小写，使用英文单词或缩写，对于专有名词，可以使用拼音，例如:\n\n``` css\n.cs-logo-youku {}\n```\n\n不建议使用驼峰命名，驼峰命名建议专门给JavaScript DOM用，以便和CSS样式类名区分开。\n\n``` css\n.csLogoYouku{} /* 不建议 */\n```\n\n(2) 对于组合命名，可以短横线或下划线连接，可以组合使用短横线和下划线，也可以连续短横线或下划线连接，任何方式都可以，只要在项目中保持一致就可以:\n\n``` css\n.cs-logo-youku {}\n.cs_logo_youku {}\n.cs-logo--youku {}\n.cs-logo__youku {}\n```\n\n组合格式没有必要超过5个，5个是极限。\n\n(3) 设置统一前缀，强化品牌同时避免样式冲突:\n\n``` css\n.cs-header {}\n.cs-log {}\n.cs-logo-a {}\n```\n\n这样，CSS代码的美观度也会提升很多\n\n#### 2. 选择器类型\n\n根据选择器的使用类型，我将网站CSS分成3个部分，分别是CSS重置样式，CSS基础样式和CSS交互变化样式。\n\n无论那种样式都不推荐使用ID选择器，实在要用，使用属性选择器代替，他的优先级和类选择器一模一样。\n\n``` css\n[id=\"someId\"] {}\n```\n\nCSS样式的重置可以使用标签选择器或者属性选择器:\n\n```css\nbody,p {margin:0;}\n\n[type=\"radio\"],\n[type=\"checkbox\"] {\n    position:absolute;\n    clip: rect(0 0 0 0)\n}\n```\n\n所有CSS基础样式全部使用类选择器，没有层级，没有标签。\n\n```css\n.cs-module .img {} /* 不推荐*/\n.cs-module-ul > li {} /* 不推荐*/\n```\n\n在所有HTML的标签上都写上不会冲突的类名\n\n``` css\n.cs-module-img {}\n.cs-module-li {}\n```\n\n所有HTML都需要重新命名的问题可以通过面向属性命名的CSS样式库得到解决。\n\n所有选择器嵌套或者级联，所有的伪类全部都在CSS交互样式发生变化的时候使用。例如:\n\n```css\n.cs-content.active{\n    height: auto;\n}\n.active > .cs-content-more{\n    display: none;\n}\n```\n\n例如\n\n``` css\n.cs-button:active{\n    filter: hue-rotate(5deg);\n}\n.cs-input:focus {\n    border-color: var(--blue);\n}\n```\n\n状态类名本身不包含任何CSS样式，他就是一个标识符。\n\n如果我们无法修改HTML。例如无法通过修改class属性添加新的类名，则级联、嵌套，以及各种高级伪类的使用都不受上面使用规则的限制。\n\n再和目前很多人的实现对比一下，最佳实践的不同之处在于：\n\n- 无标签，无层级；\n- 状态类名标识符；\n- 面向属性命名的CSS样式库。","tags":["css"],"categories":["css"]},{"title":"nginx部署vue项目及配置路由模式","url":"/haoge744.github.io/2020/01/02/nginx部署vue项目及配置路由模式/","content":"vue的默认路由模式采用的是hash模式，使用URL的hash值来模拟路径，于是url改变时，页面不会重载。如果不想要很丑的`#`号，可以使用路由的`history`模式,但是部署至服务器后，刷新页面会404找不到页面。原因是浏览器刷新后根据路由的地址是找不到相关资源的，所以我们要给服务器设置相关配置。\n\n### 警告\n\n正确的做法是给服务器设置把所有相关请求都转发到对应的index.html页面就可以了，但是也有个注意的地方，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。\n\n``` javascript\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [\n    { path: '*', component: NotFoundComponent }\n  ]\n})\n```","tags":["nginx"],"categories":["nginx"]},{"title":"vue cli2.x及3.x多环境打包配置","url":"/haoge744.github.io/2019/12/28/vue-cli2-x及3-x多环境打包配置/","content":"\n前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。\n\n俗话说懒是程序员三大美德之一，我们不希望每次切换环境都修改参数,我们希望的效果是:**每次构建时传入不同的参数来访问不同环境的全局变量**。\n\n<!-- more -->\n\n## vue cli2.x的配置\n\nvue cli2.x的配置对比3.x来说复杂一点，因为2.x中默认使用的是webpack3.x,配置项比较多。没有webpack4那么简洁。\n如果你当前的项目没有安装cross-env需要安装一下:\n``` bash\nnpm install cross-env --save-dev\n```\n假设我们除了生产环境还需要增加一个测试环境`test`和预生产环境`pre-prod`。并且每种环境的后台调用的api接口地址不一样。\n### 一. `config`目录中复制两个prod.env.js 分别修改为`test.env.js`和`pre.prod.env.js`\n\n``` javascript\n// test.env.js\n'use strict'\nmodule.exports = {\n  NODE_ENV: '\"production\"',\n  BASE_API: '\"http://test.api.com\"',\n  ENV_CONFIG: '\"test\"'\n}\n```\n``` javascript\n// pre.prod.env.js\n'use strict'\nmodule.exports = {\n  NODE_ENV: '\"production\"',\n  BASE_API: '\"http://pd.api.com\"',\n  ENV_CONFIG: '\"pre-prod\"'\n}\n```\n修改prod.env.js:\n``` javascript\n'use strict'\nmodule.exports = {\n  NODE_ENV: '\"production\"',\n  BASE_API: '\"http://prod.api.com\"',\n  ENV_CONFIG: '\"prod\"' // 设置这个参数对打包没有影响，它的作用是方便访问当前是什么环境\n}\n```\n\n### 二. 修改 `build/webpack.prod.conf.js`\n``` javascript\nconst envConfigMap = {\n  'prod': require('../config/prod.env'),\n  'test': require('../config/test.env'),\n  'pre-prod': require('../config/pre.prod.env')\n}\n\n// const env = require('../config/prod.env')\nconst env = envConfigMap[process.env.ENV_CONFIG] || require('../config/prod.env')\n```\n\n### 三. 修改`package.json`中的脚本命令\n``` json\n{\n    //...\n    \"scripts\": {\n        // ...\n        // ENV_CONFIG的变量要和上面map中的一致\n        \"build\": \"cross-env ENV_CONFIG=prod node build/build.js\",\n        \"build--test\": \"cross-env ENV_CONFIG=test node build/build.js\",\n        \"build--pre-prod\": \"cross-env ENV_CONFIG=pre-prod node build/build.js\"\n  },\n}\n```\n### 四. 修改`build/build.js` 添加打包环境提示\n``` javascript\nconst spinner = ora('正在打包...' + process.env.ENV_CONFIG + '环境')\n```\n### 五. 运行命令实现打包\n``` bash\nnpm run build\nnpm run build--test\nnpm run build--pre-prod\n```\n### 六. 测试\n运行 `npm run build--pre-prod`\n在初始化时打印`process.env`环境变量,可以看到读取到的配置文件是匹配上的。\n![测试](vue-cli2.x及3.x多环境打包配置/console.png)\n\n## vue cli3.x的配置\nvue-cli3.0之后默认没有提供开发和生产环境的全局变量，需要自己新建。\n\n配置开发、生产环境变量\n\n``` javascript\n// 项目根目录新建 '.env.development' 文件\n# api地址\nVUE_APP_BASE_API = '/development/api'\n```\n``` javascript\n// 项目根目录新建 '.env.production' 文件\n# api地址\nVUE_APP_BASE_API = '/production/api'\n```\n\n代码中使用`process.env.VUE_APP_BASE_API`去访问它们\n\n> 注意: *只有以 `VUE_APP_` 开头的变量会被 `webpack.DefinePlugin` 静态嵌入到客户端侧的包中。*\n\n### 自定义模式\n\n假如我们要创建一个预演的环境需要另外一套参数配置,比如说叫做`staging`。\n\n在package.json中添加一个命令(也可以在启动时添加 —mode参数)\n\n```json\n\"scripts\": {\n    \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lint\": \"vue-cli-service lint\",\n    // 启动本地环境\n    \"staging\": \"vue-cli-service serve --mode staging\"\n    // 打包\n    \"build-staging\": \"vue-cli-service build --mode staging\"\n  },\n```\n\n**注意**:创建 `.env.staging`, **文件后缀需要与 `--mode` 后面跟的值一样**\n\n```\nNODE_ENV = 'production'\nVUE_APP_BASE_API = '/staging/api'\n```\n\n如果需要再增加配置的话只需要增加一行命令，然后新建一个`.env.xxx`的文件就ok了，是不是比老版本方便很多呢。\n\n关于环境变量和模式的更多配置信息可以访问[官方介绍文档](https://cli.vuejs.org/zh/guide/mode-and-env.html)","tags":["vue","webpack","前端构建化"],"categories":["webpack"]},{"title":"Notification的使用","url":"/haoge744.github.io/2019/12/22/Notification的使用/","content":"\n最近注意到一些网站上渐渐会弹出一个框，提示你是否显示通知，这也意味着这项功能以后会越来越普遍了，像微博、邮箱、爱奇艺等网站已经开始用起来了，如果点击同意显示通知的话，那么前台可能会开启MQ或者使用轮询的方式，去获取你关注的人或者视频有没有更新，如果有则弹起通知，更加提高了用户的体验性。\n其实有关于通知的相关api之前也有了解过，但是并不深入，今天学习后总结一下，以便自己加深影响。\n\n<!-- more -->\n\n## 基础介绍\n\n### 构造方法\n\n``` javascript\nlet notification = new Notification(title, options)\n```\n调用`new Notification()`之后windows就会弹出一个框，他的参数有以下这些:\n\n1. title\n   通知的标题。\n2. options `可选`\n   - `dir`: 文字的方向.它的值可以是 `auto（自动）`, `ltr（从左到右）`, or `rtl`（从右到左） \n   - `lang`: 指定通知中所使用的语言。这个字符串必须在 [BCP 47 language tag](http://tools.ietf.org/html/bcp47) 文档中是有效的。\n   - `body`: 通知中额外显示的字符串\n   - `tag`: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。\n   - `icon`: 一个图片的URL，将被用于显示通知的图标。\n\n### 属性\n\n- `Notification.permission`  *只读属性*，用于读取用户是否授权显示通知，可能的值包括: `denied` (用户拒绝显示);`granted`(用户允许显示通知);`default`(未询问过用户，这种状态浏览器也会拒绝显示通知).\n- `Notification.title`*只读属性*, 在构造方法中传入的title参数\n- `notification.dir` *只读属性*,文本显示方向\n- `notification.lang` *只读属性*,通知的语言\n- `notification.body`*只读属性*,通知中额外显示的字符串\n-  `Notification.icon` 显示的图标图片的url地址\n\n### 事件处理\n\n- `Notification.onclick`\n\n  处理 `click` 事件的处理。每当用户点击通知时被触发。\n\n- `Notification.onshow`\n\n  处理 `show` 事件的处理。当通知显示的时候被触发。\n\n- `Notification.onerror`\n\n  处理 `error` 事件的处理。每当通知遇到错误时被触发。\n\n- `Notification.onclose`\n\n  处理 `close` 事件的处理。当用户关闭通知时被触发。\n\n### 方法\n\n#### 静态方法\n\n- `Notification.requestPermission(callback)` 请求用户是否显示通知,传入一个回调函数，回调函数参数的值为`denied` 和`granted`\n\n#### 实例方法\n\n-  `Notification.close()` 用于手动关闭通知\n\n- `Notification.addEventListener()` 添加事件监听\n- `Notification.removeEventListener()` 移除事件监听\n- `EventTarget.DispatchEvent` 手动触发事件\n\n### 案例\n\n``` javascript\n<script>\nwindow.onload = () => {\n    showNotify(\"Hello 你好\", {\n        dir: 'auto',\n        lang: 'zh_CN',\n        data: {a: 'ss'},\n        body: '你的xxx更新了,快去瞧瞧吧！',\n        icon: 'https://developer.mozilla.org/static/img/favicon32.7f3da72dcea1.png'\n    }).then( notifyInstance => {\n        notifyInstance.onclick = (e) => {\n            console.log('通知被点击了' + e.target)\n        }\n        notifyInstance.onshow = (e) => {\n            console.log('通知被显示了' + e.target.data)\n        }\n        notifyInstance.onerror = (e) => {\n            console.log('通知异常' + e)\n        }\n        notifyInstance.onclose = (e) => {\n            console.log('通知被关闭' + e)\n        }\n    })\n}\n\n// 发送通知\nfunction showNotify (title, options) {\n    return new Promise((resolve, reject) => {\n        if (!(\"Notification\" in window)) {\n            reject('Your browser does not support desktop Notification')\n        }\n        if (Notification.permission === 'granted') { // 如果用户已经同意显示通知，直接显示\n            resolve(new Notification(title, options))\n        } else if (Notification.permission === 'default') {\n            Notification.requestPermission((permission) => {\n                if (permission === 'granted')  // 用户同意\n                    resolve(new Notification(title, options))\n                else reject()\n            })\n        }\n    })\n    \n}\n</script>\n```\n\n在调试中发现`options`还可以传入一个参数`data`,有了这个data属性可以方便我们做点击通知后的处理事件了。不知道为什么MDN中的api并没有说这个参数。[MDN文档]( https://developer.mozilla.org/zh-CN/docs/Web/API/notification )\n还有一点就是`Notifiction`在服务器下的页面才有用,像`file:///`这样双击打开的是不能弹出通知来的。\n\n","tags":["javascript"],"categories":["javascript"]},{"title":"vue使用jsx","url":"/haoge744.github.io/2019/12/14/vue使用jsx/","content":"实际上，如果是要编写一些复杂和好用的组件，`vue`的`render`会经常出现,例如`element`的`el-tree`和`el-tabs`里面就用到了。有时间想写一些关于`element`的源码解析的文章，他们的组件写的很出色。\n之前写过一篇关于`vue render`函数的相关文章,今天写一篇关于`jsx`在vue的应用场景及实战。\n\n<!-- more -->\n\n## 使用场景\n目前`vue-cli3.0`构建的项目是默认支持jsx语法的，如果是`2.x`的项目，可能需要调整下`.babelrc`,\njsx的使用场景，目前我知道的只有两个，一个是当组件参数传过去，一个就是写`render`方法。\n1. 例如使用`el-tree`的时候可以传一个`render-content`参数来手动渲染，或者其他渲染比较复杂的时候，jsx是扩展性更好的方案。\n2. 如果在写render函数的时候,组件、参数比较多的情况下，会发现整个函数写的很长，并且很难维护，这时候使用jsx更加简单直观，并且更利于维护\n\n## 实际运用\n\n### 参数使用jsx\n上期我写了一篇文章封装了一个菜单栏，其中有一个参数使用了render函数,接下来把它改为jsx的写法\n我的[上期文章](/2019/12/04/vue渲染函数render/)\n``` javascript\nexport default {\n    data() {\n        return {\n            menuList: [{\n                key: 'home',\n                name: '首页',\n                content_render: (h,item) => {\n                  // console.log(h,item) \n                    //   return h('span', [ // 使用函数的写法\n                    //     h('span', {class: 'el-icon-location'}),\n                    //     item.name\n                    //   ])\n                    return \n                        <span>\n                            <span class=\"el-icon-location\"></span>\n                            <span>{item.name}</span>\n                        </span>\n                }\n                // ...\n          \t]\n        }\n    }\n}\n```\n### 实战中使用\n之前在项目中根据`el-table`再封装了一下，把分页给封装了进去，并且会自动计算屏幕剩余高度，避免出现屏幕滚动条。\n这个组件的难点在于如何适配多表头，如果没有多表头的情况下，使用`template`封装就可以满足,如果要适配多表头,那么要不使用组件递归，要么使用`render`函数，在函数里面递归，我自然是不想使用组件递归的了，是使用jsx完成了`render`函数\n\n``` jsx\nexport default {\n  name: 'dataTable',\n  props: {\n    head: {\n      type: Array,\n      required: true\n    },\n    tableData: { // 表格数据\n      type: Array,\n      default: () => []\n    },\n    showNumber: {\n      type: Boolean,\n      default: () => true\n    },\n    paging: { // 是否显示分页\n      type: Boolean,\n      default: () => true\n    },\n    pageProps: {\n      type: Object,\n      default: ()  => {\n        return { pageNum: 1, pageSize: 10, total: 0}\n      }\n    },\n    height: {\n      type: String,\n      default: 'auto'\n    }\n  },\n  data() {\n    return {\n      tableHeight: 500\n    }\n  },\n  render(h) {\n    const _this = this\n    // 渲染表格列\n    function renderCol(cols) {\n      return (\n        cols.map((item, index) => {\n          {/* 是否有子节点， 有的话递归渲染 el-table-column组件 */}\n          return !item.hasOwnProperty('children') || item.children.length === 0 ?\n            <el-table-column\n              prop={item.prop}\n              {/* v-bind=\"item\" 代替成 {...{attrs: item}}  */}\n              {...{attrs: item}}\n              label={item.label || item.prop}\n              {/*\n                 这一点有点复杂\n                 渲染一个作用域插槽，如果列的type属性不为'slot'或者没有传递item.prop的作用域具名插槽那么直接渲染当前表格的值\n                 否则渲染具名作用域插槽\n              */}\n              scopedSlots = {{default: (scope) =>\n                ( item.type !== 'slot' || !_this.$scopedSlots[item.prop]  ?\n                  <span>{scope.row[scope.column.property]}</span>\n                  :\n                  _this.$scopedSlots[item.prop]({\n                    data: scope.row\n                  })\n                )\n              }}\n            >\n            </el-table-column>\n            :\n            {/* 渲染多表头 */}\n            <el-table-column align=\"center\" label={item.label || item.prop}>\n              { renderCol(item.children)}\n            </el-table-column>\n        })\n      )\n\n    }\n\n    return (\n      <div>\n        <el-table height={this.getTableHeight} ref=\"dataTable\" {...{attrs: this.$attrs}}  data={this.tableData} style=\"width: 100%\" border>\n          {\n            this.showNumber ?\n              <el-table-column type=\"index\" align=\"center\" label=\"序号\" width=\"50\">\n              </el-table-column> : ''\n          }\n          {\n            /* 把传过来的head参数用上面定的方法进行渲染 */\n            renderCol(this.head)\n          }\n        </el-table>\n        {\n          this.paging ?\n            <el-pagination\n              class=\"pagin-wrapper\"\n              ref=\"pagination\"\n              current-page={this.pageProps.pageNum}\n              page-size={this.pageProps.pageSize}\n              total={this.pageProps.total}\n              pager-count={5}\n              page-sizes={[5,10,20,50]}\n              layout=\"total, sizes, prev, pager, next, jumper\"\n              on-size-change={this.pageSizeChangHandler}\n              on-current-change={this.pageChangeHandler}/> : ''\n        }\n      </div>\n    )\n  },\n  methods: {\n    pageSizeChangHandler (val) {\n      this.$emit('sizeChanged', val)\n    },\n    pageChangeHandler (val) {\n      this.$emit('pageChanged', val)\n    },\n    doLayout () {\n      this.$refs.dataTable.doLayout()\n    },\n    computedHeight () {\n      if (this.$refs.dataTable.$el) {\n        const top = this.$refs.dataTable.$el.getBoundingClientRect().top\n        const pageHeight = this.paging ? this.$refs.pagination.$el.offsetHeight : 0\n        this.tableHeight = document.body.clientHeight - top - pageHeight - 48 + 'px'\n      }\n    }\n  },\n  updated() {\n    this.$nextTick(() => {\n      this.doLayout()\n    })\n  },\n  computed: {\n    getTableHeight() {\n      if (this.height === 'auto') {\n        return this.tableHeight\n      } else if (this.height) {\n        return this.height\n      } else {\n        return null\n      }\n    },\n  },\n  mounted () {\n    this.$nextTick(() => {\n      this.computedHeight()\n    })\n  }\n}\n```\n比较难的一部分，在`renderCol`方法那里，至于jsx绑定数据和绑定事件都是用花括号比较简单。\n使用组件:\n``` vue\n<template>\n    <!-- ... -->\n    <dataTable\n        :head=\"head\"\n        :tableData=\"tableData\"\n        @sizeChanged=\"sizeChanged\"\n        @pageChanged=\"pageChanged\"\n        :pageProps=\"pageForm\">\n        <template v-slot:rate=\"{data}\">\n          {{ data.rate ? (data.rate * 100).toFixed(2) + '%' : '-'  }}\n        </template>\n    </dataTable>\n</template>\n<script>\n  export default {\n    name: 'ffff',\n    mixins: [dataTableMixin],\n    components: {\n      dataTable,\n      card\n    },\n    data() {\n      return {\n        tableData: [],\n        head: [{\n          prop: 'name',\n          label: 'xxx',\n          align: 'center',\n        }, {\n          prop: 'rate',\n          label: '占比',\n          align: 'center',\n          type: 'slot'\n        }\n        ]\n      }\n}\n</script>\n```\n至此已经对jsx封装组件有一定经验了，以后封装组件更有自己的想法。","tags":["vue","jsx"],"categories":["vue"]},{"title":"vue全局注册filters骚操作","url":"/haoge744.github.io/2019/12/07/vue全局注册filters骚操作/","content":"\n# 注册全局Filters骚操作\n\n``` javascript\n// 新建 src/filters/index.js\nconst filtersMap = {\n    dateFormatter: function (date, fmtExp) {\n        if (!date) return '-'\n        \n        var date = new Date(date)\n        var o = {\n            \"M+\": date.getMonth() + 1, //月份\n            \"D+\": date.getDate(), //日\n            \"h+\": date.getHours(), //小时\n            \"m+\": date.getMinutes(), //分\n            \"s+\": date.getSeconds(), //秒\n            \"q+\": Math.floor((date.getMonth() + 3) / 3), //季度\n            \"S\": date.getMilliseconds() //毫秒\n        };\n      \n        \n        if (/(y+)/.test(fmtExp)){\n            fmtExp = fmtExp.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n            console.log(fmtExp);\n        }\n        for (var k in o)\n            if (new RegExp(\"(\" + k + \")\").test(fmtExp))\n                fmtExp = fmtExp.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n        return fmtExp;\n    }\n}\n\nexport default (Vue) => {\n    for(key in filtersMap) {\n        Vue.filter(key, filtersMap[key])\n    }\n}\n```\n\n<!-- more -->\n在main.js中使用:\n\n``` javascript\nimport Vue from Vue\nimport filters from './filters'\nVue.use(filters)\n```\n\n### 使用require.context动态注册\n\n上面的方法有个缺点就是如果filter方法数量太多的话，js代码会很长，不易于维护，如果多的话也可以用js来划分不同的模块，然后使用webpack的`require.context`api自动导入，而不需要手动的import。\n首先在filters文件夹下创建modules文件夹然后根据需要创建对应的js文件，比如这样:\n![folder](vue全局注册filters骚操作/folder.png)\n\n里面的js都导出一个对象\n\n![code](vue全局注册filters骚操作/code.png)\n\nindex.js写好自动导出的代码:\n\n``` javascript\nconst modules = require.context('./modules', true, /\\.js$/)\n\nlet filters = modules.keys().reduce((prev, key) => {\n    return Object.assign(prev,modules(key).default)\n}, {})\n\nexport default (Vue) => {\n    for(let key in filters) {\n        Vue.filter(key, filters[key])\n    }\n}\n```\n\n使用方法直接`Vue.use`即可\n\n关于require.context()目前了解的不深，不作太多讲解。以后会专门写一篇文章总结它。","tags":["vue"],"categories":["vue"]},{"title":"vue渲染函数render","url":"/haoge744.github.io/2019/12/04/vue渲染函数render/","content":"\n# Vue Render函数\n\n## 基础\n\nrender函数即渲染函数，它的的参数为`createElement`，也是个函数，它的返回值为`VNode`, render函数必须返回一个`VNode`对象。\n\n`createElement`的参数:\n1. 标签名、组件选项对象。必填。类型:{String | Object | Function}\n2. 为node添加属性的数据对象。非必填。类型:{Object}\n3. 子级虚拟节点，由 `createElement()`构建而成，也可以直接使用字符串。类型: {String | Array}\n\n`createElement()`的返回值是`VNode`对象，而且`render()`需要返回的正是`VNode`对象。\n\n<!-- more -->\n\n### 深入数据对象\n\n在模板中我们给组件设置一些参数、响应事件 一般使用的是 `v-bind:`或者`v-on`开头的语法,但在render函数中它们都变成了一个个的属性\n``` javascript\n{\n    // 与 `v-bind:class` 的 API 相同，\n    // 接受一个字符串、对象或字符串和对象组成的数组\n    'class': {\n        foo: true,\n        bar: false\n    },\n    // 与 `v-bind:style` 的 API 相同，\n    // 接受一个字符串、对象，或对象组成的数组\n    style: {\n        color: 'red',\n        fontSize: '14px'\n    },\n    // 普通的 HTML 特性\n    attrs: {\n        id: 'foo'\n    },\n    // 组件 prop\n    props: {\n        myProp: 'bar'\n    },\n    // DOM 属性\n    domProps: {\n        innerHTML: 'baz'\n    },\n    // 事件监听器在 `on` 属性内，\n    // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。\n    // 需要在处理函数中手动检查 keyCode。\n    on: {\n        click: this.clickHandler\n    },\n    // 仅用于组件，用于监听原生事件，而不是组件内部使用\n    // `vm.$emit` 触发的事件。\n    nativeOn: {\n        click: this.nativeClickHandler\n    },\n    // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`\n    // 赋值，因为 Vue 已经自动为你进行了同步。\n    directives: [\n        {\n            name: 'my-custom-directive',\n            value: '2',\n            expression: '1 + 1',\n            arg: 'foo',\n            modifiers: {\n                bar: true\n            }\n        }\n    ],\n    // 作用域插槽的格式为\n    // { name: props => VNode | Array<VNode> }\n    scopedSlots: {\n        default: props => createElement('span', props.text)\n    },\n    // 如果组件是其它组件的子组件，需为插槽指定名称\n    slot: 'name-of-slot',\n    // 其它特殊顶层属性\n    key: 'myKey',\n    ref: 'myRef',\n    // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，\n    // 那么 `$refs.myRef` 会变成一个数组。\n    refInFor: true\n}\n```\n\n### 官方示例\n\n如果封装一个组件，根据传入的level来决定渲染h1~h6的标题元素，那么用模板代码太冗余，尝试使用render函数效果会好很多:\n``` javascript\nexport default {\n    props: {\n        level: {\n            type: Number,\n            default: () => 1\n        }\n    },\n    render (h) {\n        return h(\n            'h'+ this.level, // 标签名称\n            this.$slots.default // 子节点数据\n        )\n    }\n}\n```\n\n### 实际运用\n比如我们要在element-ui基础上封装一个导航组件，根据传入的菜单数据生成菜单像这样:\n![menu](vue渲染函数render/menu.png)\n\n如果说没有子菜单还好，有子菜单的话就必须要拆成两个组件了，然后递归循环了，可是我并不像那样，这个时候使用render函数就可以避免。\n\n直接上代码:\n\n``` javascript\n// 新建 /components/navMenu/index.js\nexport default {\n    name: 'navMenu',\n    props: {\n        menuList: {\n            type: Array,\n            required: true\n        }\n    },\n    created() {\n    },\n    render (h) {\n        const _this = this\n        // 渲染子菜单的方法\n        function renderSubItem(list, h) {\n            return list.map(item => {\n                // 判断有没有children属性 如果没有直接渲染el-menu-item组件\n                if (!item.hasOwnProperty('children') || item.children.length === 0) {\n                    return h('el-menu-item', {\n                        props: {\n                            index: item.key,\n                            ...item\n                        },\n                        key: item.key\n                    },\n                        item.name\n                    )\n                } else { // 有子节点的情况渲染el-submenu节点 并且给一个具名插值'title'\n                    return h('el-submenu', {\n                        props: {\n                            index: item.key,\n                            ...item // 属性扩展符可以把属性自动设置成组件的参数\n                        },\n                        key: item.key\n                        },\n                        [ \n                            h('template', {\n                                slot: 'title'\n                            },item.name),\n                        \t// 递归渲染子节点\n                            ...renderSubItem(item.children, h)\n                        ]\n                    )\n\n                }\n\n            })\n        }\n        // 首先渲染外部的el-menu节点 参数和事件使用$attrs和$listeners传递\n        return h('el-menu', {\n            props: {\n                ...this.$attrs\n            },\n            on: {\n                ...this.$listeners\n            }\n        }, [\n            ...renderSubItem(this.menuList, h)\n        ])\n    }\n}\n```\n\n使用:\n\n``` vue\n<template>\n\t<navMenu background-color=\"#545c64\" text-color=\"#fff\" active-text-color=\"#ffd04b\" \n      mode=\"horizontal\" :menuList=\"menuList\"></navMenu>\n</template>\n<script>\nimport navMenu from '@/components/navMenu/index.js'\nexport default {\n  name: 'home',\n  components: {\n    navMenu\n  },\n  data() {\n      return {\n      menuList: [{\n        key: 'home',\n        name: '首页',\n        content_render: (h,item) => {\n          // console.log(h,item)\n          return <span>{item.name}</span>\n        },\n      },{\n        key: 'categories',\n        name: 'web前端',\n        children: [{\n          key: 'book',\n          name: '书籍',\n        },{\n          key: 'tools',\n          name: '工具',\n        },{\n          key: 'javascript',\n          name: 'javascript',\n        },{\n          key: 'vue',\n          name: 'vue',\n        },{\n          key: 'css',\n          name: 'css',\n          children: [{\n            key: 'css3',\n            name: 'css3',\n          },{\n            key: 'stylus',\n            name: 'stylus',\n          },{\n            key: 'scss',\n            name: 'scss',\n          }]\n        }]\n      },{\n        key: 'dashboard',\n        name: '控制面板',\n        children: [{\n          key: 'ip',\n          name: '域名管理'\n        },{\n          key: 'server',\n          name: '服务器管理'\n        }]\n      },{\n        key: 'about',\n        name: '关于'\n      }]\n      }\n  }\n}\n</script>\n```\n\n使用效果:\n\n![menu](vue渲染函数render/menu2.png)\n\n还是有点瑕疵，菜单没有图标，我理想的状态是能够使用插槽并且设置图标。所以需要把这个功能加上。\n我的想法是每个菜单item可以提供一个`content_render`方法，这个方法的参数为`(h,item)`，这个方法的返回值需要为VNode。这样就可以实现相同的效果辣。\n\n修改一下`renderSubItem()`方法\n\n``` javascript\t\n\nfunction renderSubItem(list, h) {\n            return list.map(item => {\n                if (item.hasOwnProperty('content_render') && item.content_render) {\n                    console.log(item.content_render(h,item))\n                }\n                if (!item.hasOwnProperty('children') || item.children.length === 0) {\n                    return h('el-menu-item', {\n                        props: {\n                            index: item.key,\n                            ...item\n                        },\n                        key: item.key\n                    }, // 使用三目运算符判断菜单项是否有渲染函数\n                        [item.content_render ? \n                            h('template', {\n                                slot: 'title',\n                            }, [item.content_render(h,item)])\n                            : \n                            h('template', {\n                                slot: 'title',\n                            }, [item.name])\n                        ]\n                    )\n                } else {\n                    return h('el-submenu', {\n                        props: {\n                            index: item.key,\n                            ...item\n                        },\n                        key: item.key\n                    },\n                    [\n                        // 使用三目运算符判断菜单项是否有渲染函数\n                        item.content_render ? \n                            h('template', {\n                                slot: 'title',\n                            }, [item.content_render(h,item)])\n                            : \n                            h('template', {\n                                slot: 'title',\n                            }, [item.name]),\n                        ...renderSubItem(item.children, h)\n                    ]\n                    )\n                }\n            })\n        }\n```\n\n然后修改`data`中绑定的值:\n\n``` javascript\nexport default {\n    data() {\n        return {\n            menuList: [{\n                key: 'home',\n                name: '首页',\n                content_render: (h,item) => {\n                  // console.log(h,item)\n                  return h('span', [\n                    h('span', {class: 'el-icon-location'}),\n                    item.name\n                  ])\n                }\n                // ...\n          \t]\n        }\n    }\n}\n\n```\n\n效果:\n\n![menu](vue渲染函数render/menu3.png)\n\n如果觉得上面`content_render`写法太复杂也可以改成下面jsx的方法实现:\n\n```javascript\ncontent_render: (h, item) => {\n    return (\n            <span>\n              <span class=\"el-icon-location\"></span>\n              <span>{item.name}</span>\n            </span>\n          )\n}\n```\n\n修改完后的效果和上图是一致的。\n\n实际上上面的`navMenu`组件也可以使用jsx来重构，使用jsx的话代码更简洁和易维护一点，但是有关在vue中使用jsx的内容太多，打算再另外写一篇文章进行总结。","tags":["vue"],"categories":["vue"]},{"title":"vue插件总结","url":"/haoge744.github.io/2019/11/30/vue插件总结/","content":"# Vue三方插件集合\n\n前几天在网上看到一个vue插件列表，觉得还不错分享一下。找不到插件的时候可以回来看下哦。\n\n<!-- more -->\n\n## UI件\n\n### 框架\n\n> 1. [element](https://github.com/ElemeFE/element) - 饿了么出品的Vue2的web UI工具套件\n> 2. [mint-ui](https://github.com/ElemeFE/mint-ui) - Vue 2的移动UI元素\n> 3. [iview](https://github.com/iview/iview) - 基于 Vuejs 的开源 UI 组件库\n> 4. [Keen-UI](https://github.com/JosephusPaye/Keen-UI) - 轻量级的基本UI组件合集\n> 5. [vue-material](https://github.com/marcosmoura/vue-material) - 通过Vue Material和Vue 2建立精美的app应用\n> 6. [muse-ui](https://github.com/museui/muse-ui) - 三端样式一致的响应式 UI 库\n> 7. [vuetify](https://github.com/vuetifyjs/vuetify) - 为移动而生的Vue JS 2组件框架\n> 8. [vonic](https://github.com/wangdahoo/vonic) - 快速构建移动端单页应用\n> 9. [vue-blu](https://github.com/chenz24/vue-blu) - 帮助你轻松创建web应用\n> 10. [vue-multiselect](https://github.com/monterail/vue-multiselect) - Vue.js选择框解决方案\n> 11. [VueCircleMenu](https://github.com/OYsun/VueCircleMenu) - 漂亮的[vue](http://www.javanx.cn/tag/vue/)圆环菜单\n> 12. [vue-chat](https://github.com/Coffcer/vue-chat) - vuejs和vuex及webpack的聊天示例\n> 13. [radon-ui](https://github.com/luojilab/radon-ui) - 快速开发产品的Vue组件库\n> 14. [vue-waterfall](https://github.com/MopTym/vue-waterfall) - Vue.js的瀑布布局组件\n> 15. [vue-carbon](https://github.com/myronliu347/vue-carbon) - 基于 vue 开发MD风格的移动端\n> 16. [vue-beauty](https://github.com/FE-Driver/vue-beauty) - 由vue和ant design创建的优美UI组件\n> 17. [bootstrap-vue](https://github.com/pi0/bootstrap-vue) - 应用于Vuejs2的Twitter的Bootstrap 4组件\n> 18. [vueAdmin](https://github.com/taylorchen709/vueAdmin) - 基于vuejs2和element的简单的管理员模板\n> 19. [vue-ztree](https://github.com/lisiyizu/vue-ztree) - 用 vue 写的树层级组件\n> 20. [vue-tree](https://github.com/weibangtuo/vue-tree) - vue树视图组件\n> 21. [vue-tabs](https://github.com/alexqdjay/vue-tabs) - 多tab页轻型框架\n\n\n\n### 编辑器\n\n> 1. [markcook](https://github.com/jrainlau/markcook) - 好看的markdown编辑器\n> 2. [eme](https://github.com/egoist/eme) - 优雅的Markdown编辑器\n> 3. [vue-syntax-highlight](https://github.com/vuejs/vue-syntax-highlight) - Sublime Text语法高亮\n> 4. [vue-quill-editor](https://github.com/surmon-china/vue-quill-editor) - 基于Quill适用于Vue2的富文本编辑器\n> 5. [Vueditor](https://github.com/hifarer/Vueditor) - 所见即所得的编辑器\n> 6. [vue-html5-editor](https://github.com/PeakTai/vue-html5-editor) - html5所见即所得编辑器\n> 7. [vue2-editor](https://github.com/davidroyer/vue2-editor) - HTML编辑器\n> 8. [vue-simplemde](https://github.com/F-loat/vue-simplemde) - VueJS的Markdown编辑器组件\n> 9. [vue-quill](https://github.com/CroudSupport/vue-quill) - [vue组件](http://www.javanx.cn/tag/vue组件/)构建quill编辑器\n\n### slider\n\n> 1. [vue-awesome-swiper](https://github.com/surmon-china/vue-awesome-swiper) - vue.js触摸滑动组件\n> 2. [vue-slick](https://github.com/staskjs/vue-slick) - 实现流畅轮播框的vue组件\n> 3. [vue-swipe](https://github.com/ElemeFE/vue-swipe) - VueJS触摸滑块\n> 4. [vue-swiper](https://github.com/weilao/vue-swiper) - 易于使用的滑块组件\n> 5. [vue-images](https://github.com/littlewin-wang/vue-images) - 显示一组图片的lightbox组件\n> 6. [vue-carousel-3d](https://github.com/Wlada/vue-carousel-3d) - VueJS的3D轮播组件\n> 7. [vue-slide](https://github.com/hilongjw/vue-slide) - vue轻量级滑动组件\n> 8. [vue-slider](https://github.com/warpcgd/vue-slider) - vue 滑动组件\n> 9. [vue-m-carousel](https://github.com/shiye515/vue-m-carousel) - vue 移动端轮播组件\n> 10. [dd-vue-component](https://github.com/ibufu/dd-vue-component) - 订单来了的公共组件库\n> 11. [vue-easy-slider](https://github.com/shhdgit/vue-easy-slider) - Vue 2.x的滑块组件\n\n### 图表\n\n> 1. [vue-table](https://github.com/ratiw/vue-table) - 简化数据表格\n> 2. [vue-chartjs](https://github.com/apertureless/vue-chartjs) - vue中的Chartjs的封装\n> 3. [vue-charts](https://github.com/hchstera/vue-charts) - 轻松渲染一个图表\n> 4. [vue-chart](https://github.com/miaolz123/vue-chart) - 强大的高速的vue图表解析\n> 5. [vue-highcharts](https://github.com/weizhenye/vue-highcharts) - HighCharts组件\n> 6. [chartjs](https://github.com/vue-bulma/chartjs) - Vue Bulma的chartjs组件\n> 7. [vue-chartkick](https://github.com/ankane/vue-chartkick) - VueJS一行代码实现优美图表\n\n### 日历\n\n> 1. [vue-calendar](https://github.com/jinzhe/vue-calendar) - 日期选择插件\n> 2. [vue-datepicker](https://github.com/hilongjw/vue-datepicker) - 日历和日期选择组件\n> 3. [vue-datetime-picker](https://github.com/Haixing-Hu/vue-datetime-picker) - 日期时间选择控件\n> 4. [vue2-calendar](https://github.com/icai/vue2-calendar) - 支持lunar和日期事件的日期选择器\n> 5. [vue-fullcalendar](https://github.com/Wanderxx/vue-fullcalendar) - 基于vue.js的全日历组件\n> 6. [vue-datepicker](https://github.com/weifeiyue/vue-datepicker) - 漂亮的Vue日期选择器组件\n> 7. [datepicker](https://github.com/vue-bulma/datepicker) - 基于flatpickr的时间选择组件\n> 8. [vue2-timepicker](https://github.com/phoenixwong/vue2-timepicker) - 下拉时间选择器\n> 9. [vue-date-picker](https://github.com/Bubblings/vue-date-picker) - VueJS日期选择器组件\n> 10. [vue-datepicker-simple](https://github.com/dai-siki/vue-datepicker-simple) - 基于vue的日期选择器\n\n### 地址选择\n\n> 1. [vue-city](https://github.com/xinxingyu/vue-city) - 城市选择器\n> 2. [vue-region-picker](https://github.com/QingWei-Li/vue-region-picker) - 选择中国的省份市和地区\n\n### 地图\n\n> 1. [vue-amap](https://github.com/ElemeFE/vue-amap) - 基于Vue 2和高德地图的地图组件\n> 2. [vue-google-maps](https://github.com/GuillaumeLeclerc/vue-google-maps) - 带有双向数据绑定Google地图组件\n> 3. [vue-baidu-map](https://github.com/Dafrok/vue-baidu-map)- 基于 Vue 2的百度地图组件库\n> 4. [vue-cmap](https://github.com/doodlewind/vue-cmap) - Vue China map可视化组件\n\n### 播放器\n\n> 1. [vue-video-player](https://github.com/surmon-china/vue-video-player) - VueJS视频及直播播放器\n> 2. [vue-video](https://github.com/hilongjw/vue-video) - Vue.js的HTML5视频播放器\n> 3. [vue-music-master](https://github.com/yunyi1895/vue-music-master) - vue手机端网页音乐播放器\n\n### 滚动scroll\n\n> 1. [vue-scroller](https://github.com/wangdahoo/vue-scroller) - Vonic UI的功能性组件\n> 2. [vue-mugen-scroll](https://github.com/egoist/vue-mugen-scroll) - 无限滚动组件\n> 3. [vue-infinite-loading](https://github.com/PeachScript/vue-infinite-loading) - VueJS的无限滚动插件\n> 4. [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller) - 带任意数目数据的顺畅的滚动\n> 5. [vue-infinite-scroll](https://github.com/ElemeFE/vue-infinite-scroll) - VueJS的无限滚动指令\n> 6. [vue-scrollbar](https://github.com/BosNaufal/vue-scrollbar) - 最简单的滚动区域组件\n> 7. [vue-scroll](https://github.com/suguangwen/vue-scroll) - vue滚动\n> 8. [vue-pull-to-refresh](https://github.com/bajian/vue-pull-to-refresh) - Vue2的上拉下拉\n> 9. [mint-loadmore](https://github.com/mint-ui/mint-loadmore) - VueJS的双向下拉刷新组件\n> 10. [vue-smoothscroll](https://github.com/Teddy-Zhu/vue-smoothscroll) - smoothscroll的VueJS版本\n\n### 文件上传\n\n> 1. [vue-upload-component](https://github.com/lian-yue/vue-upload-component) - Vuejs文件上传组件\n> 2. [vue-core-image-upload](https://github.com/Vanthink-UED/vue-core-image-upload) - 轻量级的vue上传插件\n> 3. [vue-dropzone](https://github.com/rowanwins/vue-dropzone) - 用于文件上传的Vue组件\n\n### 图片处理\n\n> 1. [vue-lazyload-img](https://github.com/JALBAA/vue-lazyload-img) - 移动优化的vue图片懒加载插件\n> 2. [vue-image-crop-upload](https://github.com/dai-siki/vue-image-crop-upload) - vue图片剪裁上传组件\n> 3. [vue-svgicon](https://github.com/MMF-FE/vue-svgicon) - 创建svg图标组件的工具\n> 4. [vue-img-loader](https://github.com/JackGit/vue-img-loader) - 图片加载UI组件\n> 5. [vue-image-clip](https://github.com/legeneek/vue-image-clip)- 基于vue的图像剪辑组件\n> 6. [vue-progressive-image](https://github.com/MatteoGabriele/vue-progressive-image) - Vue的渐进图像加载插件\n\n### 提示\n\n> 1. [vue-toast-mobile](https://github.com/ElemeFE/vue-toast-mobile) - VueJS的toast插件\n> 2. [vue-msgbox](https://github.com/ElemeFE/vue-msgbox) - vuejs的消息框\n> 3. [vue-tooltip](https://github.com/Akryum/vue-tooltip) - 带绑定信息提示的提示工具\n> 4. [vue-verify-pop](https://github.com/aweiu/vue-verify-pop) - 带气泡提示的vue校验插件\n\n### 进度条\n\n> 1. [vue-radial-progress](https://github.com/wyzant-dev/vue-radial-progress) - Vue.js放射性进度条组件\n> 2. [vue-progressbar](https://github.com/hilongjw/vue-progressbar) - vue轻量级进度条\n> 3. [vue2-loading-bar](https://github.com/BosNaufal/vue2-loading-bar) - 最简单的仿Youtube加载条视图\n\n### 其他\n\n> 1. [vue-dragging](https://github.com/hilongjw/vue-dragging)- 使元素可以拖拽\n> 2. [Vue.Draggable](https://github.com/David-Desmaisons/Vue.Draggable)- 实现拖放和视图模型数组同步\n> 3. [vue-picture-input](https://github.com/alessiomaffeis/vue-picture-input)- 移动友好的图片文件输入组件\n> 4. [rubik](https://github.com/ccforward/rubik)- 基于Vuejs2的开源 UI 组件库\n> 5. [VueStar](https://github.com/OYsun/VueStar)- 带星星动画的vue点赞按钮\n> 6. [vue-tables-2](https://github.com/matfish2/vue-tables-2)- 显示数据的bootstrap样式网格\n> 7. [DataVisualization](https://github.com/SimonZhangITer/DataVisualization)- 数据可视化\n> 8. [vue-drag-and-drop-list](https://github.com/Alex-fun/vue-drag-and-drop-list)- 创建排序列表的Vue指令\n> 9. [vuwe](https://github.com/vuwe/vuwe)- 基于微信WeUI所开发的专用于Vue2的组件库\n> 10. [vue-typer](https://github.com/cngu/vue-typer)- 模拟用户输入选择和删除文本的Vue组件\n> 11. [vue-impression](https://github.com/NewDadaFE/vue-impression)- 移动Vuejs2 UI元素\n> 12. [vue-datatable](https://github.com/galenyuan/vue-datatable)- 使用Vuejs创建的DataTableView\n> 13. [vue-instant](https://github.com/santiblanko/vue-instant)- 轻松创建自动提示的自定义搜索控件\n> 14. [vue-slider-component](https://github.com/NightCatSama/vue-slider-component)- 在vue1和vue2中使用滑块\n> 15. [vue-touch-ripple](https://github.com/surmon-china/vue-touch-ripple)- vuejs的触摸ripple组件\n> 16. [coffeebreak](https://github.com/Kocisov/coffeebreak)- 实时编辑CSS组件工具\n> 17. [vue-datasource](https://github.com/coderdiaz/vue-datasource)- 创建VueJS动态表格\n> 18. [handsontable](https://github.com/vue-bulma/handsontable)- 网页表格组件\n> 19. [vue-bootstrap-table](https://github.com/jbaysolutions/vue-bootstrap-table)- 可排序可检索的表格\n> 20. [vue-google-signin-button](https://github.com/phanan/vue-google-signin-button)- 导入谷歌登录按钮\n> 21. [vue-float-label](https://github.com/bkzl/vue-float-label)- VueJS浮动标签模式\n> 22. [vue-tagsinput](https://github.com/Ginhing/vue-tagsinput)- 基于VueJS的标签组件\n> 23. [vue-social-sharing](https://github.com/nicolasbeauvais/vue-social-sharing)- 社交分享组件\n> 24. [vue-popup-mixin](https://github.com/myronliu347/vue-popup-mixin)- 用于管理弹出框的遮盖层\n> 25. [cubeex](https://github.com/fangyongbao/cubeex)- 包含一套完整的移动UI\n> 26. [vue-fullcalendar](https://github.com/CroudSupport/vue-fullcalendar)- vue FullCalendar封装\n> 27. [vue-material-design](https://github.com/loujiayu/vue-material-design)- Vue MD风格组件\n> 28. [vue-morris](https://github.com/bbonnin/vue-morris)- Vuejs组件封装Morrisjs库\n> 29. [we-vue](https://github.com/tianyong90/we-vue)- Vue2及weui1开发的组件\n> 30. [vue-form-2](https://github.com/matfish2/vue-form-2)- 全面的HTML表单管理的解决方案\n> 31. [vue-side-nav](https://github.com/vue-comps/vue-side-nav)- 响应式的侧边导航\n> 32. [mint-indicator](https://github.com/mint-ui/mint-indicator)- VueJS移动加载指示器插件\n> 33. [vue-ripple](https://github.com/BosNaufal/vue-ripple)- 制作谷歌MD风格涟漪效果的Vue组件\n> 34. [vue-touch-keyboard](https://github.com/icebob/vue-touch-keyboard)- VueJS虚拟键盘组件\n> 35. [vue-parallax](https://github.com/vue-comps/vue-parallax)- 整洁的视觉效果\n> 36. [vue-typewriter](https://github.com/eduardostuart/vue-typewriter)- vue组件类型\n> 37. [vue-ios-alertview](https://github.com/Treri/vue-ios-alertview)- iOS7+ 风格的alertview服务\n> 38. [paco-ui-vue](https://github.com/yeseason/paco-ui-vue)- PACOUI的vue组件\n> 39. [vue-button](https://github.com/steven5538/vue-button)- Vue按钮组件\n\n## 开发框架\n\n> 1. [vue.js](https://github.com/vuejs/vue) - 流行的轻量高效的前端组件化方案\n> 2. [vue-admin](https://github.com/fundon/vue-admin) - Vue管理面板框架\n> 3. [electron-vue](https://github.com/SimulatedGREG/electron-vue) - Electron及VueJS快速启动样板\n> 4. [vue-2.0-boilerplate](https://github.com/petervmeijgaard/vue-2.0-boilerplate) - Vue2单页应用样板\n> 5. [vue-webgulp](https://github.com/rodzzlessa24/vue-webgulp) - 仿VueJS Vue loader示例\n> 6. [vue-bulma](https://github.com/wangxg2016/vue-bulma) - 轻量级高性能MVVM Admin UI框架\n> 7. [vue-spa-template](https://github.com/hanan198501/vue-spa-template) - 前后端分离后的单页应用开发\n> 8. [Framework7-Vue](https://github.com/nolimits4web/Framework7-Vue) - VueJS与Framework7结合\n> 9. [vue-element-starter](https://github.com/Metnew/vue-element-starter) - vue启动页\n\n## 实用库\n\n> 1. [vuelidate](https://github.com/monterail/vuelidate) - 简单轻量级的基于模块的Vue.js验证\n> 2. [qingcheng](https://github.com/zerqu/qingcheng) - qingcheng主题\n> 3. [vuex](https://github.com/vuejs/vuex) - 专为 Vue.js 应用程序开发的状态管理模式\n> 4. [vue-axios](https://github.com/imcvampire/vue-axios) - 将axios整合到VueJS的封装\n> 5. [vue-desktop](https://github.com/ElemeFE/vue-desktop) - 创建管理面板网站的UI库\n> 6. [vue-meta](https://github.com/declandewet/vue-meta) - 管理app的meta信息\n> 7. [avoriaz](https://github.com/eddyerburgh/avoriaz) - VueJS测试实用工具库\n> 8. [vue-framework7](https://github.com/lmk123/vue-framework7) - 结合VueJS使用的Framework7组件\n> 9. [vue-lazy-render](https://github.com/yeyuqiudeng/vue-lazy-render) - 用于Vue组件的延迟渲染\n> 10. [vue-svg-icon](https://github.com/cenkai88/vue-svg-icon) - vue2的可变彩色svg图标方案\n> 11. [vue-online](https://github.com/Sopamo/vue-online) - reactive的在线和离线组件\n> 12. [vue-password-strength-meter](https://github.com/apertureless/vue-password-strength-meter) - 交互式密码强度计\n> 13. [vuep](https://github.com/QingWei-Li/vuep) - 用实时编辑和预览来渲染Vue组件\n> 14. [vue-bootstrap-modal](https://github.com/Coffcer/vue-bootstrap-modal) - vue的Bootstrap样式组件\n> 15. [element-admin](https://github.com/lynzz/element-admin) - 支持 vuecli 的 Element UI 的后台模板\n> 16. [vue-shortkey](https://github.com/iFgR/vue-shortkey) - 应用于Vue.js的Vue-ShortKey 插件\n> 17. [cleave](https://github.com/vue-bulma/cleave) - 基于cleave.js的Cleave组件\n> 18. [vue-events](https://github.com/cklmercer/vue-events) - 简化事件的VueJS插件\n> 19. [http-vue-loader](https://github.com/FranckFreiburger/http-vue-loader) - 从html及js环境加载vue文件\n> 20. [vue-electron](https://github.com/SimulatedGREG/vue-electron) - 将选择的API封装到Vue对象中的插件\n> 21. [vue-router-transition](https://github.com/weinot/vue-router-transition) - 页面过渡插件\n> 22. [vuemit](https://github.com/gocanto/vuemit) - 处理VueJS事件\n> 23. [vue-cordova](https://github.com/kartsims/vue-cordova) - Cordova的VueJS插件\n> 24. [vue-qart](https://github.com/superman66/vue-qart) - 用于qartjs的Vue2指令\n> 25. [vue-websocket](https://github.com/icebob/vue-websocket) - VueJS的Websocket插件\n> 26. [vue-gesture](https://github.com/mlyknown/vue-gesture) - VueJS的手势事件插件\n> 27. [vue-local-storage](https://github.com/pinguinjkeke/vue-local-storage) - 具有类型支持的Vuejs本地储存插件\n> 28. [lazy-vue](https://github.com/gocanto/lazy-vue) - 懒加载图片\n> 29. [vue-lazyloadImg](https://github.com/yodfz/vue-lazyloadImg) - 图片懒加载插件\n> 30. [vue-bus](https://github.com/yangmingshan/vue-bus) - VueJS的事件总线\n> 31. [vue-observe-visibility](https://github.com/Akryum/vue-observe-visibility) - 当元素在页面上可见或隐藏时检测\n> 32. [vue-notifications](https://github.com/se-panfilov/vue-notifications) - 非阻塞通知库\n> 33. [v-media-query](https://github.com/AStaroverov/v-media-query) - vue中添加用于配合媒体查询的方法\n> 34. [vuex-shared-mutations](https://github.com/xanf/vuex-shared-mutations) - 分享某种Vuex mutations\n> 35. [vue-lazy-component](https://github.com/Coffcer/vue-lazy-component) - 懒加载组件或者元素的Vue指令\n> 36. [vue-reactive-storage](https://github.com/ropbla9/vue-reactive-storage) - [vue插件](http://www.javanx.cn/tag/vue插件/)的Reactive层\n> 37. [vue-ts-loader](https://github.com/HerringtonDarkholme/vue-ts-loader) - 在Vue装载机检查脚本\n> 38. [vue-pagination-2](https://github.com/matfish2/vue-pagination-2) - 简单通用的分页组件\n> 39. [vuex-i18n](https://github.com/dkfbasel/vuex-i18n) - 定位插件\n> 40. [Vue.resize](https://github.com/David-Desmaisons/Vue.resize) - 检测HTML调整大小事件的vue指令\n> 41. [vue-zoombox](https://github.com/vue-comps/vue-zoombox) - 一个高级zoombox\n> 42. [leo-vue-validator](https://github.com/LeoHuiyi/leo-vue-validator) - 异步的表单验证组件\n> 43. [modal](https://github.com/vue-bulma/modal) - Vue Bulma的modal组件\n> 44. [Famous-Vue](https://github.com/irwansyahwii/Famous-Vue) - Famous库的vue组件\n> 45. [vue-input-autosize](https://github.com/syropian/vue-input-autosize) - 基于内容自动调整文本输入的大小\n> 46. [vue-file-base64](https://github.com/BosNaufal/vue-file-base64) - 将文件转换为Base64的vue组件\n> 47. [Vue-Easy-Validator](https://github.com/MetinSeylan/Vue-Easy-Validator) - 简单的表单验证\n> 48. [vue-truncate-filter](https://github.com/imcvampire/vue-truncate-filter) - 截断字符串的VueJS过滤器\n\n## 服务端\n\n> 1. [vue-ssr](https://github.com/hilongjw/vue-ssr) - 结合Express使用Vue2服务端渲染\n> 2. [nuxt.js](https://github.com/nuxt/nuxt.js) - 用于服务器渲染Vue app的最小化框架\n> 3. [vue-ssr](https://github.com/ccforward/vue-ssr) - 非常简单的VueJS服务器端渲染模板\n> 4. [vue-easy-renderer](https://github.com/leaves4j/vue-easy-renderer) - Nodejs服务端渲染\n> 5. [express-vue](https://github.com/danmademe/express-vue) - 简单的使用服务器端渲染vue.js\n\n## 辅助工具\n\n> 1. [DejaVue](https://github.com/MiCottOn/DejaVue) - Vuejs可视化及压力测试\n> 2. [vue-generate-component](https://github.com/NetanelBasal/vue-generate-component) - 轻松生成Vue js组件的CLI工具\n> 3. [vscode-VueHelper](https://github.com/OYsun/vscode-VueHelper) - 目前vscode最好的vue代码提示插件\n> 4. [vue-play](https://github.com/vue-play/vue-play) - 展示Vue组件的最小化框架\n> 5. [VuejsStarterKit](https://github.com/MetinSeylan/VuejsStarterKit) - vuejs starter套件\n> 6. [vue-multipage-cli](https://github.com/xwpongithub/vue-multipage-cli) - 简单的多页CLI\n\n## 应用实例\n\n> 1. [pagekit](https://github.com/pagekit/pagekit) - 轻量级的CMS建站系统\n> 2. [vuedo](https://github.com/Vuedo/vuedo) - 博客平台\n> 3. [koel](https://github.com/phanan/koel) - 基于网络的个人音频流媒体服务\n> 4. [CMS-of-Blog](https://github.com/ycwalker/CMS-of-Blog) - 博客内容管理器\n> 5. [vue-cnode](https://github.com/lzxb/vue-cnode) - 重写vue版cnode社区\n> 6. [vue-ghpages-blog](https://github.com/viko16/vue-ghpages-blog) - 依赖GitHub Pages无需本地生成的静态博客\n> 7. [swoole-vue-webim](https://github.com/wh469012917/swoole-vue-webim) - Web版的聊天应用\n> 8. [fewords](https://github.com/sapjax/fewords) - 功能极其简单的笔记本\n> 9. [jackblog-vue](https://github.com/jackhutu/jackblog-vue) - 个人博客系统\n> 10. [vue-blog](https://github.com/surmon-china/vue-blog) - 使用Vue2.0 和Vuex的vue-blog\n> 11. [vue-dashing-js](https://github.com/thelinuxlich/vue-dashing-js) - nuvo-dashing-js的fork\n> 12. [rss-reader](https://github.com/mrgodhani/rss-reader) - 简单的rss阅读器\n\n## Demo示例\n\n> 1. [eleme](https://github.com/liangxiaojuan/eleme) - 高仿饿了么app商家详情\n> 2. [NeteaseCloudWebApp](https://github.com/javaSwing/NeteaseCloudWebApp) - 高仿网易云音乐的webapp\n> 3. [vue-zhihu-daily](https://github.com/hilongjw/vue-zhihu-daily) - 知乎日报 with Vuejs\n> 4. [Vue-cnodejs](https://github.com/shinygang/Vue-cnodejs) - 基于vue重写Cnodejs.org的webapp\n> 5. [vue2-demo](https://github.com/lzxb/vue2-demo) - 从零构建vue2 + vue-router + vuex 开发环境\n> 6. [vue-wechat](https://github.com/useryangtao/vue-wechat) - vue.js开发微信app界面\n> 7. [vue-music](https://github.com/Sioxas/vue-music) - Vue 音乐搜索播放\n> 8. [maizuo](https://github.com/zhengguorong/maizuo) - vue/vuex/redux仿卖座网\n> 9. [vue-demo](https://github.com/kenberkeley/vue-demo) - vue简易留言板\n> 10. [spa-starter-kit](https://github.com/codecasts/spa-starter-kit) - 单页应用启动套件\n> 11. [zhihudaily-vue](https://github.com/yatessss/zhihudaily-vue) - 知乎日报web版\n> 12. [douban](https://github.com/jiakeqi/douban) - 模仿豆瓣前端\n> 13. [vue-Meizi](https://github.com/liangxiaojuan/vue-Meizi) - vue最新实战项目\n> 14. [vue-demo-kugou](https://github.com/lavyun/vue-demo-kugou) - vuejs仿写酷狗音乐webapp\n> 15. [vue2.0-taopiaopiao](https://github.com/canfoo/vue2.0-taopiaopiao) - vue2.0与express构建淘票票页面\n> 16. [node-vue-server-webpack](https://github.com/yjj5855/node-vue-server-webpack) - Node.js+Vue.js+webpack快速开发框架\n> 17. [VueDemo_Sell_Eleme](https://github.com/SimonZhangITer/VueDemo_Sell_Eleme) - Vue2高仿饿了么外卖平台\n> 18. [vue-leancloud-blog](https://github.com/jiangjiu/vue-leancloud-blog) - 一个前后端完全分离的单页应用\n> 19. [vue-fis3](https://github.com/okoala/vue-fis3) - 流行开源工具集成demo\n> 20. [mi-by-vue](https://github.com/wendaosanshou/mi-by-vue) - VueJS仿小米官网\n> 21. [vue-demo-maizuo](https://github.com/ChuckCZC/vue-demo-maizuo) - 使用Vue2全家桶仿制卖座电影\n> 22. [vue2.x-douban](https://github.com/superman66/vue2.x-douban) - Vue2实现简易豆瓣电影webApp\n> 23. [vue-adminLte-vue-router](https://github.com/liujians/vue-adminLte-vue-router) - vue和adminLte整合应用\n> 24. [vue-zhihudaily](https://github.com/iHaPBoy/vue-zhihudaily) - 知乎日报 Web 版本\n> 25. [Zhihu-Daily-Vue.js](https://github.com/pomelo-chuan/Zhihu-Daily-Vue.js) - Vuejs单页网页应用\n> 26. [vue-axios-github](https://github.com/superman66/vue-axios-github) - 登录拦截登出功能\n> 27. [vue2.x-Cnode](https://github.com/vincentSea/vue2.x-Cnode) - 基于vue全家桶的Cnode社区\n> 28. [hello-vue-django](https://github.com/rokups/hello-vue-django) - 使用带有Django的vuejs的样板项目\n> 29. [websocket_chat](https://github.com/secreter/websocket_chat) - 基于vue和websocket的多人在线聊天室\n> 30. [x-blog](https://github.com/CommanderXL/x-blog) - 开源的个人blog项目\n> 31. [vue-cnode](https://github.com/wszgxa/vue-cnode) - vue单页应用demo\n> 32. [vue-express-mongodb](https://github.com/xrr2016/vue-express-mongodb) - 简单的前后端分离案例\n> 33. [photoShare](https://github.com/beidan/photoShare) - 基于图片分享的社交平台\n> 34. [notepad](https://github.com/lin-xin/notepad) - 本地存储的记事本\n> 35. [vue-zhihudaily-2.0](https://github.com/cs1707/vue-zhihudaily-2.0) - 使用Vue2.0+vue-router+vuex创建的zhihudaily\n> 36. [vueBlog](https://github.com/elva2596/vueBlog) - 前后端分离博客\n> 37. [Zhihu_Daily](https://github.com/littlewin-wang/Zhihu_Daily) - 基于Vue和Nodejs的Web单页应用\n> 38. [vue-ruby-china](https://github.com/hql123/vue-ruby-china) - VueJS框架搭建的rubychina平台\n> 39. [vue-koa-demo](https://github.com/Molunerfinn/vue-koa-demo) - 使用Vue2和Koa1的全栈demo\n> 40. [life-app-vue](https://github.com/shaqihe/life-app-vue) - 使用vue2完成多功能集合到小webapp\n> 41. [vue-trip](https://github.com/wenye123/vue-trip) - vue2做的出行webapp\n> 42. [github-explorer](https://github.com/SidKwok/github-explorer) - 寻找最有趣的GitHub库\n> 43. [vue-ssr-boilerplate](https://github.com/albertchan/vue-ssr-boilerplate) - 精简版的ofvue-hackernews-2\n> 44. [vue-bushishiren](https://github.com/nswbmw/vue-bushishiren) - 不是诗人应用\n> 45. [houtai](https://github.com/peng1992/houtai) - 基于vue和Element的后台管理系统\n> 46. [ios7-vue](https://github.com/QRL909109/ios7-vue) - 使用vue2.0 vue-router vuex模拟ios7\n> 47. [Framework7-VueJS](https://github.com/tyllo/Framework7-VueJS) - 使用移动框架的示例\n> 48. [cnode-vue](https://github.com/BubblyPoker/cnode-vue) - 基于vue和vue-router构建的cnodejs web网站SPA\n> 49. [vue-cli-multipage-bootstrap](https://github.com/zhoou/vue-cli-multipage-bootstrap) - 将vue官方在线示例整合到组件中\n> 50. [vue-cnode](https://github.com/jiananle/vue-cnode) - 用 Vue 做的 CNode 官网\n> 51. [seeMusic](https://github.com/Alex-xd/seeMusic) - 跨平台云音乐播放器\n> 52. [HyaReader](https://github.com/GitaiQAQ/HyaReader) - 移动友好的阅读器\n> 53. [zhihu-daily](https://github.com/xrr2016/zhihu-daily) - 轻松查看知乎日报内容\n> 54. [vue-cnode](https://github.com/Damonlw/vue-cnode) - 使用cNode社区提供的接口\n> 55. [zhihu-daily-vue](https://github.com/moonou/zhihu-daily-vue) - 知乎日报\n> 56. [vue-dropload](https://github.com/ITCNZ/vue-dropload) - 用以测试下拉加载与简单路由\n> 57. [vue-cnode-mobile](https://github.com/soulcm/vue-cnode-mobile) - 搭建cnode社区\n> 58. [Vuejs-SalePlatform](https://github.com/fishenal/Vuejs-SalePlatform) - vuejs搭建的售卖平台demo\n> 59. [vue-memo](https://github.com/youknowznm/vue-memo) - 用 vue写的记事本应用\n> 60. [sls-vuex2-demo](https://github.com/sailengsi/sls-vuex2-demo) - vuex2商城购物车demo\n> 61. [v-notes](https://github.com/Halfeld/v-notes) - 简单美观的记事本\n> 62. [vue-starter](https://github.com/BosNaufal/vue-starter) - VueJs项目的简单启动页\n\n原文地址: http://www.javanx.cn/20180720/vue-plug/ ","tags":["vue"],"categories":["vue"]},{"title":"Typescript的类型断言","url":"/haoge744.github.io/2019/11/29/Typescript的类型断言/","content":"\n## ts类型断言\n\n写给自己看的类型断言笔记。。\n\n\n之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：\n\n<!-- more -->\n\n``` typescript\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\ninterface Fish{\n    name: string;\n    swim: void;\n}\nfunction isFish(animal: Cat|Fish) {\n    if(typeof animal.swim === 'function'){\n        return true;\n    }\n    return false;\n}\n```\n\n此时可以使用类型断言，将`animal`断言成`Fish`\n\n``` typescript\nfunction isFish(animal: Cat|Fish){\n    if((animal as Fish).swim === 'function'){\n        return true;\n    }\n    return false;\n}\n```\n\n需要注意的是，类型断言只能够欺骗ts编译器,无法避免运行时的错误，所以滥用类型断言可能会导致运行时错误:\n\n``` typescript\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\ninterface Fish{\n    name: string;\n    swim: void;\n}\n\nfunction swim(animal: Cat|Fish){\n    (animal as Fish).swim()\n}\n\nconst tom:Cat={\n    name: 'tom',\n    run() {console.log('tom run')}\n}\nswim(tom); // Uncaught TypeError: animal.swim is not a function`\n```\n\n### 将任意一个类型断言成any\n\n理想情况下，Typescript的类型系统运转良好，每个值的类型都具体而精确。当我们引用一个在此类型上不存在的属性或方法时，就会报错:\n\n```typescript\nconst foo: number = 1;\nfoo.length = 1;\n// index.ts:2:5 - error TS2339: Property 'length' does not exist on type 'number'.\n```\n\n这种错误提示显然是非常有用的。\n\n但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：\n\n```typescript\nwindow.foo = 1;\n\n// index.ts:1:8 - error TS2339: Property 'foo' does not exist on type 'Window & typeof globalThis'.\n```\n\n上面的例子中，我们需要将 `window` 上添加一个属性 `foo`，但 TypeScript 编译时会报错，提示我们 `window` 上不存在 `foo` 属性。\n\n此时我们可以使用 `as any` 临时将 `window` 断言为 `any` 类型：\n\n```typescript\n(window as any).foo = 1;\n```\n\n在 `any` 类型的变量上，访问任何属性都是允许的。\n\n需要注意的是，将一个变量断言为 `any` 可以说是解决 TypeScript 中类型问题的最后一个手段。\n\n**它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 `as any`。**\n\n### 将 `any` 断言为一个具体的类型\n\n在日常的开发中，我们不可避免的需要处理 `any` 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。\n\n遇到 `any` 类型的变量时，我们可以选择无视它，任由它滋生更多的 `any`。\n\n我们也可以选择改进它，通过类型断言及时的把 `any` 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。\n\n举例来说，历史遗留的代码中有个 `getCacheData`，它的返回值是 `any`：\n\n```typescript\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n```\n\n那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：\n\n```typescript\nfunction getCacheData(key: string): any{\n   \treturn (window as any).cache[key]\n}\n\ninterface Cat{\n    name:string;\n    run():void;\n}\nconst tom = getCacheData('tom') as Cat\ntom.run()\n```\n\n上面的例子中，我们调用完 `getCacheData` 之后，立即将它断言为 `Cat` 类型。这样的话明确了 `tom` 的类型，后续对 `tom` 的访问时就有了代码补全，提高了代码的可维护性。\n\n## 类型断言的限制\n\n是不是任何一个类型都可以被断言成任何的另一个类型呢？答案是否定的——并不是任务一个类型都可以被断言成任何另一个类型\n\n```typescript\ninterface Cat {\n    run(): void;\n}\ninterface Fish {\n    swim(): void;\n}\n\nreturn testCat(cat: cat) {\n    return (cat as Fish) // error 两个接口无相同属性互不兼容\n}\n```\n\n## 双重断言\n\n既然：\n\n- 任何类型都可以被断言为 any\n- any 可以被断言为任何类型\n\n那么我们是不是可以使用双重断言 `as any as Foo` 来将任何一个类型断言为任何另一个类型呢？\n\n```tstypescript\ninterface Cat {\n    run(): void;\n}\ninterface Fish {\n    swim(): void;\n}\n\nfunction testCat(cat: Cat) {\n    return (cat as any as Fish);\n}\n```\n\n在上面的例子中，若直接使用 `cat as Fish` 肯定会报错，因为 `Cat` 和 `Fish` 互相都不兼容。\n\n但是若使用双重断言，则可以打破「要使得 `A` 能够被断言为 `B`，只需要 `A` 兼容 `B` 或 `B` 兼容 `A` 即可」的限制，将任何一个类型断言为任何另一个类型。\n\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n\n**除非迫不得已，千万别用双重断言。**\n\n## 类型断言 vs 类型声明\n\n在这个例子中：\n\n```typescript\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n我们使用 `as Cat` 将 `any` 类型断言为了 `Cat` 类型。\n\n但实际上还有其他方式可以解决这个问题：\n\n```typescript\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom: Cat = getCacheData('tom');\ntom.run();\n```\n\n上面的例子中，我们通过类型声明的方式，将 `tom` 声明为 `Cat`，然后再将 `any` 类型的 `getCacheData('tom')` 赋值给 `Cat` 类型的 `tom`。\n\n这和类型断言是非常相似的，而且产生的结果也几乎是一样的——`tom` 在接下来的代码中都变成了 `Cat` 类型。\n\n### 类型断言 vs 类型声明\n\n``` typescript\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\nconst tom: Cat = {\n    name: '123',\n    run: () => {}\n}\nconst a1: Animal = tom; // ok\nconst tom2: Cat = a1; // error\nconst tom3: Cat = a1 as Animal; // error\n```\n\n 这很容易理解，`Animal` 可以看作是 `Cat` 的父类，当然不能将父类的实例赋值给类型为子类的变量。有点和面向对象中多态的思想一样。\n\n## 类型断言 vs 泛型\n\n还是这个例子：\n\n```typescript\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n我们还有第三种方式可以解决这个问题，那就是泛型：\n\n```typescript\nfunction getCacheData<T>(key: string): T {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData<Cat>('tom');\ntom.run();\n```\n\n通过给 `getCacheData` 函数添加了一个泛型 `<T>`，我们可以更加规范的实现对 `getCacheData` 返回值的约束，这也同时去除掉了代码中的 `any`，是最优的一个解决方案。\n\n","tags":["typescript"],"categories":["typescript"]},{"title":"vue中name的作用","url":"/haoge744.github.io/2019/11/23/vue中name的作用/","content":"我们在写vue项目的时候会遇到给组件命名。\n``` javascript\nexport default {\n    name: 'xxx'\n}\n```\n这里的name非必选项，看起来好像没啥用处，但是实际上这里用处还挺多的\n<!-- more -->\n\n1. 当项目需要使用keep-alive时，可以进行缓存过滤\n使用keep-alive组件时,它的`includes`和`exclude`属性中使用的正是component的name\n\n2. 做递归组件时使用，\n比如当我们需要做层级菜单的时候，递归时需要用到name属性\nlist.vue:\n``` vue\n<div>\n    <div v-for=\"(item,index) of list\" :key=\"index\">\n      <div>\n        <span class=\"item-title-icon\"></span>\n        {{item.title}}\n      </div>\n      <div v-if=\"item.children\" >\n        <detail-list :list=\"item.children\"></detail-list>\n      </div>\n    </div>\n </div>\n<script>\nexport default {\n  name:'DetailList',//递归组件是指组件自身调用自身\n  props:{\n    list:Array\n  }\n}\n</script>\n```\n\nlist数据:\n``` javascript\nconst list = [{\n     \"title\": \"A\",\n     \"children\": [{\n      \"title\": \"A-A\",\n      \"children\": [{\n       \"title\": \"A-A-A\"\n      }]\n     },{\n        \"title\": \"A-B\"\n     }]\n    }, {\n     \"title\": \"B\"\n    }, {\n     \"title\": \"C\"\n    }, {\n     \"title\": \"D\"\n    }]\n```\n\n3. 使用vue-tools调试工具时，里面的组件标签显示的就是vue的name属性\n\n4. 事件传递时可以用到\n研究element源码的时候发现有一个`mixins/emitter`文件，里面写了如何向上和向下的组件传递事件(不限层级)，当然他这里为了避免冲突没有用到name而是componentName,但是是差不多的。\n`mixins/emitter.js`\n``` javascript\nfunction broadcast(componentName, eventName, params) {\n    this.$children.forEach(child => {\n        const name = child.$options.componentName;\n        if (name === componentName) {\n            child.$emit.apply(child, [eventName].concat(params));\n        } else {\n            broadcast.apply(child, [componentName, eventName].concat([params]));\n        }\n    });\n}\nexport default {\n    methods: {\n        dispatch(componentName, eventName, params) {\n            let parent = this.$parent || this.$root;\n            let name = parent.$options.componentName;\n\n            while (parent && (!name || name !== componentName)) {\n                parent = parent.$parent;\n\n                if (parent) {\n                    name = parent.$options.componentName;\n                }\n            }\n            if (parent) {\n                parent.$emit.apply(parent, [eventName].concat(params));\n            }\n        },\n        broadcast(componentName, eventName, params) {\n            broadcast.call(this, componentName, eventName, params);\n        }\n    }\n};\n```","tags":["vue"],"categories":["vue"]},{"title":"vue使用mixins提升开发效率","url":"/haoge744.github.io/2019/11/12/vue使用mixins提升开发效率/","content":"\n> 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n<!-- more -->\n\n在开发一些后台系统的时候，像这样的界面随处可见，那么能不能把其中相同的逻辑抽离出来来节省开发效率呢。vue给我们提供了`mixins`这样的一个混合工具，让我们可以抽离出一部分代码来进行\"合并\"。\n\n![后台管理系统](vue使用mixins提升开发效率/ht.png)\n\n大多数的列表界面都是类似的，不同的地方可能是功能以及数据的列不一样。所以可以把列表的查询条件，查询方法，分页等数据做一个`mixins`。\n\n## 开始使用\n\n``` javascript\n    // 新建 ListMixins.js\n    // 请求后台的方法，传递url和查询参数即可返回列表值，需要后台统一查询接口\n    import { queryListData } from \"@/api/dataTable\";\n    export default {\n        data () {\n            _url: '', // 请求数据的url\n            list: [], // 数据列表\n            page: { // 分页参数\n                pageNum: 1,\n                pageSize: 10,\n                total: 0\n            },\n            loading: false, // 加载状态\n        },\n        methods: {\n            del() { // 删除提示也可以抽出来，在实际的组件中覆盖 doDelete方法就行了\n                this.$confirm('是否确认删除?', '提示', {\n                    confirmButtonText: '确定',\n                    cancelButtonText: '取消',\n                    type: 'warning'\n                }).then(() => {\n                    this.doDelete()\n                })\n            },\n            getQueryParam() { // 获取查询参数 默认是查询条件和分页混合在一起 如果有额外的需求自行添加\n                return {...this.query, ...this.page }\n            },\n            queryListData() { // 加载列表数据\n                const param = this.getQueryParam() // 获取上面定义的参数\n                return new Promise((resolve, reject) => {\n                    this.loading = true // 设置loading\n                    initData(this._url, param).then(res => {\n                        this.loading = false\n                        this.page.total = res.data.total // 设置总数 \n                        resolve(res.data.list)\n                    }).catch(error => {\n                        this.loading = false\n                        reject(error)\n                    })\n                })\n            },\n            init () {}\n        },\n        created () {\n            // 初始化函数， 需要在里面做url和数据的处理\n            this.init()\n        }\n      }\n    }\n\n```\n\n组件中使用:\n\n``` vue\n<template>\n  <div>\n    <!-- 查询部分 -->\n    <div>\n        <el-form :inline=\"true\" size=\"small\" :model=\"query\" class=\"demo-form-inline\">\n            <el-form-item label=\"名称\">\n                <el-input  v-model=\"query.name\" placeholder=\"请输入关键字\"></el-input>\n            </el-form-item>\n            <el-form-item label=\"电话\">\n                <el-input v-model=\"query.phone\" placeholder=\"请输入关键字\"></el-input>\n            </el-form-item>\n            <el-button @click=\"queryData\">查询</el-button>\n        </el-form>\n        <div class=\"pull-right\">\n            <el-button type=\"default\">新增</el-button>\n            <el-button type=\"default\" @click=\"edit\">编辑</el-button>\n            <el-button type=\"default\" @click=\"del\">删除</el-button>\n        </div>\n    </div>\n\t\n    <!-- 列表部分 -->\n    <el-table :data=\"list\">\n        <el-table-column label=\"用户名\" prop=\"name\" align=\"center\">\n        </el-table-column>\n        <el-table-column label=\"电话\" prop=\"name\" align=\"center\">\n        </el-table-column>\n    </el-table>\n    <el-pagination\n          style=\"text-align: center;\"\n          :current-page.sync=\"page.pageNum\"\n          :page-size.sync=\"page.pageSize\"\n          :total=\"page.total\"\n          :page-sizes=\"[10,20,50]\"\n          layout=\"total, sizes, prev, pager, next, jumper\"\n          @size-change=\"queryData\"\n          @current-change=\"queryData\"/>\n  </div>\n</template>\n\n<script>\n    import ListMixin from '../mixins/ListMixins'\n\texport default {\n        mixins: [ListMixin],\n        methods: {\n            init () {\n                this._url = 'xxx/xxx/query' // 覆盖查询的url\n                this.queryData()\n            },\n            doDelete () {\n              // 调用删除接口  \n            },\n            queryData () {\n                this.queryListData().then(res => {\n                    this.list = res\n                })\n            }\n        }\n    }\n</script>\n\n```\n\n我这里用的是`element-ui`，关于el-table和el-pagination的可以自己再封装，这里不演示了，只演示mixins的相关内容。\n\n## 总结\n\n封装好mixins后使用既方便了开发，维护起来也方便了很多，比如说我的默认页要调整到20页，我该一行代码就可以了，关键是把真正项目中公用的地方抽离出来，这个要考虑好。\n\n虽然mixins好用，但是也不是没有缺点，如果说你一个组件引入的mixins过多，那么容易产生我这个数据或方法不知道从哪来的，会产生不确定性。\n\n","tags":["vue"],"categories":["vue"]},{"title":"vue3.0之vue-composition-api尝鲜","url":"/haoge744.github.io/2019/11/05/vue3-0之vue-composition-api尝鲜/","content":"\n# 简介\n\n根据vue作者尤雨溪去年发布的vue3.0开发路线，vue3.0很可能会在2019年下半年推出。\n\n此前vue官方也提供过了vue3.0特性的尝鲜版本，叫做`vue-function-api`,此后推出的最新版本为`vue-composition-api`,之前的`vue-function-api`已经淘汰了不再推荐学习了。\n\n虽然vue3.0还没有正式发布，但是已经可以安装`composition-api`插件来体验了。\n\n本篇文章将介绍`composition-api`基础使用以及最重要的一些新特性,例如`setup()`函数、`reactive()`、`ref()`等这些Vue Hooks。\n\n<!-- more -->\n\n# 安装\n\n1. 安装@vue/cli3\n\n   ```\n   npm install -g @vue/cli\n   ```\n\n2. 创建项目\n\n   ``` bash\n   vue create my-project\n   ```\n\n3. 安装`composition-api`\n\n   ``` bash\n   npm install @vue/composition-api --save\n   ```\n\n4. 使用\n\n   ``` javascript\n   // 在main.js使用\n   import Vue from 'vue'\n   import VueCompositionApi from '@vue/composition-api'\n   \n   Vue.use(VueCompositionapi)\n   \n   ```\n\n\n\n\n# 使用\n\n## setup函数\n\n**setup**函数是vue3中，专门为组件提供的新属性，它为我们使用vue3的Composition API 提供了同意的入口\n\n生命周期:\n\n**setup**会在**beforeCreate**之后，**created**之前执行。\n\n```javascript\n// comp1.vue\nexport default{\n    props: {\n        title: String\n    },\n    setup(props, ctx) {\n        console.log(props.title)\n    }\n}\n// 使用\n<compSetup title=\"access\" aaa=\"app\"></compSetup>\n\n```\n\n#### setup函数的形参\n\n**props**对应的是组件的参数，并且必须在`props`中声明才能访问的到，否则会出现在`Vue inheritAttrs`中\n\n**ctx**对应的是一个上下文对象，包含了一些有用的属性，这些属性在`vue2.x`中通过`this`才能访问，在vue3.x中集成到了**ctx**属性中。如图\n![setup](vue3-0之vue-composition-api尝鲜/setup.png)\n\n> 注意：在`setup()`函数中无法访问`this`\n\n### reactive\n\n`reactive()`函数接受一个普通的对象，返回一个响应式的数据对象\n\n#### 基本语法\n\n等价于Vue2.x中的`Vue.observable()`函数\n\n``` javascript\nimport { reactive } from '@vue/composition-api'\nexport default {\n    setup (props, ctx) {\n        const state = reactive({count : 0})\n        // 将响应式对象state 返回出去，否则外界访问不到\n        return state\n    }\n}\n```\n\n模板中访问\n\n``` vue\n<template>\n\t<span>{{ count }}</span>\n\t<!-- 每次点击加1，同时页面也会更新 -->\n\t<button @click=\"count += 1\">\n        +1\n    </button>\n</template>\n\n```\n\n使用方式和原来差不多，只不过原来是data属性，现在集成到了setup函数中，写法有点像react了\n\n### ref\n\n`ref()`函数的作用是根据给定的值创建一个响应式的数据对象，`ref()`函数调用的返回值是一个对象，且该对象只有一个属性:`value`\n\n#### 使用:\n\n``` vue\n<template>\n  <div>\n    <!-- 在模板中使用不需要.value -->\n    {{ count }}\n    <button @click=\"count += 1\">\n        +1\n    </button>\n  </div>\n</template>\n\n<script>\nimport {ref} from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const count = ref(0)\n        count.value++ // 在setup中使用需要.value ref返回的是对象\n        return {\n            count\n        }\n    }\n}\n</script>\n```\n\n`ref`的功能和`reactive`很像，但在`vue3`中推荐使用`ref`创建响应式对象\n\n#### ref和reactive配合使用\n\n``` javascript\n<script>\nimport {ref, reactive} from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const cc = ref(0)\n        const state = reactive{\n            cc\n        }\n        console.log(state.cc) // 输出0 此处不需要.value就能直接访问原始值\n        state.cc++\n        console.log(state.cc) // 输出1\n        return state\n    }\n}\n</script>\n```\n\n**注意:在setup创建的任何成员，想要使用必须在setup()中return**\n\n> 新的ref会覆盖就的ref:\n\n``` javascript\nconst a1 = ref(0)\nconst state = reactive({\n    a1\n})\nconst a2 = ref(10)\n\nstate.a1 = a2 // 将旧ref a1指向 新ref a2\nstate.a1++\nconsole.log(state.a1) // 输出 11\nconsole.log(a2) // 输出11\nconsole.log(a1.value) // 输出0\n```\n\n### isRef\n\n作用是判断该对象是否是`ref`方法创建的\n\n``` javascript\nimport {isRef} from '@vue/composition-api'\nconst objValue = isRef(obj) ? obj.value : obj\n```\n\n### toRefs的使用\n\ntoRefs函数的作用是将reactive()创建出来的对象，转换成普通的对象，只不过这个对象的每一个属性都是ref类型的响应式数据。\n\n应用场景:\n\n``` vue\n<template>\n\t<div>\n        {{ count }}\n        <button @click=\"increment\">+1</button>\n    </div>\n</template>\n<script>\nimport {toRefs, reactive} from '@vue/composition-api'\n\nexport default {\n    setup () {\n        \n        const state = reactive({\n            count: 0\n        })\n        \n        // 定义页面上的事件处理函数\n        const increment = () => {\n            state.count++\n        }\n        \n        // 在setup中返回一个对象供页面调用 可以包含响应式的数据，也可以包含供页面调用的函数\n        return {\n            ...toRefs(state),\n            // 增加的处理函数\n            increment\n        }\n    }\n}\n</script>\n```\n\n在vue3中推荐在setup中写函数而不是在`metods`中写， 但是如果要返回响应式的值，又要返回函数的话，直接使用`...state`会让响应式失去作用，所以就有了`toRefs`函数，他把对象中所有的属性改为了ref类型，所以给页面提供了响应式的功能。\n\n### computed计算属性\n\n `computed()` 用来创建计算属性，`computed()` 函数的返回值是一个 `ref` 的实例。使用 `computed` 之前需要按需导入： \n\n``` javascript\nimport { computed } from '@vue/composition-api'\n```\n\n只读计算属性\n\n``` vue\n<template>\n  <div>\n      count的值：{{ count }}\n      计算属性：{{ plusOne }}\n      <button @click=\"count += 1\">+</button>\n  </div>\n</template>\n\n<script>\nimport { computed,ref } from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const count = ref(0)\n        const plusOne = computed(() => count.value + 1)\n        return {\n            count, plusOne\n        }\n    }\n}\n</script>\n```\n\n可读写的计算属性:\n\n``` javascript\n\nconst count = ref(0)\nconst plusOne = computed({\n    get: () => count.value + 1\n    set: (val) => count.value =  val - 1\n})\n//为计算属性赋值会触发set函数\nplusOne.value = 10\nconsole.log(count.value) // 输出9\n```\n\n### watch\n\n和vue2.x的`watch`作用一致，只是用法不一样\n\n#### 基础用法\n\n``` javascript\nimport { watch, ref } from '@vue/composition-api'\nconst count = ref (0)\n// 每次改变count 都会打印count的值\nwatch(() => console.log(count.value))\n```\n\n#### 监听reactive和ref\n\n``` javascript\nconst state = reactive({count: 0})\n// 监视state.count的数据变化\nwatch(\n\t() => state.count, // 第一个参数设置监听的数据源\n    (count, oldCount) => { // 第二个参数为监听方法\n        // TODO\n    },\n    {\n        lazy: true, // watch创建的时候会自动执行一次，设置lazy可以关闭\n    }\n)\n// 监听ref\nconst c2 = ref(0)\nwatch(c2, \n\t(val, oldVal) => {\n    \t// TODO\n\t}    \n)\n```\n\n在vue2.x中监听多个数据源，需要写多个watch,在vue3中支持监听多个数据源:\n\n#### 监听多个数据源:\n\n``` javascript\nconst state = reactive({ count: 0, name: 'zs' })\n\nwatch(\n  [() => state.count, () => state.name], // Object.values(toRefs(state)),\n  ([count, name], [oldCount, oldName]) => { // 按顺序解构赋值\n    console.log(count) // 新的 count 值\n    console.log(name) // 新的 name 值\n    console.log('------------')\n    console.log(oldCount) // 旧的 count 值\n    console.log(oldName) // 新的 name 值\n  },\n  {\n    lazy: true \n  }\n)\n\nsetTimeout(() => {\n  state.count++\n  state.name = 'ls'\n}, 1000)\n```\n\n监听多个ref:\n\n``` javascript\nconst count = ref(0)\nconst name = ref('zs')\n\nwatch(\n  [count, name], // 需要被监视的多个 ref 数据源\n  ([count, name], [oldCount, oldName]) => {\n    console.log(count)\n    console.log(name)\n    console.log('-------------')\n    console.log(prevCount)\n    console.log(prevName)\n  },\n  {\n    lazy: true\n  }\n)\n\nsetTimeout(() => {\n  count.value++\n  name.value = 'xiaomaolv'\n}, 1000)\n```\n\n#### 清除watch监视\n\n在组件销毁的时候会自动清除watch的监听，但是如果需要手动清除的话可以用以下的方法\n\n```\nconst stop = watch(() => {})\n// 调用watch的返回值就可以停止监听\nstop()\n```\n\n#### 清除无效的异步任务\n\n 有时候，当被 `watch` 监视的值发生变化时，或 `watch` 本身被 `stop` 之后，我们期望能够清除那些无效的异步任务，此时，`watch` 回调函数中提供了一个 `cleanup registrator function` 来执行清除的工作。这个清除函数会在如下情况下被调用： \n\n- watch 被重复执行了\n- watch 被强制 `stop` 了\n\n**Template 中的代码示例如下**：\n\n```html\n/* template 中的代码 */ <input type=\"text\" v-model=\"keywords\" />\n```\n\n**Script 中的代码示例如下**：\n\n```js\n// 定义响应式数据 keywords\nconst keywords = ref('')\n\n// 异步任务：打印用户输入的关键词\nconst asyncPrint = val => {\n  // 延时 1 秒后打印\n  return setTimeout(() => {\n    console.log(val)\n  }, 1000)\n}\n\n// 定义 watch 监听\nwatch(\n  keywords,\n  (keywords, prevKeywords, onCleanup) => {\n    // 执行异步任务，并得到关闭异步任务的 timerId\n    const timerId = asyncPrint(keywords)\n\n    // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务\n    onCleanup(() => clearTimeout(timerId))\n  },\n  // watch 刚被创建的时候不执行\n  { lazy: true }\n)\n\n// 把 template 中需要的数据 return 出去\nreturn {\n  keywords\n}\n```\n\n实现之后的效果是,等输入框输入暂停时才会触发打印，有了这个功能防抖就好做了 (;￢＿￢)  \n\n### New LifeCycle Hooks\n\n新的生命周期方法，可以按需导入到组件中，且只能在 `setup()` 函数中使用，代码示例如下： \n\n``` javascript\nimport { onMounted, onUpdated, onUnmounted } from '@vue/composition-api'\n\nconst MyComponent = {\n  setup() {\n    onMounted(() => {\n      console.log('mounted!')\n    })\n    onUpdated(() => {\n      console.log('updated!')\n    })\n    onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  }\n}\n\n```\n\n下面的列表，是 `vue 2.x` 的生命周期函数与新版 Composition API 之间的映射关系：\n\n- ~~`beforeCreate`~~ => use `setup()`\n- ~~`created`~~ => use `setup()`\n- `beforeMount` => `onBeforeMount`\n- `mounted` => `onMounted`\n- `beforeUpdate `=> `onBeforeUpdate`\n- `updated` => `onUpdated`\n- `beforeDestroy` => `onBeforeUnmount`\n- `destroyed` => `onUnmounted`\n- `errorCaptured` => `onErrorCaptured`\n\n### provide和inject\n\n`provide()`和`inject()`用于实现嵌套组件之间的数据传递，这两个函数只能在setup中使用。\n\n父组件使用provide向下分享数据，inject在子组件中进行接收数据\n\n### 用法\n\n父组件传递主题颜色\n\n``` vue\n// 父组件\n<template>\n  <div>\n    <h1 :style=\"{color: color}\">父节点</h1>\n    <comp1 />   \n  </div>\n</template>\n\n<script>\nimport { provide,ref } from '@vue/composition-api'\nimport inject1 from './inject1'\nexport default {\n    components: {\n        'comp1': inject1\n    },\n    setup(props, ctx) {\n        const color = ref('#fad0c4')\n        provide('textColor', color)\n\n        setTimeout(() => { // 2秒后变为淡蓝色\n            color.value = '#8fd3f4'\n        },2000)\n        return {\n            color\n        }\n    }\n}\n</script>\n\n// 子组件 inject1.vue\n<template>\n  <div>\n      <h2 :style=\"{color: color}\">子组件</h2>\n      <inject2 />\n  </div>\n</template>\n\n<script>\ninject\nimport {inject} from '@vue/composition-api'\nimport inject2 from './inject2'\nexport default {\n    components: {\n        'inject2': inject2\n    },\n    setup(props, ctx) {\n        const color = inject('textColor')\n        return {\n            color\n        }\n    }\n}\n</script>\n// 孙组件 inject2.vue\n<template>\n  <div>\n      <h3 :style=\"{color: color}\">孙组件</h3>\n  </div>\n</template>\n\n<script>\nimport {inject} from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const color = inject('textColor')\n        return {\n            color\n        }\n    }\n}\n</script>\n```\n\n### template refs\n\nref也支持vue2.x中的 ref属性，下面看看是怎么实现的\n\n#### 引用页面元素和组件\n\n``` vue\n<template>\n\t<div>\n       \t<h1 ref=\"refTitle\"></h1>\n        <comp1 ref=\"refComp\"/>\n    </div>\n</template>\n<script>\nimport {ref, onMounted} from '@vue/composition-api'\nimpot comp1 from './comp'\nexport default {\n    components: {\n        comp1\n    },\n    setup(props, ctx) {\n     \tconst refTitle = ref(null)\n        const refComp = ref(null)\n        onMounted(() => { // onMounted后dom才渲染完成\n            refTitle.value.style.color = 'red'\n        })\n        return { // 保持和元素中的ref一致\n            refTitle,\n            refComp\n        }\n    }\n}\n</script>\n\n```\n\n### createComponent\n\n> 这个函数是非必须的，除非你想要结合typescript进行vue项目的开发\n\n``` typescript\nimport {createComponent} '@vue/composition-api'\nexport default createComponent({\n    props: {\n        foo: String\n    },\n    setup(props) {\n     \tprops.foo   \n    }\n})\n```\n## 总结\n\n把`composition-api`都体验了一遍，虽然没有做像样的例子，但是感觉还是比较容易上手的，特别如果是有2.x经验的话。\n看的出来使用`this`的地方变少或者没有了。还有就是在vue3中应该不能像以前那样用Mixins了，Mixins本身有个缺点就是数据来源不明，如果引用的多的话更是如此。\n还有就是对ts的支持更加友好了,这里我还没体验过不作过多说明。\n\n## Tips\n\nVue 3将支持全局tree-shaking,这意味着如果你不使用它的某些功能，这些则不会出现在你打包的文件中。\n\n``` javascript\nimport {nextTick, observable} from 'Vue'\nnextTick(() => {})\nconst obj = objservable({})\n```\n\nVue3的响应式由`Object.defineProperty `换为`Proxy`后给对象，数组赋值不需要再使用`Vue.set`方法\n\n``` javascript\nVue.set(obj, key, value)\n=>\nthis.obj[key] = value\n```\n\n","tags":["vue"],"categories":["vue"]},{"title":"axios下载文件","url":"/haoge744.github.io/2019/10/22/axios下载文件/","content":"\n由于有些文件需要做权限处理，下载需要所以权限\n``` javascript\nfunction downloadFile (file) {\n    const fileId = file.id || file.response.data.id\n    const url =`${this.downUrl}/${fileId}`\n    axios({\n        method: 'get',\n        url: url,\n        responseType: 'arraybuffer',\n        headers: {\n            Authentication: this.token,\n            filename:'utf-8'\n        }\n    }).then(res => {\n        const fileStr = res.headers['content-disposition']\n        const fileName = decodeURI(fileStr.substr(fileStr.indexOf('filename=')+9))\n        let url = window.URL.createObjectURL(new Blob([res.data]))\n        let link = document.createElement('a')\n        link.style.display = 'none'\n        link.href = url\n        document.body.appendChild(link)\n        link.setAttribute('download', fileName)\n        link.target = '_blank'\n        link.click()\n        document.body.removeChild(link); //下载完成移除元素\n        window.URL.revokeObjectURL(url); //释放掉blob对象\n    }).catch(error => {\n        console.log(error)\n    })\n}\n```","tags":["javascript","axios"],"categories":["axios"]},{"title":"Vue inheritAttrs的使用","url":"/haoge744.github.io/2019/10/17/Vue-inheritAttrs的使用/","content":"\n## 介绍\n\n`Vue inheritAttrs`诞生于vue2.4.0版本,目的是为了解决父孙组件传递参数的问题。\n在以前如果要父组件要给孙组件传值只能给子组件设置一套值，然后再给孙组件再设置一套相同的值，这样代码太过冗余并且工作量，还有一个方法就是用`provide`和`inject`,但是貌似这个方法也不是很好，组件多的话很难控制。\n所以vue2.4发布后解决了这个问题，还增加了关于事件向上传递的相关api `$listeners`\n\n<!-- more -->\n\n如果你使用的是vue2.4之后的版本，那么当前的vue组件实例中会默认带一个属性，这个就是`$attrs`属性,这个属性用来保存没有在`props`中声明的参数属性。什么意思呢，就是你定义一个组件，这个组件的props只有一个count，但是我父组件调用的时候除了给了count，比如说还传递了一个:age=\"12\",那么子组件就可以通过`$attrs`来获取到age。\n\n``` vue\n// parent.vue\n<template>\n  <div>\n      <children :count=\"10\" :age=\"15\"/>\n  </div>\n</template>\n\n<script>\nimport children from './children'\nexport default {\n    components: {\n        children\n    }\n}\n</script>\n```\n\n``` vue\n//  children.vue\n<template>\n  <div>\n      {{ count }}\n      {{ $attrs.age }}\n  </div>\n</template>\n<script>\nexport default {\n    props: {\n        count: Number\n    },\n    mounted() {\n        console.log(this)\n    }\n}\n</script>\n```\n\n把children.vue实例打印出来如下图。\n![attrs](Vue-inheritAttrs的使用/attrs.png)\n\n比如说项目中有这样有个功能，弹出一个有table的dialog，只是表格的字段和查询条件不一样。并且很多地方用得到，这样最好是封装成一个组件，然后我要用element的dialog和table进行封装。\n\n![dialogTable](Vue-inheritAttrs的使用/table.png)\n\n``` vue\n\n<template>\n  <el-dialog\n    <!-- sync是不支持的,所以要额外写参数 -->\n    :visible.sync=\"visible\"\n    <!-- 给dialog组件传递参数 -->\n    v-bind=\"$attrs\">\n    <div style=\"padding: 5px;\">\n      <el-table class=\"data-table-container\" :data=\"tableData\" style=\"width: 100%\" v-loading=\"loading\" border>\n        <el-table-column type=\"index\" align=\"center\" label=\"序号\" v-if=\"showNumber\" width=\"50\">\n        </el-table-column>\n        <!-- 循环表格的列，并且给表格列设置绑定属性为item -->\n        <el-table-column v-for=\"(item, index) in head\" v-bind=\"item\" :key=\"index\">\n          <template v-slot=\"scope\">\n            <!-- 如果类型是slot的话给表格的列设置插槽 -->\n            <slot :name=\"item.prop\" v-if=\"item.type === 'slot'\" :data=\"scope.row\"></slot>\n            <template v-else>\n              {{ scope.row[scope.column.property] }}\n            </template>\n          </template>\n        </el-table-column>\n      </el-table>\n    </div>\n  </el-dialog>\n</template>\n\n<script>\n  import request from '@/utils/request'\n\n  export default {\n    name: 'tableGridDialog',\n    props: {\n      head: { // 表格的列\n        required: true\n      },\n      showNumber: {\n        type: Boolean,\n        default: true\n      },\n      url: {\n        type: String\n      },\n      params: {\n        type: Object\n      },\n      httpMethod: {\n        type: String,\n        default: 'get'\n      },\n      show: {\n        type: Boolean\n      },\n      formatDataMethod: {\n        type: Function\n      }\n    },\n    data() {\n      return {\n        tableData: [],\n        loading: false,\n        visible: false,\n      }\n    },\n    methods: {\n      initList() {\n        const queryData = {\n          url: this.url,\n          method: this.httpMethod\n        }\n        if (this.params) {\n          if (this.httpMethod.toLowerCase() === 'get') {\n            queryData.params = this.params\n          } else {\n            queryData.data = this.params\n          }\n        }\n        this.loading = true\n        request(queryData).then(res => {\n          this.loading = false\n          if (res.status === 200) {\n            // 如果有数据格式化方法，执行完之后赋值\n            if (this.formatDataMethod) {\n              this.tableData = this.formatDataMethod(res.data)\n            } else {\n              this.tableData = res.data\n            }\n          }\n        }).catch(error => {\n          console.log(error)\n          this.loading = false\n        })\n      }\n    },\n    created() {\n\n    },\n    watch: {\n      params: {\n        handler(val) {\n          if (val) this.initList()\n        },\n        immediate: true\n      },\n      url (val) {\n        if (val) this.initList()\n      },\n      show: {\n        handler(val) {\n          if (val !== this.visible) {\n            this.visible = val\n          }\n        },\n        immediate: true\n      },\n      visible(val) {\n        if (val !== this.show) {\n          this.$emit('update:show', val)\n        }\n      }\n    }\n  }\n</script>\n```\n\n使用\n\n``` vue\n<template>\n\t<tableGridDialog\n      :url=\"changeUrl\"\n      width=\"740px\"\n      title=\"xx明细\"\n      :params=\"param\"\n      :head=\"changeDesignHead\"\n      :show.sync=\"showchangeDesign\">\n      <template v-slot:createTime=\"{data}\">\n        {{ data.createTime | dateFormat}}\n      </template>\n    </tableGridDialog>\n\n</template>\n\n<script>\nexport default {\n    data () {\n        changeUrl: 'xxx',\n        param: {\n          queryId: 'xxx'  \n        },\n        changeDesignHead: [\n          {\n            prop: 'createTime',\n            label: '日期',\n            align: 'center',\n            type: 'slot'\n          }, {\n            prop: 'name',\n            label: '变更名称',\n            align: 'center',\n            type: 'slot'\n          }, {\n            prop: 'content',\n            label: '内容',\n            align: 'center',\n            width: '200px'\n          }\n        ]\n    },\n    // ...\n}\n</script>\n\n```\n\n使用的话代码也比较简单，不作太多讲解了。总结来说在组件嵌套这块解决了很大的问题。\n\n\n","tags":["vue"],"categories":["vue"]},{"title":"win10更新后提示未安装任何音频设备","url":"/haoge744.github.io/2019/10/10/win10更新后提示未安装任何音频设备/","content":"\n某天正常开启自己的笔记本电脑发现右上角的音量图标划伤了叉号，明明前几天用的好好的，最多就是windows自动更新了下系统，没想到就给更新挂了!!!∑(ﾟДﾟノ)ノ \n\n点击了音量图标，然后弹出个框一直在loading,读取完之后提示我重启之后就好了，但是每次重启之后还是这样提示我重启(╬￣皿￣)=○，无限循环。。。\n\n最后百度后找到了一下三种解决方法\n\n### 更新声卡驱动\n\n下载了驱动精灵安装,并更新声卡驱动到最新版本，并没有啥用￣へ￣\n\n### 卸载声卡设备\n\n操作步骤是这样的：\n\n1. 右键此电脑 => 管理\n\n2. 左侧菜单切换到设备管理器\n3. 找到声音、视频和游戏控制器\n4. 把里面关于声音的设备全部卸载了\n5. 重启电脑 再回到设备管理器右键选择 `扫描检测硬件改动`\n\n但是我试了这种方法也不行\n\n### 秘之方法\n\n最后在csdn的秘之方法，据说是国外大神的。\n\n直接在命令行输入\n\n``` bash\nnet localgroup Administrators /add networkservice\nnet localgroup Administrators /add localservice\n```\n\n没想到意外解决了，所以记下此次记录，希望帮助更多人。\n\n\n","tags":["生活"],"categories":["生活"]},{"title":"webpack基础使用及配置","url":"/haoge744.github.io/2019/10/07/webpack基础使用及配置/","content":"\nVueCli用的比较多了，但是没有系统性的学过webpack,今天不基于任何脚手架工具单纯用webpack搭建一个小项目,加深自己对webpack的理解,以及一些常用配置。另外本文使用的是`webpack4.41.0`,在一些插件的使用上用了最新的方案。\n\n<!-- more -->\n\n## 初始化\n\n``` bash\n-- 创建一个项目文件夹名字任意\n-- 新建src/main.js\n-- 新建src/index.html\ncd 项目文件夹\n-- 初始化package.json\nnpm init -y \n\n-- 安装相关组件\nyarn\nyarn add webpack --dev\nyarn add html-webpack-plugin --dev\nyarn add webpack-dev-server --dev\nyarn add webpack-cli --dev\n```\n\n## 创建配置文件\n\n``` javascript\n// 创建webpack.config.js\nconst path = require('path')\nconst htmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:  path.join(__dirname, './src/index.js'),// 入口文件\n    output: { // 输出文件\n      path: path.join(__dirname, './dist'),\n      filename: 'bundle.js'\n    },\n    plugins: [ // 插件\n        new htmlWebpackPlugin({\n            template: path.join(__dirname, './src/index.html'),\n            filename: 'index.html'\n        })\n    ]\n}\n```\n\n### 配置启动命令行\n\n``` json\n// package.json\n{\n  ...\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n      // --open自动打开浏览器 端口 3000, 热修复\n    \"dev\": \"webpack-dev-server --open --port 3000 --hot\"\n  },\n}\n\n```\n\n### 添加模式\n\n作用是为了区分生产环境和测试环境\n\n``` \n// package.json\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --open --port 3000 --hot --mode development\",\n    \"prod\": \"\"webpack-dev-server --open --port 3000 --hot --mode production\"\n  },\n}\n```\n\nmode属性是`webpack4.0.0`后增加的，内容可以是`development`和`production`,在dev和prod环境下`process.env.NODE_ENV`打印的值分别为development和production。\n\n项目是可以跑起来了,但是还有一些欠缺，没有对css/scss、图片资源等资源进行处理；还有没有对es6语法进行兼容性问题处理。这个时候就需要用到webpack的loader了。\n\n## 添加loader\n\n在src中新建`css/index.scss`文件和目录,然后给一个div设置背景图片\n\n![比如这样](webpack基础使用及配置/scss.png)\n\n在main.js中引入\n\n```\nimport './css/index.scss'\n```\n\n然后运行后设置的css是无效的，因为没有给css和scss配置对应的loader，代码没有转换，所以会出现错误。\n\n![error](webpack基础使用及配置/error.png)\n\n### **配置样式loader**\n\n``` bash\nyarn add style-loader css-loader sass-loader node-sass url-loader file-loader --dev\n```\n修改`webpack.config.js`\n``` javascript\nmodule.exports = {\n    // 入口、输出、插件等配置在这里省略...\n    module: {\n        rules: [\n           //some rule loaders... ,\n            { test: /\\.css$/, use: ['style-loader', 'css-loader'] },\n            { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] },\n            { test: /\\.(png|gif|bmp|jpg)$/, use: ['url-loader?limit=5000']},\n        ]\n    }\n}\n```\n\n### **配置babel**\n\n``` bash\nyarn add babel-core babel-loader babel-plugin-transform-runtime babel-preset-env babel-preset-stage-0 --dev\n```\n修改`webpack.config.js`\n``` javascript\nmodule.exports = {\n    // 入口、输出、插件等配置在这里省略...\n    module: {\n        rules: [\n           //some rule loaders... ,\n           // 对js文件使用babel-loader, 排除node_modules中的文件\n           { test: /\\.js$/, use 'babel-loader', exclude: /node_modules/ }\n        ]\n    }\n}\n```\n\n在根目录新建`.babelrc`文件\n\n``` json\n// json格式\n{\t\n    // 刚刚装的babel-preset-x 在这里写上\n    \"presets\": [\"env\", \"stage-0\"],\n    // 使用的插件 babel-plugin-transform-runtime\n    \"plugins\": [\"transform-runtime\"]\n}\n\n```\n关于babel相关的配置及.babelrc文件的编写可以查看[这篇文章](https://excaliburhan.com/post/babel-preset-and-plugins.html)\n\n配置完后就可以使用scss、图片、es6等最新语法了\n\n----- \n\n## 打包\n\n打包前需要安装几个全局依赖(如果没有安装的话)\n\n``` bash\nnpm install webpack -g\nnpm install webpack-cli -g\n```\n\n然后直接在当前目录执行`webpack`命令就可以打包到`dist`目录下了\n\n### 打包相关配置优化\n\n很多时候我们开发和打包的相关配置希望单独存放\n\n复制`webpack.config.js`重命名`webpack.config.build.js`\n\n在`package.json`中添加`build`命令\n\n``` json\n{\n    // ... \n    \"scripts\": {\n        // ... some scripts\n        // 自定义设置文件\n        \"build\": \"webpack --config webpack.config.build.js --mode production\"\n    }\n}\n```\n\n然后运行 `npm run build`就okl了\n\n#### 优化图片路径及名称\n\n``` javascript\n{ test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000] }\n// 改为\n// 图片名称改为8为哈希值-图片名.后缀名, 路径生成到images下面                              \n{ test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000&name=images/[hash:8]-[name].[ext]'] }\n```\n\n#### 每次打包前删除dist文件\n\n安装插件\n\n``` bash\nyarn add clean-webpack-plugin --dev\n```\n\n在config中添加\n\n``` javascript\nconst clearWebpackPlugin = require('clean-webpack-plugin')\n\nmodule.exports = {\n\t// ...\n    plugins: [\n        // 数组中传入需要删除的文件夹名\n        new clearWebpackPlugin(['dist'])\n    ]\n}\n\n------------- 新写法----------------------\nconst {CleanWebpackPlugin} = require('clean-webpack-plugin')\nmodule.exports = {\n\t// ...\n    plugins: [\n        // 数组中传入需要删除的文件夹名\n        new clearWebpackPlugin()\n    ]\n}\n```\n\n### 抽取第三方包\n\n在开发项目中会用到各种各样的第三方包,我们目前的这个打包方式会把第三方包和自己写的业务代码都放在bundle.js文件中，这样太臃肿了。\n\n``` javascript\n// 修改webpack.config.build.js文件\nconst webpack = require('webpack') // 导入webpack\n// 修改entry入口节点 把原来的入口文件改为对象\nmodule.exports = {\n    entry: { // 配置入口节点\n        app: path.join(__dirname, './src/main.js'),\n        // 这个名字要和chunk插件中的name对应\n        vendors: ['jquery','moment'] // 数组内为要分割的第三方包\n    },\n// 修改plugins\n// ------------------ 这是 webpack 3.x.x的写法 -----------------------\n    plugins: [\n        ...\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'vendors', // 指定要抽离的入口名称\n            filename: 'vendors.js' // 打包时除了会有一个bundle.js还有一个vendors.js文件里面存放了第三方包\n        })\n    ]\n// ------------------  webpack 4.x.x的写法 -----------------------\n    // 配置optimization(和entry同级的属性)\n    optimization: {\n        splitChunks: {\n            cacheGroups: {\n                commons: {\n                    name: \"vendors\",\n                    chunks: \"initial\",\n                    minChunks: 2\n                }\n            }\n        }\n    },\n}\n```\n\n随着webpack4升级chunk得配置也发生了变化\n\n![chunk](webpack基础使用及配置/chunk.png)\n\n[相关链接](https://webpack.docschina.org/plugins/split-chunks-plugin/)\n\n### html-webpack-plugin的优化\n\n``` \n// 修改打包配置文件\n{\n\tplugins: [\n        new htmlWebpackPlugin({\n            template: path.join(__dirname, './src/index.html'),\n            filename: 'index.html',\n            minify: { // html优化项\n                collapseWhitespace: true,// 清除多余的空格\n                removeComments: true, // 清除注释\n                removeAttributeQuotes: true // 清除属性上的双引号\n            }\n        }),\n\t]\n}\n```\n\n还有更多选项[Github](https://github.com/kangax/html-minifier#options-quick-reference)\n\n### css相关优化\n\n#### 抽取css文件\n\n##### 安装插件\n\nwebpack 3.x.x使用**extract-text-webpack-plugin**(这里不做介绍)\n\n```bash\nnpm install --save-dev mini-css-extract-plugin\n```\n\n[github](https://github.com/webpack-contrib/extract-text-webpack-plugin)\n\nwebpack 4.x.x使用**mini-css-extract-plugin**\n\n[github地址](https://github.com/webpack-contrib/mini-css-extract-plugin)\n\n```\nnpm install --save-dev mini-css-extract-plugin\n```\n\n##### 修改配置文件\n\n``` javascript\n// webpack.build.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin') // 引入插件\n\nmodule.exports = {\n    plugins: [\n        // ... some another plugins\n        new MiniCssExtractPlugin({ \n            filename: '[hash:8]-[name].css',\n            chunkFilename: '[id],css',\n            ignoreOrder: false, // Enable to remove warnings about conflicting order\n        })\n    ],\n    module: {\n        rules: [        \n        \t{ \n                test: /\\.css$/, \n                // use: ['style-loader', 'css-loader'] // 注释之前的loader\n                use: [\n                    {\n                        loader: MiniCssExtractPlugin.loader,\n                        options: {\n                            publicPath: (resourcePath, context) => {\n                                // 资源路径，如果你的css打包至css/xxx.css中，那么要返回../\n                                return './';\n                            },\n                        }\n                    },\n                    // style-loader不能引入否则会报错\n                    'css-loader'\n                ]\n            },\n            { \n                test: /\\.scss$/, // 配置scss\n                // use: ['style-loader', 'css-loader', 'sass-loader']\n                use: [\n                    {\n                        loader:MiniCssExtractPlugin.loader,\n                        options: {\n                            publicPath: (resourcePath, context) => {\n                                return './';\n                            },\n                            hmr: process.env.NODE_ENV === 'development'\n                        },\n                    },\n                    // style-loader不能引入否则会报错\n                    'css-loader',\n                    'sass-loader'\n                ]\n            },\n        ]\n    }\n}\n```\n\n","tags":["webpack"],"categories":["webpack"]},{"title":"typescript随手笔记1","url":"/haoge744.github.io/2019/10/02/typescript随手笔记1/","content":"\n## 介绍\n\nTypeScript是Javascript的超集，具有静态类型特性，旨在简化大型JavaScript应用程序的开发，也被称为Javascript that scales(可扩展的JavaScript)\n\n<!-- more -->\n\n### 优点\n\n- 在开发周期中能更早地捕获潜在的错误。\n- 管理大型代码库\n- 更易于重构\n- 更易于团队合作：代码的耦合性越强，不同开发人员访问代码库时越不容易造成无意的破坏\n- 文档特性：类型本身就是一种文档信息，方便日后开发者本人或者其他开发者查询。\n\n### 缺点\n\n- 需要学习周期\n- 类型错误多种多样\n- 配置极大地影响运行\n\n## TS的类型\n\n#### Boolean\n\n``` typescript\nconst loading: boolean = true;\n```\n\n#### Number\n\n``` typescript\nconst decimal: number = 1;\nconst binary: number = 0b110;\n```\n\n#### String\n\n``` typescript\nconst str: string = 'hello world'\n```\n\n#### Array\n\n``` typescript\nlet arr: Array = [2,4,5,6]\n// 使用泛型\nlet arr2: Array<number> = [2,6,55]\n```\n\n#### Tuple(元组)\n\n数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n\n元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。\n\n``` typescript\nlet tom: [string, number] = ['Tom', 25];\n```\n\n#### Any (任意类型)\n\n``` typescript\nlet variable: any = 123\nvariable = 'bbb'\nvariable = [12,23]\n```\n\n#### void 空值\n\nvoid表示没有任何类型。它通常用作没有返回值的函数的返回类型\n\n``` typescript\nfunction sayHello(name: string): void {\n    console.log(`hello ${name}`)\n}\n```\n\n#### Never\n\nneverl类型表示的是那些用不存在的值得类型。一般用于错误处理函数\n\n``` typescript\nfunction error(message: string): never {\n    throw new Error(message);\n}\n```\n\n#### 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n``` typescript\nvar a: string | number = 'abc'\na = 212\n\n```\n\n#### Null & Undefined\n\n在 TypeScript 中，可以使用 `null` 和 `undefined` 来定义这两个原始数据类型：\n\n``` typescript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n`undefined` 和 `null` 是所有类型的子类型。也就是说 `undefined` 类型的变量，可以赋值给 `number` 类型的变量：\n\n```\n// 这样不会报错let num: number = undefined;\n// 这样也不会报错let u: undefined;let num: number = u;\n\n// 这样会报错\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n下一篇会写些关于接口和类相关的内容\n\n> 更多详细内容推荐阅读[此篇教程](https://ts.xcatliu.com/)","tags":["typescript"],"categories":["typescript"]},{"title":"react事件this指向问题","url":"/haoge744.github.io/2019/10/02/react事件this指向问题/","content":"\nreact 在事件绑定和html不同的几点:\n\n1. react事件命名使用驼峰命名法，onclick要写成onClick,onchange写成onChange\n\n2. 事件赋值要加{}而不是属性赋值的方式如:\n\n   ``` html\n   dom:\n   <button onclick=\"clickHandler()\">按钮</button>\n   react:\n   <button onClick={clickButton}>按钮</button>\n   ```\n<!-- more -->\n\n事件处理\n\n``` react\nclass MyComponent extends React.Component {\n    \n    construct (props){\n        super(props)\n        this.setState = {\n            count: 0\n        }\n    }\n    \n    handlerClick (event) {\n        const number = ++ this.state.number;\n        this.setState = {\n            count: number\n        }\n    }\n    \n    render () {\n        return (\n        \t<button onClick={this.handlerClick(event)}>按钮</button>\n        )\n    }\n}\n```\n\n### this指向问题\n\n1. 使用es6箭头函数\n\n``` jsx\nclass MyComponent extends React.Component {\n    constructor (props) {\n        super(props);\n        this.setState = {\n            count: 0\n        }\n    }\n    \n    render () {\n        return (\n        \t<button onClick={(event) => {console.log(this.state.count)}}>按钮</button>\n        )\n    }\n    \n}\n\n```\n\n **注：直接在render方法中定义事件处理函数的最大问题是，每次render调用时都会创建一个新的事件处理函数，给组件带来额外的开销，当组件的层级越低，开销就越大，组件的任何上一层级组件的变化都会触发这个组件的render方法（一般可以忽略）。** \n\n2. 使用组件的方法\n\n``` jsx\nclass MyComponent extends React.Component {\n    constructor (props) {\n        super(props);\n        this.setState = {\n            count: 0\n        }\n        this.handlerClick = this.handlerClick.bind(this)\n    }\n\t\n    handlerClick(event) {\n        const number = ++ this.state.count\n        this.setState = {\n            count: number\n        }\n    }\n    render () {\n        return (\n        \t<button onClick={this.handlerClick}> 按钮 </button>\n        )\n    }\n    \n}\n\n\n```\n\n **注：这种方法的好处是每次render渲染都不会重新创建一个回调函数，没有额外的性能损失，但是如果在一个组件中有很多的事件函数时这种在构造函数中绑定this的方法会显得繁琐，还可以直接在给事件属性直接赋值时绑定this；** \n\n3. 使用bind方法\n\n``` jsx\nclass MyComponent extends React.Component {\n    constructor (props) {\n        super(props);\n        this.setState = {\n            count: 0\n        }\n        \n    }\n\t\n    handlerClick(event) {\n        const number = ++ this.state.count\n        this.setState = {\n            count: number\n        }\n    }\n    render () {\n        return (\n        \t<button onClick={this.handlerClick.bind(this)}> 按钮 </button>\n        )\n    }\n}\n```\n\n\n\n``` jsx\n\nclass MyComponent extends React.Component{\n\n    constructor(props){\n        super(props);\n        this.setState={\n            list:[1,2,3,4,5],\n            current:1\n        }\n    }\n    //每点击一项时，将点击项设置为当前选中项，因此需要将点击项作为参数传递\n\n    handleClcik(item，event){\n        this.setState={\n            current:item\n        }\n    }\n\n    render(){\n        <ul>\n            {\n                {/*bind除了绑定this，还绑定item作为参数,供handleClick使用*/}\n                this.state.list.map((item)=>(\n                    <li className={this.state.current==item?\"current\"：\"\"} onClick={this.handleClick.bind(this,item)}>{item}</li>\n                ))\n            }\n        </ul>\n    }\n```\n\n3. 属性初始化语法(property initializer syntax)** \n\n使用es7的property initializers 会自动为class中定义的方法绑定this，列如:\n\n  \n\n``` jsx\nclass MyComponent extends React.Component{\n    constructor(props){\n        super(props);\n        this.setState={number:0};\n    }\n    handleClcik=(event)=>{\n        const number=++this.state.number;\n        this.setState={\n            number\n        }\n    }\n    render(){\n        <div>{this.state.number}</div>\n        {/*事件属性赋值和this绑定同时*/}\n        <button onClcik={this.handleClick}>点我</button>\n    }\n}\n```\n\n此种方法既不需要再构造函数中绑定this，也不需要担心重复渲染导致重复创建的问题，但：\n\n\nproperty initializers还处在实验性阶段，默认不支持，不过官方的脚手架create-react-app默认支持这个特性,如果你想要在你的项目中使用这个默认的特性，你可以在项目中引入babel的transform-class-properties插件获取这个特性的支持。\n\n以上为react事件处理的三种方式及this问题的全部内容，如下不当之处欢迎指正。。。。\n\n [原文出处链接](https://blog.csdn.net/weixin_39939012/article/details/80873444) ","tags":["react"],"categories":["react"]},{"title":"moment.js基础使用","url":"/haoge744.github.io/2019/09/28/moment-js基础使用/","content":"\n## moment.js基础使用\n\n开发中不可避免的会经常碰到一些对日期的操作，使用moment.js可以很简单的实现很多对日期的一些操作，像日期的格式化，转换，计算，当月的第一天或最后一天等等之类的需求，它都可以快速实现。\n\n<!-- more -->\n\n#### 安装\n\nmoment.js也支持使用包管理器安装\n\n```bash\nnpm install moment\n// or \n<script src=\"moment.js\"></script>\n```\n\n#### 创建moment对象\n\n```javascript\nmoment() // 当前时间\nmoment().format('YYYY-MM-DD HH:mm:ss') // 当前事件格式化\nmoment('2019-12-12 ', 'YYYY-MM-DD') // 字符串格式化转为对象\nmoment(new Date().getTime()) // 使用时间戳毫秒转\nconst day = moment(\"1995-12-25\");\n```\n\n#### 格式化\n\n```javascript\nmoment().format('YYYY-MM-DD')\n```\n\n#### 日期计算\n\n```javascript\nmoment().days(3) // days函数取得是在周中的天数，比如传入3求的是下个周三的日期\nmoment().day(-7); // 上周三 (0 - 7)\n// weekday的用法和days大致相同\nmoment().weekday(3) // 获取本周三的日期\nmoment().weekday(-1) // 获取上周末的日期 相当于这周一减1的日期\nmoment().weekday(-10) // 获取上上周周五的日期 本周-10\n```\n\n#### 日期加减\n\n```javascript\nmoment().add(1, 'days') // 可以使用简写\nmoment().subtract(1, 'days') // 求昨天的日期\n```\n\n| Key          | Shorthand |\n| :----------- | :-------- |\n| years        | y         |\n| quarters     | Q         |\n| months       | M         |\n| weeks        | w         |\n| days         | d         |\n| hours        | h         |\n| minutes      | m         |\n| seconds      | s         |\n| milliseconds | ms        |\n\n#### 日期相减\n\n```javascript\n// 计算当前两个日期相差多少天\nmoment().diff(moment('2019-08-05', 'YYYY-MM-DD'), 'days')\n```\n\n#### 获取最后一天\n``` javascript\n// 获取当月最后一天的日期\nmoment().endOf('month').format('YYYY-MM-DD')\n// 获取当年最后一天的日期 \nmoment().endOf('year').format('YYYY-MM-DD')\n// 这样也可以获取当年最后一天的日期\nmoment().month(11).endOf('month')\nmoment('2018-05-24','YYYY-MM-DD').endOf('month') // 2018-05-31\n```\n\n\n我目前常用的也就是格式化和互相转换,还有日期相减之类的，具体更多方法请参照官方[api文档](http://momentjs.cn/docs/#/use-it/)\n\n","tags":["moment"],"categories":["javascript"]},{"title":"vue-cli3.0升级","url":"/haoge744.github.io/2019/09/15/vue-cli3-0升级/","content":"\n## 全局安装\n\n目前执行 `install Vue-cli -g`命令只会安装到Vue-cli 2.9.6,因为Vue cli以后的版本改了包名 改为了 @vue/cli\n\n所以要先卸载掉Vue-cli 2.x.x的版本,在进行安装\n\n```bash\nnpm uninstall -g vue-cli\nnpm install -g @vue/cli\n```\n\n``` bash\nyarn global remove vue-cli\nyarn global add @vue/cli\n```\n\n<!-- more -->\n## 创建vue-cli3项目\n\n```\nvue create <projectName>\n// 之后可以选择以下选项 (空格=单选 a=全选 i= 反选)\n1. Babel 使用babel做编译以兼容IE浏览器\n2. TypeScript 支持TypeScript\n3. Progressive Web App (PWA) support 支持pwa应用\n4. router 路由\n5. vuex 状态管理\n6. Css Pre-processors css 预处理\n7. Linter / Formatter 代码风格校验\n8. Unit Testing  单元测试\n9. E2E Testing 端对端测试\n```\n\n除了使用命令行创建项目还可以使用图形化界面创建\n\n``` bash\nvue ui\n```\n\n运行命令后会自动打开浏览器，点击选择好目录可以点击`在此创建新项目`创建项目了，\n\n![img](vue-cli3.0升级/ui1.png)\n\n然后输入一些基本信息\n\n![img](vue-cli3.0升级/ui2.png)\n\n然后选择项目配置，我选了手动配置,然后可以选择一些基本功能，router,vuex,linter,css预处理之类的功能，css预处理有scss、less、stylus之类。全部选好之后就会自动创建项目了。\n\n![img](vue-cli3.0升级/ui3.png)\n\n创建完成后可以进入图形化的项目管理界面。功能分为5个大模块\n\n1. 项目仪表盘 可以做一些之运行任务、关闭端口、更新插件依赖的功能(可以自定义菜单)\n2. 插件 可以查看、安装插件。\n3. 依赖 可以查看、安装依赖。\n4. 配置 对Vue Cli、Eslint、Css编译进行配置\n5. 任务 一些运行、构建、lint之类的指令。\n\n![img](vue-cli3.0升级/ui4.png)\n\nvue-ui具体更多功能和效果需要自己动手去摸索。\n\n## 启动\n\n``` bash\ncd <project-name>\nnpm run serve\nnpm run build // 构建\n```\n\n启动参数:\n\n```text\nvue-cli-service serve [options] [entry]\n选项：\n\n  --open    在服务器启动时打开浏览器\n  --copy    在服务器启动时将 URL 复制到剪切版\n  --mode    指定环境模式 (默认值：development)\n  --host    指定 host (默认值：0.0.0.0)\n  --port    指定 port (默认值：8080)\n  --https   使用 https (默认值：false)\n```\n\n构建参数:\n\n```text\n用法：vue-cli-service build [options] [entry|pattern]\n\n选项：\n\n  --mode        指定环境模式 (默认值：production)\n  --dest        指定输出目录 (默认值：dist)\n  --modern      面向现代浏览器带自动回退地构建应用\n  --target      app | lib | wc | wc-async (默认值：app)\n  --name        库或 Web Components 模式下的名字 (默认值：package.json 中的 \"name\" 字段或入口文件名)\n  --no-clean    在构建项目之前不清除目标目录\n  --report      生成 report.html 以帮助分析包内容\n  --report-json 生成 report.json 以帮助分析包内容\n  --watch       监听文件变化\n```\n\n## 工程结构\n\n Vue-cli3目录\n\n``` \n┌─src            源码目录\n│  └─assets             资源目录\n│  └─components         组件目录\n│  └─api                后端交互相关模块(需自己手动添加,这里只是建议)\n│  └─views              所有路由组件\n│  └─router             所有路由配置文件目录\n│  └─store              所有状态管理配置文件目录\n│  └─main.js            vue入口文件\n│  └─App.js             入口vue文件\n├─package.json          项目基本信息,包依赖信息等\n├─platforms             存放各平台专用页面的目录，详见\n├─public                public静态资源文件，打包时会被复制到输出目录(dist)中\n│  └─index.html\n│  └─favicon.ico\n├─vue.config.js         可选配置文件，下面会介绍\n```\n\n![img](vue-cli3.0升级/dict.png)\n\n可以看到Vue Cli3和Vue Cli2相比少了config和build文件夹，少了很多配置文件，变得更加简洁。但是如果要修改webpack相关配置的话需要就用到`vue.config.js`文件了。\n\nvue.config.js部分属性说明:\n\n``` javascript\nmodule.export{\n    // 做文件打包后部署用的。如果你的公共路径是 http://www.xxx.com 那么使用默认的 '/'\n    // 如果是 http://www.xxx.com/app 则需要修改成'/app'\n    publicPath: '/', // 最新版本使用publicPath替代原来的 baseUrl\n    outputPath: 'dist', // 构建之后\n    lintOnSave: true, // 是否在保存时执行eslint检查\n    devServer: {\n        host: '',\n        port: 8181,\n        open: true, //配置自动启动浏览器\n        proxy: {\n            ...\n        }\n    },\n    configureWebpack: { // Object | Function\n        plugs: [\n        \tnew webpack.DefinePlugin({ // 使用definePlugin定义全局变量\n                'process.env.api_url': '',\n            })   \n        ]\n    },\n    chainWebpack(config) { // 使用chainWebpack自定义loader\n        config.module\n           .rule('svg')\n           .exclude.add(resolve('src/icons'))\n           .end()\n       config.module // 使用svg-sprite-loader组件加载svg文件\n          .rule('icons')\n          .test(/\\.svg$/)\n          .include.add(resolve('src/icons'))\n          .end()\n          .use('svg-sprite-loader')\n          .loader('svg-sprite-loader')\n          .options({\n            symbolId: 'icon-[name]'\n          })\n          .end()\n    },\n\tpluginOptions: {} // 第三方插件配置        \n}\n```\n\n关于`vue-config`的更多配置请参考[官方文档](https://cli.vuejs.org/zh/config/#vue-config-js)\n\n## 配置环境变量\n\n前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。\n\nVue Cli2.x.x的配置主要是在 `config/dev.env.js` 和`config/prod.env.js`中配置,但是到了Vue Cli3后这个配置文件没有了，但是不用担心，到了Vue Cli3中后这个功能变得更加灵活了，可以配置更多种环境变量。\n\n比如说我们配置开发、生产环境的后台地址变量:\n\n```\n// 新建 '.env.development' 文件\n# api地址\nVUE_APP_BASE_API = '/development/api'\n// 新建 '.env.production' 文件\n# api地址\nVUE_APP_BASE_API = '/production/api'\n```\n\n新建完成后会自动根据当前运行环境来读取对应配置文件中的变量了。\n\n### 自定义模式\n\n假如我们要创建一个预上线的环境需要另外一套配置,比如说叫做`staging`。\n\n在package.json中添加一个命令(也可以在启动时添加 ---mode参数)\n\n``` json\n\"scripts\": {\n    \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lint\": \"vue-cli-service lint\",\n    \"staging\": \"vue-cli-service serve --mode staging\"\n  },\n```\n\n创建 `.env.staging`, **文件后缀需要与 `--mode` 后面跟的值一样**\n\n``` \nNODE_ENV = 'production'\nVUE_APP_BASE_API = '/staging/api'\n```\n\n> 注意: *只有以 `VUE_APP_` 开头的变量会被 `webpack.DefinePlugin` 静态嵌入到客户端侧的包中。*\n\n关于环境变量和模式的[官方介绍文档](https://cli.vuejs.org/zh/guide/mode-and-env.html)\n\n## Tips\n\n安装Vue cli3前必须卸载Vue cli2,如果安装完Vue cli3 之后，还想用Vue-cli2.x 版本呢\nVue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 Vue init 功能，你可以全局安装一个桥接工具：\n\n``` bash\nnpm install -g @vue/cli-init\n// 安装完后 就还可以使用 vue init 命令\nvue init webpack my_project\n```","tags":["vue"],"categories":["vue"]},{"title":"node学习笔记","url":"/haoge744.github.io/2019/09/08/node学习笔记/","content":"\n## Node介绍\n\nnodejs的显著特性是它的异步和事件驱动机制。以及其短小精悍的标准库。\n目前nodejs分为两个版本，长期支持版(LTS)和当前版。\nnode内部使用了libuv的库来访问操作系统的非阻塞网络调用。node的动力源自V8 Javascript引擎\n\n<!-- more -->\n\n## Node Web程序\n\nNode Web项目的结构\n\n``` \n┌─package.json          一个包含依赖项列表和运行这个程序的命令的文件\n├─public/               静态资源文件夹,css和客户端js放在这里\n├─node_modules/         项目的依赖项都会撞到这里\n├─src                   放程序代码的文件夹，\n│  ├─app.js或index.js   设置程序的代码\n│  ├─modles/            数据库模型\n│  ├─views/             用来渲染页面的模板;\n│  ├─controllers或routes  http请求处理器\n│  └─middleware/        中间件组件\n├─another...            其它\n```\n\n### 开始一个新的web程序\n\n``` bash\nmkdir later\ncd later \nnpm init -fy\n-- 安装express\nnpm install express --save\n-- 安装消息体解析器\nnpm install body-parser --save\n```\n\n使用消息体解析器\n\n``` javascript\nconst express = require('express')\nconst app = express()\n\nconst articles = [{title: 'Example'}]\nconst bodyParser = require('body-parser')\n\napp.set('port', process.env.PORT || 3000)\napp.use(bodyParse.json())\napp.use(bodyParse.urlencoded(extended: true))\n\napp.post('/articles', (req, res, next) => {\n    const article = {title: req.body.title}\n    articles.push()\n    res.send(article)\n})\n```\n\n\n\n### 发送http请求\n\n``` javascript\t\nconst http = require('http')\n\nhttp.request({\n    host: 'localhost',\n    port: '8080',\n    path: '/index.html'\n}, res => {\n    const body = ''\n    res.on('data', data => {\n      body += data  \n    })\n    res.on('end', () => {\n        // 数据接收完成\n        console.log(body)\n    })\n})\n\n```\n\n### 连接mysql\n\n安装mysql模块\n\n``` bash\ncnpm install mysql --save\n```\n\n连接数据库:\n\n``` javascript\nconst mysql = require('mysql')\nconst connection = mysql.createConnection({\n    host:     'localhost',\n    user:     'root',\n    port:     '3306',\n    password: '123456',\n    database: 'test',\n    // charset 默认 UTF8_GENERAL_CI\n})\n\nconnection.connect()\n\n\nconnection.query('SELECT 1 + 1 AS soluction', (err, results, fields) => {\n    if (err) throw err;\n    console.log('The solution is :', results[0].solution)\n})\n\n```\n\n查询数据\n\n``` javascript\nconst sql = 'select * from websites'\n\nconnection.query(sql, (err, result) => {\n    if (err) {return}\n    console.log(result)\n})\n\n```\n\n插入数据\n\n``` javascript\nconst addSql = 'INSERT INTO websites(ID,name,url,alexa) VALUES(?,?,?,?)'\nconst addSqlParams = ['zxczxss','菜鸟工具', 'https://www.sss.com','2345']\nconnection.query(addSql,addSqlParams,(err, result) => {\n    if (err) {\n        console.log(err)\n    }\n    console.log(result)\n})\n```\n\n更新、删除用的也是query方法，改了sql而已， result的内容不一样\n\n## express 的使用\n\n``` javascript\nconst express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => {\n    res.send('Hello World')\n})\n\nconst server = app.listen(8081, () => {\n    const {address, port} = server.address()\n    console.log('服务器成功:访问地址为 http://%s:%s',address, port)\n    \n})\n```\n\n`res.send()`的参数可以是 Buffer、Object、String、Array\n\n`res.end()`参数类型只能是Buffer或String\n\n### app.get和use的区别\n\n1. use不区分get和post\n\n2. use 请求路径中只要第一部分只要匹配上即可， 并不要求请求路径完全相等\n\napp.all不限制method，要求路径完全匹配\n\n### 使用正则匹配\n\n``` javascript\napp.get(/^\\/index(\\/.+)*$/, (req, res) => {\n    res.send('hello world')\n})\n```\n\n### 通过req.params获取路由参数\n\n``` javascript\napp.get('/news/:year/:month/:day', (req, res) => {\n    res.send(req.params)\n})\n```\n\n### 处理静态资源\n\n``` javascript\nconst path = require('path')\napp.use('/', app.static(path.join(__dirname, 'public')))\n// app.use('/public', app.static(path.join(__dirname, 'public')))\n```\n\n### res常见方法\n\n1. res.send() 返回数据\n2. res.json([body]) 返回JSON格式数据 content-type会设置为application/json\n3. res.jsonp(body) 返回JSONP数据\n4. res.redirect([status], 'path') 重定向状态码非必填。\n\n4. res.sendFile(path,[,options],[,fn]) 发送文件\n5. res.status(code).end() 设置http返回的状态码\n\n## express路由模块封装\n\n错误做法:\n\n``` javascript\n// router.js\nmodule.exports = (app) => {\n    app.get('/index', (req,res) => {})\n    // app.get\n    // ...\n}\n\n// main.js:\nconst express = require('express')\nconst router = reqire('./router')\nconst app = express()\nrouter(app)\n```\n\n正确做法，解耦app对象:\n\n``` javascript\n// router.js\nconst express = require('express')\nconst router = express.Router()\nrouter.get('/index',(req,res) => {\n    req.send('index')\n})\n// 静态资源文件\nrouter.use('/resources', exporess.static())\n// ...\nmodule.exports = router\n\n// main.js\n\nconst express = require('express')\nconst router = require('router')\nconst app = express()\n\napp.use('/public',express.static('./public/' ))\n\napp.use(router)\n\napp.listen(3000, () => {\n    console.log('Server Running...')\n})\n```\n\n### 封装handler\n\n``` javascript\n// handler.js\nmodule.exports.index = (req, res) => {\n    res.send('index')\n}\n// router.js\nconst handler = require('./handler')\nrouter.get('index', handler.index)\n```\n\n### express 处理表单数据\n\n#### get表单处理\n\n``` javascript\napp.get('/form_get', (req, res) => {\n    const response = {\n        'first_name': req.query.firstName,\n        'last_name': req.query.lastName\n    }\n    res.send(response)\n})\n```\n\n#### post表单处理\n\n``` javascript\napp.post('/form_post', (req, res) => {\n    const response = {\n        'first_name': req.body.firstName,\n        'last_name': req.body.lastName\n    }\n    res.send(response)\n})\n\n```\n\n处理文件上传\n\n``` html\n<form action=\"/file_upload\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"image\" size=\"100\" />\n    <input type=\"submit\" value=\"上传\" />\n</form>\n```\n\n``` javascript\napp.post('/file_upload', (req, res) => {\n    console.log(req.files[0]) // 上传的文件信息\n    var des_file = __dirname + \"/\" + req.files[0].originalname;\n   \tfs.readFile( req.files[0].path, function (err, data) {\n        fs.writeFile(des_file, data, function (err) {\n         if( err ){\n              console.log( err );\n         }else{\n               response = {\n                   message:'File uploaded successfully', \n                   filename:req.files[0].originalname\n              };\n          }\n          console.log( response );\n          res.end( JSON.stringify( response ) );\n       });\n   });\n})\n```\n\n\n\n### 静态资源处理\n\n``` javascript\n//将静态文件目录设置为：项目根目录+/public\napp.use(express.static(__dirname + '/public'));\n//或者\napp.use(express.static(path.join(__dirname, 'public')));\n```\n\n### 使用cookie-parser管理cookie\n\n``` javascript\nconst express = require('express')\nconst cookieParser = require('cookie-parser')\nconst util = require('util')\n\nconst app = express()\napp.use(cookieParser)\napp.get('/', (req, res) => {\n    console.log('Cookies info:' util.inspect(req.cookies))\n})\n```\n\n\n\n## ejs模板引擎\n\n#### 安装ejs\n\n``` bash\ncnpm install ejs --save\n```\n\n#### 使用ejs\n\n``` javascript\nconst ejs = require('ejs')\nconst html = '<h1><%= name %></h1>'\nconst result = ejs.render(html,{name: '张飞'})\nconsole.log(result)\n```\n\n**渲染html文件**\n\nindex.html\n\n``` html\n<h1>\n    <%= title%>\n</h1>\n<ul>\n    <% for (var i = 0; i < 5; i++) { %>\n    \t<li> <%= msg %> </li>\n    <%> } </%>\n</ul>\n```\n\n``` javascript\nconst ejs = require('ejs')\nconst path = require('path')\nejs.renderFile(path.join(__dirname, 'index.html'), {\n    title: '标题',\n    msg: '你好ejs'\n}, (err, result) => {\n    console.log(result)\n})\n```\n\n","tags":["node"],"categories":["node"]},{"title":"webpack打包优化配置","url":"/haoge744.github.io/2019/09/03/webpack打包优化配置/","content":"\n## 关闭source-map配置\n\n\n关闭source-map之后可以大大减少打包后文件体积，关掉之后出现的弊端是如果出现报错信息，无法准确判断问题在哪。\n\n``` javascript\t\n// config/index.js\n// 把productionSourceMap属性的true改成false即可生效\nmodule.exports = {\n    build: {\n        productionSourceMap: true => false\n    }\n}\n\n```\n\n<!-- more -->\n\n## gzip压缩优化\n\ngzip可以优化页面加载时的速度，这个操作需要后台配合开启gzip,并且安装`compression-webpack-plugin`的时候要注意版本，像我用的`webpack 3.6`安装了`compression-webpack-plugin 3.0.0`然后就出现错误了。\n\n**开启gzip后,js会生成`js.gz`文件，会略微增加打包文件的体积:**\n\n``` javascript\t\n\n// Gzip off by default as many popular static hosts such as\n// Surge or Netlify already gzip all static assets for you.\n// Before setting to `true`, make sure to:\n// npm install --save-dev compression-webpack-plugin\nproductionGzip: false,\n```\n\n**服务端开启gzip压缩:**\n\n修改服务器的配置，这里的服务器是Nginx \n找到conf目录下的nginx.conf ,开启gzip,并设置gzip的类型，如下\n开启后，访问服务器的js文件时，会优先查找`.gz`文件，如果没有则会查找`.js`文件\n\n``` \ngzip on; #开启或关闭gzip on off\ngzip_disable \"msie6\"; #不使用gzip IE6\ngzip_min_length 100k; #gzip压缩最小文件大小，超出进行压缩（自行调节）\ngzip_buffers 4 16k; #buffer 不用修改\ngzip_comp_level 5; #压缩级别:1-10，数字越大压缩的越好，时间也越长\ngzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; #  压缩文件类型 \n```\n\n## HappyPack插件优化\n\n由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以Webpack 需要处理的事情需要一件一件的做，不能多件事一起做。\n我们需要Webpack 能同一时间处理多个任务，发挥多核 CPU 电脑的威力，[HappyPack](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack) 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。\n\n安装:\n\n```bash\nnpm i -D happypack\n```\n\n在webpack.config.js中添加plugins\n\n``` javascript\nmodule.exports = {\n    // ... 一些模块配置\n    plugins: [\n            // ... 一些插件配置\n        new HappyPack({\n            //用id来标识 happypack处理那里类文件\n          id: 'happyBabel',\n          //如何处理  用法和loader 的配置一样\n          loaders: [{\n            loader: 'babel-loader?cacheDirectory=true',\n          }],\n          //共享进程池\n          threadPool: happyThreadPool,\n          //允许 HappyPack 输出日志\n          verbose: true,\n        })\n    ]\n}\n```\n\n\n\n## 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块\n\n作用:优化打包速度\n\n因此我们首先需要在我们的项目根目录下创建一个 webpack.dll.config.js 文件。然后配置代码如下：\n\n``` javascript\nconst path = require('path');\nconst DllPlugin = require('webpack/lib/DllPlugin');\n\nmodule.exports = {\n  // 入口文件\n  entry: {\n    // 项目中用到该两个依赖库文件\n    jquery: ['jquery'],\n    echarts: ['echarts']\n  },\n  // 输出文件\n  output: {\n    // 文件名称\n    filename: '[name].dll.js', \n    // 将输出的文件放到dist目录下\n    path: path.resolve(__dirname, 'dist'),\n    /*\n     存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll\n     是为了防止全局变量冲突。\n    */\n    library: '_dll_[name]'\n  },\n  plugins: [\n    // 使用插件 DllPlugin\n    new DllPlugin({\n      /*\n       该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。\n       比如在jquery.manifest文件中有 name: '_dll_jquery'\n      */\n      name: '_dll_[name]',\n\n      /* 生成manifest文件输出的位置和文件名称 */\n      path: path.join(__dirname, 'dist', '[name].manifest.json')\n    })\n  ]\n};\n\n```\n\n在webpack.config.js中配置它:\n\n``` javascript\n// 引入 DllReferencePlugin\nconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n\n// 使用插件\nmodule.exports = {\n  plugins: [\n    // 告诉webpack使用了哪些第三方库代码\n    new DllReferencePlugin({\n      // jquery 映射到json文件上去\n      manifest: require('./dist/jquery.manifest.json')\n    }),\n    new DllReferencePlugin({\n      // echarts 映射到json文件上去\n      manifest: require('./dist/echarts.manifest.json')\n    })\n  ]\n}\n\n```\n\n**执行构建：**\n\n最后一步就是构建代码了，先生存第三方库文件，因此我们运行如下命令：\n\n```\nwebpack --config webpack.dll.config.js\n```\n\n在`package.json`中添加如下代码:\n\n```\n\"scripts\": {\n  \"dev\": \"webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline\",\n  \"build\": \"webpack --progress --colors --devtool cheap-module-source-map\",\n  \"build:dll\": \"webpack --config webpack.dll.config.js\"\n},\n```\n\n最后运行`npm run build:dll`打包即可\n\n## 按需引入组件实现优化打包体积\n\n如果只需要一个库的一部分功能，尽量按需导入而不是使用 `Vue.use(Plugin)`","tags":["webpack"],"categories":["webpack"]},{"title":"vue性能优化9法","url":"/haoge744.github.io/2019/09/01/vue性能优化/","content":"\n在2019年3月VueConf US大会上，有人分享了一个Vue性能优化9法的相关演讲，在此和大家分享。\n\n- 演讲视频\n    - http://www.youtube.com/watch?v=5B66qer8cZo\n- 演讲稿\n    - https://slides.com/akryum/vueconfus-2019#/\n- 演示网站\n    - https://vue-9-perf-secrets.nettlify.com\n- 演示代码\n    - https://github.com/Akryum/vue-9-perf-secrets\n\n<!-- more -->\n## 函数型组件\n\n优化前\n``` javascript\n<template>\n    <div class=\"cell\">\n        <div v-if=\"value\" class=\"on\"></div>\n        <section v-else class=\"off\"></section>\n    </div>\n</template>\n<script>\n    export default{\n        props:['value']\n    }\n</script>\n```\n优化后\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\"></div>\n    <section v-else class=\"off\"></section>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['value']\n}\n</script>\n```\n可以看到两段代码的不同仅仅是 `template`标签加了一个`functional`属性，加了这个属性有什么用呢，就是把当前组件变成函数组件，他的一系列生命周期的钩子方法不会调用。省去了这些钩子后，性能将会得到优化。\n\n## 子组件拆分\n优化前\n``` javascript\n<template>\n  <div :style=\"{ opacity: number / 300 }\">\n    <div>{{ heavy() }}</div> \n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['number'],\n  methods: {\n    heavy () { /* 非常耗时，计算量大的处理 */ }\n  }\n}\n</script>\n\n```\n\n优化后\n``` javascript\n<template>\n  <div :style=\"{ opacity: number / 300 }\">\n    <ChildComp/>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['number'],\n  components: {\n    ChildComp: {\n      methods: {\n        heavy () { /* 耗时计算逻辑放到子组件当中 */ }\n      },\n      render (h) {\n        return h('div', this.heavy())\n      }\n    }\n  }\n}\n</script>\n```\n在主组件当中把一个非常耗时耗性能的处理仅仅放在method中，那么每次组件更新时，都会重新调用一下，这样非常耗性能。那么优化之后，把耗时的逻辑放到了子组件中，那么主组件更新，也不会重新计算，提高了性能。\n\n## 局部变量\n\n优化前\n``` javascript\n<template>\n  <div :style=\"{ opacity: start / 300 }\">{{ result }}</div>\n</template>\n\n<script>\nimport { heavy } from '@/utils'\n\nexport default {\n  props: ['start'],\n  computed: {\n    base () { return 42 },\n    result () {\n      let result = this.start\n      for (let i = 0; i < 1000; i++) {\n        result += heavy(this.base) // 每次调用计算属性\n      }\n      return result\n    }\n  }\n}\n</script>\n```\n优化后\n``` javascript\n<template>\n  <div :style=\"{ opacity: start / 300 }\">\n    {{ result }}</div>\n</template>\n\n<script>\nimport { heavy } from '@/utils'\n\nexport default {\n  props: ['start'],\n  computed: {\n    base () { return 42 },\n    result () {\n      const base = this.base // 先声明一个常量，\n      let result = this.start\n      for (let i = 0; i < 1000; i++) {\n        result += heavy(base)// 每次计算时使用常量\n      }\n      return result\n    }\n  }\n}\n</script>\n```\n这个例子比较简单，在循环中处理比较复杂的逻辑时，推荐先声明常量，然后每次计算时用常量而不是计算属性。\n\n## 活用v-show,减少v-if\n\n优化前\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\">\n      <Heavy :n=\"10000\"/>\n    </div>\n    <section v-else class=\"off\">\n      <Heavy :n=\"10000\"/>\n    </section>\n  </div>\n</template>\n```\n\n优化后\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-show=\"props.value\" class=\"on\">\n      <Heavy :n=\"10000\"/>\n    </div>\n    <section v-show=\"!props.value\" class=\"off\">\n      <Heavy :n=\"10000\"/>\n    </section>\n  </div>\n</template>\n```\n这个也很简单，`v-if`显示和隐藏时，是删除和新增dom，而`v-show`是控制dom的css来隐藏显示，所以隐藏显示频繁的组件最好用v-show。\n\n## 使用keep-alive\n\n优化前\n``` javascript\n<template>\n  <div id=\"app\">\n    <router-view/>\n  </div>\n</template>\n```\n优化后\n``` javascript\n<template>\n  <div id=\"app\">\n    <keep-alive>\n      <router-view/>\n    </keep-alive>\n  </div>\n</template>\n```\n保持页面cache，提高页面加载效率\n## 活用延迟装载(Defer)\n优化前\n``` javascript\n<template>\n  <div>\n    <h2>I'm an heavy page</h2>\n\n    <Heavy v-for=\"n in 10\" :key=\"n\"/>\n\n    <Heavy class=\"super-heavy\" :n=\"9999999\"/>\n  </div>\n</template>\n```\n优化后\n``` javascript\n<template>\n  <div>\n    <h2>I'm an heavy page</h2>\n\n    <template v-if=\"defer(2)\">\n      <Heavy v-for=\"n in 10\" :key=\"n\"/>\n    </template>\n\n    <Heavy v-if=\"defer(3)\" class=\"super-heavy\" :n=\"9999999\"/>\n  </div>\n</template>\n\n<script>\nimport Defer from '@/mixins/Defer'\n\nexport default {\n  mixins: [\n    Defer()\n  ]\n}\n</script>\n\n```\n\n延迟加载各组件，使用户感觉界面加载流畅\n``` javascript\n// Defer.js\nexport default function (count = 10) {\n  // @vue/component\n  return {\n    data () {\n      return {\n        displayPriority: 0,\n      }\n    },\n\n    mounted () {\n      this.runDisplayPriority()\n    },\n\n    methods: {\n      runDisplayPriority () {\n        const step = () => {\n          requestAnimationFrame(() => {\n            this.displayPriority++\n            if (this.displayPriority < count) {\n              step()\n            }\n          })\n        }\n        step()\n      },\n\n      defer (priority) {\n        return this.displayPriority >= priority\n      },\n    },\n  }\n}\n```\n## 分批处理(Time Sicing)\n\n优化前\n``` javascript\nfetchItems ({ commit }, { items }) {\n  commit('clearItems')\n  commit('addItems', items)\n}\n```\n优化后\n``` javascript\nfetchItems ({ commit }, { items, splitCount }) {\n  commit('clearItems')\n  const queue = new JobQueue()\n  splitArray(items, splitCount).forEach(\n    chunk => queue.addJob(done => {\n      // Commit array chunks on several frames\n      requestAnimationFrame(() => {\n        commit('addItems', chunk)\n        done()\n      })\n    })\n  )\n  // Start and wait for all the jobs\n  // to finish\n  await queue.start()\n}\n```\n未优化时，同时处理两个提交操作，操作效率慢，把任务分成块执行，按顺序执行，提高渲染性能\n\n## 非相应模式(non-reactive)\n优化前\n``` javascript\nconst data = items.map(\n  item => ({\n    id: uid++,\n    data: item,\n    vote: 0\n  })\n)\n```\n优化后\n``` javascript\nconst data = items.map(\n  item => optimizeItem(item)\n)\n\nfunction optimizeItem (item) {\n  const itemData = {\n    id: uid++,\n    vote: 0\n  }\n  Object.defineProperty(itemData, 'data', {\n    // Mark as non-reactive\n    configurable: false,\n    value: item\n  })\n  return itemData\n}\n```\n在上面，使用map方法来遍历更改对象，每次在循环中赋值时，会改变原对象。并且会触发vue的监视机制从而更新组件。在优化之后，取消了vue对itemData对象的观察，这样不会触发多余的监视方法。从而提高了效率。\n## 仅渲染可视化部分\n\n优化前\n``` javascript\n<div class=\"items no-v\">\n  <FetchItemViewFunctional\n    v-for=\"item of items\"\n    :key=\"item.id\"\n    :item=\"item\"\n    @vote=\"voteItem(item)\"\n  />\n</div>\n```\n优化后\n``` javascript\n<recycle-scroller\n  class=\"items\"\n  :items=\"items\"\n  :item-size=\"24\"\n>\n  <template v-slot=\"{ item }\">\n    <FetchItemView\n      :item=\"item\"\n      @vote=\"voteItem(item)\"\n    />\n  </template>\n</recycle-scroller>\n```\n优化前:一下就选软所有数据项。优化后：只渲染24个组件，只渲染用户能看到的数据。提高渲染性能。\n## 总结\n对于简单的页面，可以忽略优化细节，重点可以放在功能实现上，尤其在工期紧张的时候。而对于页面复杂，计算逻辑过多的应用时，应该充分考虑使用优化技巧。\n不过在时间充足的情况下，可以考虑把性能以及资源加载这部分优化到极致，这不但使应用变得更好，对自己更是一个提升。","tags":["vue"],"categories":["vue"]},{"title":"vue中使用stylus","url":"/haoge744.github.io/2019/08/29/vue中使用stylus/","content":"\n## 介绍\n\n![logo](vue中使用stylus/logo.png)\n`stylus`是css的预处理框架。和Sass、Less是一类东西。在`stylus`中可以 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件。\n\n<!-- more -->\n\n### 安装\n\n``` bash\ncnpm install stylus stylus-loader --save-dev\n```\n\n### 在组件中使用\n\n执行完安装命令之后不需要任何配置就可以使用了。\n\n在组件中使用只要把在`style`标签中增加`lang=\"stylus\"`就可以用了\n\n### 在vue文件中引用\n\n```stylus\n<style lang=\"stylus\">\n  @import \"assets/common.styl\";\n  .main_wrapper\n      padding 12 20px\n</style>\n```\n### stylus 编码风格\n\n``` stylus\n$shadow = 0px 3px 6px -2px rgba(0,0,0,0.3)\n\n// mixins\nflexvc()\n    display flex\n    items-align center\n\n// method\nadd (a,b = 10)\n    a + b // 函数可省略返回值\n\n.card\n.card2\n    box-shadow $shadow\n    &:hover\n        background-color #F4F5F6\n\t.footer\n        border-top #ededef\n```\n\n可以看到stylus的写法非常简洁，层级关系使用缩进来表示，分号、冒号、大括号都是可选项，可写可不写。\n\n## 使用语法\n\n1. **选择器**\n   stylus选择器规则和css一样.class选择、#id选择、[type=textarea]属性选择器等等\n   ``` stylus\n   p\n    color #f00\n   ```\n   编译后\n   ``` css\n   p{\n       color: #f00;\n   }\n   ```\n   多个选择器共用\n   ``` stylus\n   .card,.box\n   or    \n   .card\n   .box\n       box-shadow 0px 3px 6px -2px rgba(0,0,0,0.3)\n   ```\n   父级引用,stylus中使用&指向父选择器，可以用来做各种伪类选择器，伪元素等等\n   ``` stylus\n   li\n       background-color #F3F4F5\n       border-bottom 1px solid #f4f5f6\n       &:hover\n           background-color #ccc\n       &:last-child\n           border-bottom none\n   ```\n2. **变量**\n\n   ``` stylus\n   primary-bg = #3A75E7\n   .main_wrapper\n       background-color primary-bg\n   ```\n\n   **标识符**（变量名，函数等），也可能包括`$`字符。例如：\n\n   ``` stylus\n   $font-size = 14px\n   p\n       font-size $font-size\n   ```\n\n   **属性查找**\n\n   Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下：\n\n   ``` stylus\n   #logo\n     position: absolute\n     top: 50%\n     left: 50%\n     width: w = 150px\n     height: h = 80px\n     margin-left: -(w / 2)\n     margin-top: -(h / 2)\n   ```\n   我们不使用这里的变量`w`和`h`, 而是简单地前置`@`字符在属性名前来访问该属性名对应的值：\n   ``` stylus\n   #logo\n     position: absolute\n     top: 50%\n     left: 50%\n     width: 150px\n     height: 80px\n     margin-left: -(@width / 2)\n     margin-top: -(@height / 2)\n   ```\n3. **函数**\n   一个简单的函数\n   ``` stylus\n   add(a,b)\n       a + b // 省略return\n   body\n       padding add(10px, 5)\n   ```\n   默认参数\n   ``` stylus\n   add(a, b =a)\n       a = unit(a, px) // unit把单位都变成px\n       b = unit(b, px)\n   \ta + b\n   add(15%, 10deg)\n       // => 25\n   ```\n   多个返回值\n   ``` stylus\n   paddings()\n       25px 12px\n   \n   .main \n       padding paddings()\n       // 编译后 => padding: 25px 12px;\n   ```\n4. **混合**\n   混合和函数定义差不多，但是效果不一样。函数有返回值，混合没有。\n   比如我们想定义一个垂直居中的横向flex布局可以像下面这样:\n   ``` stylus\n   flexvc()\n   \tdisplay flex\n       align-items center\n   .main-list\n       flexvc()\n   ```\n   父级引用\n   比如说我们想创建一个条纹表格,`even`和`odd`均提供了默认颜色值，每行也指定了`background-color`属性。我们可以在`tr`嵌套中使用`&`来引用`tr`，以提供`even`颜色。\n   ``` stylus\n   stripe(even = #fff, odd = #eee)\n    tr\n      background-color odd\n      &.even\n      &:nth-child(even)\n          background-color even\n   ```\n   然后利用混合书写,如下:\n   ``` stylus\n   table\n       stripe()\n   \n   table#data-grid\n       stripe(#212121, #494848)\n   \ttd\n           color white\n   ```\n5. **插值**\n\n   Stylus支持通过使用`{}`字符包围表达式来插入值，其会变成标识符的一部分。例如，`-webkit-{'border' + '-radius'}`等同于`-webkit-border-radius`.\n\n   比较好的例子就是私有前缀属性扩展：\n\n   ``` stylue\n   vendor(prop, args)\n   \t{prop} args\n   .well\n   \tborder-radius 4px\n   ```\n\n   **选择器插值**\n\n   ``` stylus\n   table\n     for row in 1 2 3 4 5\n       tr:nth-child({row})\n         height: 10px * row\n   ```\n\n   编译后\n\n   ``` stylus\n   table tr:nth-child(1) {\n     height: 10px;\n   }\n   table tr:nth-child(2) {\n     height: 20px;\n   }\n   table tr:nth-child(3) {\n     height: 30px;\n   }\n   table tr:nth-child(4) {\n     height: 40px;\n   }\n   table tr:nth-child(5) {\n     height: 50px;\n   }\n   ```\n\n6. **注释**\n\n   单行注释\n\n   ``` stylus\n   // 单行注释\n   ```\n\n   多行注释\n\n   ``` stylus\n   /*\n    * 多行注释\n    */\n   ```\n\n   ## 总结\n\n   总的来说写法和很多css预处理语言很相似，但是stylus写法更简洁一些，入门也更简单。上面介绍到的功能和用法能满足大部分日常使用需要了。如果还需了解的更加深入的话可以去读下这份[文档](www.zhangxinxu.com/jq/stylus/)。","tags":["vue"],"categories":["vue"]},{"title":"h5常用新元素","url":"/haoge744.github.io/2019/08/25/h5常用新元素/","content":"\n过去的标签书写习惯了，其实有些更有语义化的标签可以代替`div`、`span`这些标签的。\n\n<!-- more -->\n\n语义与结构元素:\n\n| 标签         | 描述                                                         |\n| ------------ | ------------------------------------------------------------ |\n| <header>     | 定义了文档的头部区域                                         |\n| <nav>        | 定义导航链接的部分                                           |\n| <footer>     | 定义文档或节的页脚 底部                                      |\n| <article>    | 定义文章。潜在来源:论坛帖子、博客文章、新闻故事、评论        |\n| <section>    | 定义文档中的节（section、区段）                              |\n| <aside>      | 定义其所处内容之外的内容 侧边(侧边栏或者侧边菜单用的较多)    |\n| <mark>       | 定义带有记号的文本。                                         |\n| <time>       | 定义日期或时间。(可以用来标记时间，行内元素，无任何样式)     |\n| <figure>     | 规定独立的流内容（图像、图表、照片、代码等等）。(经常用于展示图片，和figcaption配合的多) |\n| <figcaption> | 定义 <figure> 元素的标题                                     |\n\n多媒体元素\n\n| 标签     | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| <canvas> | 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API |\n| <audio>  | 定义音频内容                                                 |\n| <video>  | 定义视频（video 或者 movie）                                 |\n| <source> | 定义多媒体资源 <video> 和 <audio>                            |\n| <embed>  | 定义嵌入的内容，比如插件。                                   |\n| <track>  | 为诸如 <video> 和 <audio> 元素之类的媒介规定外部文本轨道。   |\n\n","tags":["html"],"categories":["html"]},{"title":"vue自定义指令实现功能级权限","url":"/haoge744.github.io/2019/08/24/vue自定义指令实现功能级权限/","content":"\n### 自定义指令使用介绍\n\n在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。\n\n自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n\n<!-- more -->\n\n#### 钩子函数参数\n- `el`：指令所绑定的元素，可以用来直接操作 DOM 。\n- `binding`：一个对象，包含以下属性：\n  - `name`：指令名，不包括 v- 前缀。\n  - `value`：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n  - `oldValue`：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n  - `arg`：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n  - `modifiers`：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n- `vnode`：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。\n- `oldVnode`：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n\n### 功能实现\n\n权限的获取是在登录时获取，获取完之后缓存至cookie和vuex中，防止用户刷新后出现的问题。然后每次刷新初始化时尝试从cookie中取出权限项再次放入vuex。\n\n``` javascript\n// store/morules/user.js 用户存储的状态信息\nimport {setRoles, getRoles} from '@/utils/cookieHelper'\nimport Vue from 'vue'\nconst user = {\n  state: {\n    roles: getRoles()\n  },\n  mutations: {\n    SET_ROLES: (state, val) => {\n      setRoles(state, val)\n      Vue.set(state,'roles', val)\n    }\n  },\n  actions: {\n\n  }\n}\nexport default user\n```\n\n``` javascript\n// cookieHelper.js \nimport Cookies from 'js-cookie' // cookie存取使用了js-cookie的组件\n\nexport function setRoles (roles) {\n  return Cookies.set('roles', roles.split())\n}\n\nexport function getRoles () {\n  // const roleStr = Cookies.get('roles')\n  const roleStr = 'admin' // 先写死一个变量 利于测试\n  if (roleStr) {\n    return roleStr.split(',')\n  } else {\n    return []\n  }\n}\n```\n\n#### 实现自定义指令功能\n\n``` javascript\n// 新建 directive/auth.js\n\nimport Vue from 'vue'\nimport store from '../store'\n\n\nVue.directive('permission', {\n  inserted: (el, binding) => { // 如果使用bind钩子会找不到父元素\n    const { value } = binding\n    let hasPermission = false\n    const myRoles = store.getters.roles\n    if (value && value instanceof Array && value.length > 0){\n      hasPermission = value.some(item => {\n        return myRoles.includes(item)\n      })\n    }else {\n      throw new Error('参数错误')\n    }\n    if(!hasPermission){ // 没有权限移除该元素\n      el.parentNode.removeChild(el)\n    }\n  }\n})\n\n\n```\n\n``` javascript\n    // 在main.js中引入auth.js\n\t// 测试成功后，把cookieHelper中的返回的权限改为其他值后，按钮隐藏了\n\t<el-button v-permission=\"['add', 'admin']\">添加</el-button>\n```\n","tags":["vue"],"categories":["vue"]},{"title":"filco入手评测","url":"/haoge744.github.io/2019/08/15/filco入手评测/","content":"## 使用感受\n\n话说花一千多块买一把键盘到底值不值？不过我为了体验顶级键盘的手感，还是忍痛割爱了。\n说实话这款键盘我早就看中了，犹豫了很久。最后还是没忍住哈哈。\n对于程序猿这种重度使用键盘的人群，给自己一把好一点的键盘，我觉得也是可以奖励给自己的啊。毕竟时不时给自己一个小礼物，有助于提升自己的幸福感呢。\n\n![包装图](filco入手评测/filco1.jpg)\n包装图\n<!-- more -->\n\n\n包装中规中矩吧，上面也显示支持有线和蓝牙连接，赠送了一个拔键器、防尘罩、两节电池、还有两个键帽，这个待会再说有什么用。\n\n![包装图](filco入手评测/filco2.jpg)\n键盘整体图\n\n从外观上说我觉得还可以，没有现在游戏键盘那么多花里胡哨的各种灯，各种特效。我比较喜欢这种稳重的黑，也没有背光灯。给人看起来比较低调。\nfilco采用的是Abs材质的键帽，懂行的可能知道，Abs键帽虽然手感好，但是时间长了之后，键帽容易打油。个人更喜欢Abs的键帽，虽然Pbt的键帽不会打油，但是磨砂的手感完全比不上Abs类肤的手感。尤其是filco，键帽的厚度和大键的手感调试的非常好。大键和小键的手感几乎完全一样，一般中低端的樱桃轴键盘，大键的手感要么很肉，要么给人感觉就像黑轴一样 很硬。filco给人的感觉相当完美。\n\n![包装图](filco入手评测/filco3.jpg)\nLOGO特写\n\n由于我买的是青轴，声音非常清脆，打字声音比较大，但还可以接受。另外键盘手感比我的 IKBC DC108好了很多。IKBC给我的感觉有点偏硬了。\n因为我喜欢桌面整洁，所以选了双模版，这款键盘支持4台设备切换，但是它这个蓝牙连接方式，要看说明书才能学会。另外键盘右下方好像没有菜单键，这时候赠送的键帽就派上用场了，可以把右win换成菜单键，开一下键盘底下的一个开关就好了,然后换一下键帽，完美。\n## 总结\n根据这几个星期的使用感受，我总结了以下优缺点：\n优点：\n1. 手感。filco的手感一直是它最大的卖点，这点我非常满意。\n2. 双模 没有线的束缚，如果再配上一个无线鼠标，简直爽的一批。\n3. 设计 键帽整体设计给我感觉落落大方，键帽的字体我也很喜欢，还有就是右上角雕刻的LOGO，设计也很棒。\n\n缺点：\n\n1. 贵。\n2. 键帽易打油，这是Abs通用的缺点，使用1至2年就需要更换键帽了。","tags":["生活记事"],"categories":["生活记事"]},{"title":"v-slot的使用","url":"/haoge744.github.io/2019/08/12/v-slot的使用/","content":"\n## v-slot介绍\n\n`vue2.6.x`开始，vue为具名和范围插槽引入了一个全新的语法,即`v-slot`。目的就是想统一`slot`和`scope-slot`语法，使代码更加规范和清晰。\n\n还在`2.5.x`的小伙伴注意`v-slot`只支持在`vue2.6`以上使用，想用的同学请先升级版本哦。\n\n我们看看v-slot和之前的语法区别吧。\n\n<!-- more -->\n### 局名插槽\n\n``` html\n<!-- base-layout.vue -- >\n<div class=\"container\">\n\t<header>\n\t\t<slot name=\"header\"></slot>\n\t</header>\n\t\n\t<main>\n\t\t<slot></slot>\n\t</main>\n\t<footer>\n\t\t<slot name=\"footer\"></slot>\n\t</footer>\n</div>\n```\n\n使用\n\n``` html\n<!-- 过时语法 -->\n<base-layout>\n\t<template slot=\"header\">\n\t\t<h1>ssss</h1>\n\t</template>\n\t<p>12125125<p>\n\t<p>198248924</p>\n\t<template slot=\"footer\">\n\t\t<p>Some Description</p>\n\t</template>\n</base-layout>\n```\n\n使用v-slot指令改写:\n\n``` vue\n<base-layout>\n\t\t<template v-slot:header>\n\t\t\t<h1>title</h1>\n\t\t</template>\n\t\t<p>some content</p>\n\t\t<p>some content</p>\n\t\tor\n\t\t<template v-slot:default>\n\t\t</template>\n\t\t<template v-slot:footer>\n\t\t\t<p>some content</p>\n\t\t</template>\n\t</base-layout>\n```\n\n### 作用域插槽:\n\n``` vue\n<!-- 首先定义绑定对象 -->\n<span>\n    <slot v-bind:user=\"user\">\n    </slot>\n</span>\n```\n\n\n\n``` vue\n<!-- 过时语法 -->\n<slot-example>\n  <template slot-scope=\"slotProps\">\n    {{ slotProps.user.name }}\n  </template>\n</slot-example>\n```\n\n``` vue\n<!-- v-slot的写法 -->\n<slot-example>\n  <template v-slot=\"slotProps\">\n    {{ slotProps.user.name }}\n  </template>\n</slot-example>\n\n<!-- 可解构赋值改写成以下内容 -->\n<slot-example>\n  <template v-slot=\"{user}\">\n    {{ user.name }}\n  </template>\n</slot-example>\n\n<!-- 可以给结构变量赋默认值,防止未定义 -->\nv-slot=\"{user = {name: 'ghost'} }\"\n```\n\n### 简写形式\n\n事件绑定和数据绑定使用的是@和:，v-slot推出后也有一个简写符号，即使用# 代替v-slot例如\n\n``` vue\n<base-layout>\n\t\t<template #header>\n\t\t\t<h1>title</h1>\n\t\t</template>\n\t\t<p>some content</p>\n\t\t<p>some content</p>\n\t\tor\n\t\t<template #default>\n\t\t</template>\n\t\t<template #footer>\n\t\t\t<p>some content</p>\n\t\t</template>\n</base-layout>\n```\n\n然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n\n``` vue\n<!-- 这样会触发一个警告 -->\n<current-user #=\"{ user }\">\n    {{ user.firstName }}\n</current-user>\n```\n\n如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：\n\n``` html\n<current-user #default=\"{ user }\">\n    {{ user.firstName }}\n</current-user>\n```\n\n## 实际使用\n\n接下来写一个导航组件，每个导航可能会有图标或者badge，这个实际使用要看后台数据。首先先写两个组件\n\n``` vue\n<!-- NavList.vue 导航的父组件 -->\n<template>\n  <nav class=\"nav_wrapper\">\n    <!-- 循环迭代导航列表，默认只显示导航的名称 -->\n    <slot v-for=\"item in navList\" v-bind:item=\"item\">\n      <NavItem>\n        {{ item.name }}\n      </NavItem>\n    </slot>\n  </nav>\n</template>\n\n<script>\nimport NavItem from './NavItem'\nexport default {\n  components: {\n    NavItem\n  },\n  props: {\n    navList: {\n      required: true,\n      type: Array\n    }\n  },\n  name: 'NavList'\n}\n</script>\n\n<style scoped lang=\"stylus\">\n.nav_wrapper\n  background-color #545c64\n  color white\n  display flex\n  flex-flow row nowrap\n  padding 0px 40px\n  height 40px\n  align-items stretch\n  & >>> .nav_item // 让子组件的css生效\n    text-decoration none\n    padding 0 40px\n    cursor: pointer\n    display flex\n    align-items center\n    &:hover\n      background-color black\n  & >>> .nav_item_icon img <!-- 给子组件的导航图标设置的样式 -->\n    width 30px\n    height 30px\n    display flex\n    align-items center\n    margin-right 10px\n\n</style>\n```\n\n``` vue\n<!-- 导航的子组件 NavItem.vue -->\n<template>\n  <a class=\"nav_item\">\n    <!-- 导航的图标,默认没有, 在slot标签上设置class不生效,所以用span包裹一下 -->\n    <span class=\"nav_item_icon\"> \n      <slot name=\"icon\"></slot>\n    </span>\n    <slot></slot>\n    <slot name=\"badge\" class=\"nav_item_badge\"></slot>\n  </a>\n</template>\n\n<script>\nexport default {\n  name: 'NavItem'\n}\n</script>\n\n<style scoped>\n</style>\n```\n\n两个相互搭配的组件写好了，接下来开始使用了:\n\n``` vue\n<!-- index.vue -->\n<template>\n  <div>\n    <NavList :navList=\"navList\">\n      <template v-slot=\"{item}\">\n        <NavItem>\n          <!-- 菜单项中有图标则显示、没有则隐藏 -->\n          <template v-slot:icon v-if=\"item.icon\">  \n            <img :src=\"item.icon\" alt=\"\" >\n          </template>\n          {{ getName(item) }}\n\t\t  <!-- 菜单项中有badge则显示、没有则隐藏 -->\n          <template v-slot:badge v-if=\"item.badge\">\n\t\t\t<!-- badge的样式是在父组件中定义的， -->\n            <span class=\"nav_item_badge\">\n              {{ item.badge }}\n            </span>\n          </template>\n        </NavItem>\n      </template>\n      \n    </NavList>\n  </div>\n</template>\n\n<script>\nimport NavList from '@/components/NavList'\nimport NavItem from '@/components/NavItem'\nexport default {\n  name: 'index',\n  components: {\n    NavList,\n    NavItem\n  },\n  data () {\n    return {\n      navList: [{ // 导航菜单的列表\n        name: 'home',\n        icon: require('../../assets/icon.png')\n      },{\n        name: 'news',\n        badge: 2\n      },{\n        name: 'tags'\n      },{\n        name: 'about',\n        icon: require('../../assets/logo.png'),\n        badge: 3\n      }]\n    }\n  },\n  methods: {\n    getName (item) {\n      return item.name.toUpperCase()\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"stylus\">\n  .nav_item_badge \n    width 10px\n    height 10px\n    padding 5px\n    display flex\n    align-items center\n    justify-content center\n    margin-top -12px\n    margin-left 4px\n    font-size 10px\n    border-radius 50%\n    background-color red\n    color: white\n</style>\n```\n\n效果如下:\n\n![效果](v-slot的使用/slot.png)\n\n\n可能样式不是很完美，但是今天主题还是v-slot, 为什么不在NavItem里设置badge的样式呢？这是因为badge的宽高设定之后，父组件无法控制其隐藏。我目前暂时没有想到好的办法。另外本身badge这个东西也应该封装成一个组件的，如果在子组件里写死了那么久丧失了灵活性。另外这个导航本身实际项目中应该不会这样写，这只是一个v-slot的使用样例，仅供参考。\n","tags":["vue"],"categories":["vue"]},{"title":"echarts地图钻取位置异常的解决办法","url":"/haoge744.github.io/2019/08/08/echarts地图钻取位置异常的解决办法/","content":"因为有需求要做一个中国地图下钻到市的功能，但是在钻取中放大的时候碰到了地图位置显示异常的问题，切换地图的时候偶尔会出现地图找不到的问题，如下图:\n\n![错误图](echarts地图钻取位置异常的解决办法/map1.gif)\n\n<!-- more -->\n地图下钻逻辑，初始化的时候缓存全国的地图，省的多次加载，我这里实现echarts下钻的核心方法是 `registerMap(mapName,geoJson,specialAreas)`作用是向echarts内注册一个地图，这个地图的第一个参数是地图名字，可以自定义，第二个是geoJson，可以自己画geojson的数据也可以在echarts的github地址里找到关于中国省市区的地图数据(echarts官网已经下载不了了),访问这个[链接](https://github.com/apache/incubator-echarts/tree/master/map)可以下载到。第三个是可选参数，具体参考文档。\n\n在官网上看到了地图的series中可以设置`center`参数，然后在地图json中看到了每个城市也有经纬度的数据所以可以每次钻取的时候给series设置当前城市的中心点来避免问题发生。\n![广东省地图geoJSON数据](echarts地图钻取位置异常的解决办法/json1.png)\n\n\n\n### 代码:\n\n``` javascript\nexport default {\n    // ... somecode\n    methods: {\n        // ...somecode\n        init () { // 地图初始化，把画布大小调整为全屏以及注册点击事件\n          const dom = document.getElementById('map-wrapper')\n          dom.style.width = document.body.clientWidth + 'px'\n          dom.style.height = document.body.clientHeight + 'px'\n          this.chartInstance = echarts.init(dom)\n          this.chartInstance.on('click', this.chartClickHandler)\n        },\n        chartClickHandler (params) { // 地图点击事件\n          if (params.name in provinces) { // 点省级或者直辖市\n            if (special.indexOf(params.name) >= 0) {\n              this.$toast('直辖市不支持放大')\n              return\n            }\n            this.isNational = false \n            const key = provinces[params.name]\n            const name = params.name\n            this.$toast.loading({\n              mask: true,\n              duration: 0\n            })\n            // 请求static路径下城市的geoJSON.json数据\n            getMapJson(`./static/map/province/${key}.json`).then(async response => {\n              let cityData = []\n              let cityMap = {}\n              console.log(response.data.features[0].properties.name)\n              const lat = response.data.features[0].properties.cp // 获取json里第一个城市的经纬度\n              response.data.features.forEach(item => { // 没有数据的展示零\n                cityMap[item.properties.name] = 0\n              })\n              try {\n                if (this.provIdKeyMap.get(name)) {\n                    // 根据省的id拿到后台数据展示\n                  let cData = await getCityData(this.provIdKeyMap.get(name).split('_')[0]) // 根据省id 获取市的数据\n                  if (cData.status === 200) {\n                    cData.data.forEach(item => {\n                      cityMap[item.cityname] = item.ftreermb\n                    })\n                  }\n                }\n                this.$toast.clear()\n              } catch (error) {\n                this.$toast('加载地图数据失败')\n              }\n              for (let a in cityMap) { // 遍历组装所有市的数据\n                let showLabel = cityMap[a] ? true : false \n                cityData.push({\n                  name: a,\n                  value: cityMap[a],\n                  label: {\n                    show: showLabel\n                  }\n                })\n              }\n              echarts.registerMap(name, response.data) // 注册地图\n              this.renderMap(name, cityData, lat) // 渲染\n            })\n          } else {\n            this.isNational = true\n            this.renderMap('china', this.nationalData)\n          }\n        },\n        // 渲染地图\n        renderMap (map, data, lat = [103.754, 34.452]) { // 地图名字, 数据, 经纬度\n          this.$set(this.option.title, 'subtext', map)\n          const series = [{\n            name: map,\n            type: 'map',\n            mapType: map,\n            roam: true,\n            zoom: 2,\n            nameMap: {'china': '中国'},\n            left: 20,\n            top: '30%',\n            center: lat, // 设置中心点 默认中国的中心点\n            showLegendSymbol: false,\n            label: {\n              normal: {\n                show: true,\n                textStyle: {color: '#000', fontSize: 14}\n              },\n              emphasis: {\n                show: true,\n                textStyle: {color: '#999', fontSize: 14}\n              }\n            },\n            itemStyle: {\n              normal: {\n                areaColor: '#E6E6FA',\n                borderColor: 'dodgerblue',\n                label: {\n                  show: true,\n                  formatter: '{b}\\n{c} '\n                }},\n              emphasis: {\n                areaColor: 'darkorange'\n              }\n            },\n            data: data\n          }]\n          //设置option\n          this.$set(this.option, 'series', series)\n          this.chartInstance.setOption(this.option)\n        }\n    }\n}\n```\n\n完成后效果如下:\n\n![虽然有点瑕疵,但好歹还是解决了问题](echarts地图钻取位置异常的解决办法/map2.gif)\n\n### 不显示数据为零的地名\n\nseries里的data也可以设置label的样式和隐藏显示,设置标签位置等等等。详细配置请访问[链接](https://echarts.baidu.com/option.html#series-map.map)\n\n``` javascript\n{\n    name: a,\n        value: cityMap[a],\n            label: {\n                show: showLabel // 判断数据是否为空或者零\n            }\n}\n```\n\n\n\n","tags":["echarts","移动开发"],"categories":["echarts"]},{"title":"vue项目使用lottie动画","url":"/haoge744.github.io/2019/08/08/vue项目使用lottie动画/","content":"Lottie是一个开源动画框架，支持Android，IOS，ReactNative以及web开发，这篇文章主要讲Lottie在vue项目中如何使用。[GitHub地址](https://github.com/chenqingspring/vue-lottie),我在官方社区看了一下，交互性非常好，动画支持倍速播放，倒放，暂停等功能，能熟练使用的话，交互性能提升很多。\n\n### 安装\n\n在安装目录执行以下命令:\n\n``` bash\nnpm install --save vue-lottie\n```\n\n<!-- more -->\n\n## 使用\n\n准备好动画json文件。可以让UI处理好:\n\n1. UI使用AE--安装bodymovin插件-将AE中的动画工程文件通过bodymovin转换为.json文件--发给开发-开发集成Lottie框架-直接在项目中使用。\n\n2. 或者是在官方库里找:[链接](https://lottiefiles.com/popular)。\n\n具体代码:\n\n``` javascript\n<template>\n    <div>\n        <Lottie :options=\"defaultOptions\" v-on:animCreated=\"handleAnimation\" />\n    </div>\n</template>\n\n<script>\nimport Lottie from 'vue-lottie'\n// 引用动画json文件，在官网下载的。\nimport * as animeData from '../assets/anime.json'\nexport default {\n  name: 'animate',\n  components: {\n      Lottie\n  },\n  data () {\n    return {\n        // ... some code\n        defaultOptions:{\n            animationData: animeData\n        }\n    }\n  },\n  methods: {\n    handleAnimation: function (anim) {\n        this.anim = anim\n    }\n  }\n}\n</script>\n\n<style scope>\n    ...some code\n</style>\n\n```\n\n效果:\n![使用效果](vue项目使用lottie动画/lottie.gif)\n\n### 常用配置:\n\n以上配置只用到了animationData,下面列出一些常用的，更多配置项请在该[链接](https://github.com/bodymovin/bodymovin)中查看\n\n- animationData:  动画json\n- path: 可直接指定动画json // 路径\n- loop: true / false / number //循环\n- autoplay: true / false // 自动播放\n- name:  // 给动画取名字,方便方法调用\n- renderer: 'svg' / 'canvas' / 'html'  //渲染方式\n- container: the dom element on which to render the animation // 可直接指定dom节点渲染\n\n\n\n","tags":["vue","移动开发"],"categories":["vue"]},{"title":"uni随手笔记一","url":"/haoge744.github.io/2019/08/04/uni随手笔记一/","content":"\n自己看官方文档做的一些笔记，记了一些和vue差异的地方和印象较深的地方。看看就好哈哈。\n\n<!-- more -->\n\n### 编写uni注意事项\n\n用uni-app想兼容多端，不能使用带dom、window操作的库，并且最好是纯flex布局，如果只开发h5端，推荐还是用vue-cli构建项目。\n\n### 新老编译模式:\n\n``` javascript\n在manifast.json中配置{\n\t// ...\n\tapp-plus: { // app h5+相关\n\t\tusingComponents: true // 如果是true则是自定义组件模式/否则不是 \n\t},\n\twp-wexin: { // 微信小程序相关\n\t}\n}\n```\n\n**最新版本的XHbuilder默认是自定义组件模式**\n**不支持v-slot新语法 // vue2.6新增**\n\n### npm支持情况\n\n初始化项目\n\n初始化 package.json文件 npm init -y\n\n安装依赖 npm install packageName --save\n\n使用\n\n``` import package from 'packageName'\nconst package = require('packageName')\n* 注意非H5端不支持使用含有dom、window等操作的vue组件和js模块,安装的模块及其依赖的模块使用的api必须是uni-app已有的api, 说明npm 的插件极其难找\n* 支持安装 mpvue组件，但npm方式不支持小程序自定义组件(如wxml格式的vant-weapp)\n```\n\n## 生命周期:\n\n全局生命周期:\n\n| 属性  | 类型 |\n| ------ | ------------ |\n| onLaunch | 当uni-app 初始化完成时触发（全局只触发一次） |\n| onShow | 当uni-app 启动，或从后台进入前台显示 |\n| onHide | 当uni-app 从前台进入后台 |\n| onUniNViewMessage | 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 |\n\n\t组建中新增 onBackPress(event) -- 返回 event ={form: backbutton | navigateBack}\n\t自定义返回键可以看这篇文章:http://ask.dcloud.net.cn/article/35120\n组件生命周期除了vue的基本生命周期额外增加了一些生命周期\n 建议使用 uni-app 的 onReady代替 vue 的 mounted。\n 建议使用 uni-app 的 onLoad 代替 vue 的 created。\n\n`static` 目录下的 `js` 文件不会被编译，如果里面有 `es6` 的代码，不经过转换直接运行，在手机设备上会报错。\n\n## 条件编译及判断运行环境\n\n判断开发环境和生产环境: (方便切换生产环境和正式环境 后台url)\n\n```\n// uEnvDev\nif(process.env.NODE_ENV === 'development'){\n    console.log('开发环境')\n}else{\n    console.log('生产环境')\n}\n```\n\n平台条件编译 \n\n```\n// #ifdef H5\n    alert(\"只有h5平台才有alert方法\")\n// #endif\n```\n\n**注意在css或scss等其他样式中，要使用/* #ifdef MP-WEIXIN */代替**\nifdef的可取值如下\n\tAPP-PLUS、APP-PLUS-NVUE（Weex）、H5、MP-WEIXIN、MP-ALIPAY、MP-BAIDU、MP-TOUTIAO、MP-QQ(qq小程序目前仅cli版支持)、MP(非h5和app+/weex)\n\n#### 样式导入:\n\n​\t使用@import 语句导入\n​\t@import \"../../common/uni.css\";\n内联样式以及动态样式\n​\t<view :style=\"color: color\" />\n​\t注意:\n​\t\tpage相当于body节点，例如:\n​\t\tpage {  background-color: #ccc }\n\n#### css 内置变量 快捷键`hei`\n\n\tvar(--status-bar-height)  //系统状态栏高度\n\tvar(--window-top) //内容区域距离顶部的距离 -- NavagationBar的高度\n\tvar(--window-bottom) // 内容区域距离底部的距离 -- tabBar的高度\n注意导航栏和底部选项卡最好用px作为单位\n\t##注意:背景图片仅支持以 ~@ 开头的绝对路径(不支持相对路径!)\n#### 字体图标\n\n\t支持网络路径图标，网络路径必须加协议头https\n\n### vue 使用注意\n\n\t1.1建议使用 uni-app 的 onReady代替 vue 的 mounted。\n\t1.2建议使用 uni-app 的 onLoad 代替 vue 的 created。\n\n事件处理:\n\t// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件\n\n```javascript\n{\n    click: 'tap',\n    touchstart: 'touchstart',\n    touchmove: 'touchmove',\n    touchcancel: 'touchcancel',\n    touchend: 'touchend',\n    tap: 'tap',\n    longtap: 'longtap',\n    input: 'input',\n    change: 'change',\n    submit: 'submit',\n    blur: 'blur',\n    focus: 'focus',\n    reset: 'reset',\n    confirm: 'confirm',\n    columnchange: 'columnchange',\n    linechange: 'linechange',\n    error: 'error',\n    scrolltoupper: 'scrolltoupper',\n    scrolltolower: 'scrolltolower',\n    scroll: 'scroll'\n}\n```\n\n### 基本元素:\nuni-app推荐使用`view`、`text`等元素替代原来的html元素 用`navigator`替代 `a` ,虽然写`div`或者`a`之类的h5标签也不影响使用但是推荐按照官方的来\n\n元素 共同属性类型\n\n| 属性   | 类型         | 说明                                                      |\n| ------ | ------------ | --------------------------------------------------------- |\n| id     | String       | 组件的唯一标示\t保持整个页面唯一                        |\n| class  | String       | 组件的样式类\t在对应的 css 中定义的样式类               |\n| style  | String       | 组件的内联样式\t可以动态设置的内联样式                  |\n| hidden | Boolean      | 组件是否隐藏\t所有组件默认是显示的                      |\n| data-* | Any          | 自定义属性\t组件上触发的事件时，会发送给事件处理函数    |\n| @*     | EventHandler | 组件的事件\t详见各组件详细文档，事件绑定参考 事件处理器 |\n\n","tags":["移动开发","uni-app"],"categories":["uni-app"]},{"title":"vue3.0 新特性","url":"/haoge744.github.io/2019/08/01/vue3-0-新特性/","content":"\n目前vue最新的版本是19年2月份发布的2.6.x,更新了一些插槽、动态参数等，据说3.0也会在下半年发布，下面根据尤大的视频分享总结3.0的新特性。\n<!-- more -->\n\n## Vue3.0即将带来哪些新东西:\n\n- 更快\n- 更小\n- 更易于维护\n- 更好的多端渲染支持\n- 新功能\n\n判断元素是html原生还是组件的时候把这个动作放到了编译时，提高了运行时的性能。跳过不需要的条件判断，生成更易于被JS引擎优化的代码。\n\n#### 优化Slots生成\n\nVue2.0存在父组件更新时，子组件也关联着也更新了。在vue3.0中优化了这一问题。避免不必要的组件渲染。检测组件更新变得更精确。\n\n#### 静态属性提取\n\n跳过整块静态内容的更新\n及时静态内容在列表中被重复也可以生效。\n跳过单个元素的patch，但依然处理子元素。\n\n主要意思是避免元素不必要的更新。\n\n#### 内联时间函数提取\n\n解决组件重新渲染后 再重新创建函数的问题，3.0中第一次创建后会缓存，那么每次重新渲染之后可以避免这个问题。\n\n#### 数据监听改为Proxy\n\n之前的数据监听系统是由Object.definedProperty的，3.0中会修改为Proxy提高了性能。再大规模数据监听的情况下，性能提升明显。\n\n据说提升后组件实例初始化效率加倍，内存占用减半\n\n## 更小\n\n### 代码结构优化\n\n和Tree-shaking(把没有用到的代码，在最后编译时给优化掉)配合，减小包的体积。\n3.0中内置的模块可以按需引入。只引入最基本模块的情况下,依赖包只有10kb左右。\n\n## 更易于维护\n\n对于vue开发团队而言，更易于维护。用TypeScript完全重写vue的源码。并且不影响用户使用。\n\n源码的各个模块更加解耦。更加利于对阅读源码的理解。\n\n#### 编译器重构\n\n使用插件化设计\n带位置信息的parser(source maps!)\n为更好的IDE供给链铺路\n\nruntime时出错提示优化\n\n## 更好的多端渲染支持\n\nvue衍生出Wexx、NativeVue、wePy 等小程序终端。\nvue3会进行更好的优化。\n推出Custom Renderer API，为多端提供更好的渲染。\n\n``` javascript\nimport { createRenderer } from '@vue/runtime-core'\nconst {render} = createRenderer({\n    nodeOps,\n    patchData\n})\n```\n\n## 新功能\n\n#### 响应式数据监听API\n\n``` javascript\nimport {observable, effect} from 'vue'\nconst state = observable({\n    count: 0\n})\neffect(() => {\n    console.log(`count is: ${state.count} `) //每次更改状态时触发的函数\n})// count is: 0\nstate.count ++ //count is : 1\n```\n\n可以很简单的在多组件中实现状态共享\n\n#### 轻松排查组件更新的触发原因\n\n``` javascript\nconst Comp = {\n    render(props) {\n        return h('div', props.count)\n    },\n    renderTriggered(event){\n        debugger // 可在此检查是在哪触发的组件更新\n        //event可查看更多信息，更改了那个key，哪行代码做的更改..等\n    }\n}\n```\n\n#### 更好的TypeScript支持\n\n提升了性能。支持tsx\n\n#### 更好的警告信息\n\n- 组件堆栈包含函数式组件\n- 可以直接在警告信息中查看组件的props\n- 在更多的警告中提供组件堆栈信息\n\n#### 新加Experimental HooksAPI\n\n类似React Hooks,大概率取代mixins。逻辑重用机制。\n\ngithub上已有Vue Hooks这个项目\n\n#### Experimental Time Slicing Support\n\n把js中复杂的计算切成一帧一帧(每16毫秒)，解决用户界面卡顿的问题。\n\n开启Time Slicing，在js计算的时候每次只占用16毫秒左右的工作量，之后把主动权交还给浏览器，这样浏览器有时间去相应用户的操作\n\n## 关于IE\n\n会有一个专门的版本在IE11中自动降级为旧的getter/setter机制。并对IE中不支持的用法给出警告。但在ie中可能享受不到vue的一些新功能。\n\n> 整理的比较乱，具体功能以及使用需要参考相关官方文档。","tags":["vue"],"categories":["vue"]},{"title":"uni-app 入坑系列一","url":"/haoge744.github.io/2019/07/31/uni-app-入坑系列一/","content":"\n# uni的简介和优点\n\n> `uni-app`是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可编译到iOS、Android、H5、以及各种小程序等多个平台。\n\nuni-app的特点和优势在于，跨平台数量多、性能体验好、生态环境好、开发效率高等特点，确实值得现在开发者学习，学习成本也不高。\n\n<!-- more -->\n\n# 项目目录结构\n\n一个uni-app工程，默认包含如下目录及文件：\n```\n    ┌─components            uni-app组件目录\n    │  └─comp-a.vue         可复用的a组件\n    ├─hybrid                存放本地网页的目录，详见\n    ├─platforms             存放各平台专用页面的目录，详见\n    ├─pages                 业务页面文件存放的目录\n    │  ├─index\n    │  │  └─index.vue       index页面\n    │  └─list\n    │     └─list.vue        list页面\n    ├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此\n    ├─wxcomponents          存放小程序组件的目录，详见\n    ├─main.js               Vue初始化入口文件\n    ├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期\n    ├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见\n    └─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见\n```\n# uni-app 和普通Vue项目开发上有什么区别\n\n## 路由\n\nvue项目配置路由页面在`src/router/index.js`文件下配置\nuni-app在项目根目录下的`pages.json`文件配置，并且结构和vue不一样。`pages.json`具体配置项可见[详情](https://uniapp.dcloud.io/collocation/pages)。\n\n路由跳转\nvue使用vue-router的`router-view`和`vue-router`的api进行页面跳转\nuni-app使用[navigator](https://uniapp.dcloud.io/component/navigator)组件跳转、或者调用[API](https://uniapp.dcloud.io/api/router)跳转。\n\n## 组件开发\n\nuni-app和vue一样也使用`.vue`文件来编写组件\n\n但是uni-app的tmeplate层内的标签是使用类似微信小程序的标签元素来编写的，例如用`<view>`和`<text>`来替代html中的`<div>`和`<span>`标签。\n\n## 第三方组件引入\n\n可以[访问](https://ask.dcloud.net.cn/article/35489)进行查看区别。\n\n## 配置文件\n\nuni-app使用manifast.json配置各平台相关信息，\nvue使用package.json webpack.*.conf.js 等配置文件配置\n\n## 状态管理\n\nuni-app也可以使用vuex来管理生命周期，但是nvue模式下不支持。\n\n## 生命周期\n\nuni-app给app环境下添加了几个全局的生命周期\n    onLaunch 当uni-app 初始化完成时触发（全局只触发一次）\n\tonShow\t当 uni-app 启动，或从后台进入前台显示\n\tonHide\t当 uni-app 从前台进入后台\n\tonUniNViewMessage\t对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯\n\n## webpack 配置\n    uni-app也支持使用webpack安装插件，但是只推荐h5平台使用，其他只支持flex布局和不操作dom的库，制作APP个人不推荐使用webpack安装第三方组件。\n","tags":["移动开发","uni-app"],"categories":["uni-app"]},{"title":"hexo项目搭建","url":"/haoge744.github.io/2019/07/21/hexo项目搭建/","content":"\n## 安装\n\n1. 安装Node.js和git 此处不再阐述\n\n2. 执行一下命令全局安装hexo\n\n   ```\n   $ npm install -g hexo-cli\n   或者\n   $ cnpm install -g hexo-cli\n   ```\n<!-- more -->\n\n### 建站\n\n安装完成后执行以下命令\n\n```\nhexo init <folder>\ncd <folder>\nnpm install\n```\n\n### 目录结构\n\n#### 安装完成之后会生成以下目录\n\n```\n.\n├── _config.yml // 网站的配置信息\n├── package.json // package.json 依赖信息，可查看安装了哪些依赖包\n├── scaffolds // \n├── source // 资源文件夹\n|   ├── _drafts\n|   └── _posts\n└── themes // 主题文件夹\n```\n\n## 写作\n\n在hexo目录下 执行以下命令:\n\n``` \nhexo new \"post title\" \n//写完之后执行 hexo g 生成页面\nhexo s \n\n//生成草稿、 草稿不会生成页面\nhexo new draft \"draft title\"\n\n//生成纯页面\nhexo new page \"page title\"\n\n// 发布草稿\nhexp pulic [layout] <filename>\n```\n\n## 命令\n\n部署:\n\n启动本地服务:\n``` bash\nhexo s -g\n```\n\n```bash\nhexo g -d\n```\n","tags":["hexo"],"categories":["hexo"]}]