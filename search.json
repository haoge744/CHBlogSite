[{"title":"webpack打包优化配置","url":"/haoge744.github.io/2019/09/03/webpack打包优化配置/","content":"\n## 关闭source-map配置\n\n<!-- more -->\n关闭source-map之后可以大大减少打包后文件体积，关掉之后出现的弊端是如果出现报错信息，无法准确判断问题在哪。\n\n``` javascript\t\n// config/index.js\n// 把productionSourceMap属性的true改成false即可生效\nmodule.exports = {\n    build: {\n        productionSourceMap: true => false\n    }\n}\n\n```\n\n## gzip压缩优化\n\ngzip可以优化页面加载时的速度，这个操作需要后台配合开启gzip,并且安装`compression-webpack-plugin`的时候要注意版本，像我用的`webpack 3.6`安装了`compression-webpack-plugin 3.0.0`然后就出现错误了。\n\n**开启gzip后,js会生成`js.gz`文件，会略微增加打包文件的体积:**\n\n``` javascript\t\n\n// Gzip off by default as many popular static hosts such as\n// Surge or Netlify already gzip all static assets for you.\n// Before setting to `true`, make sure to:\n// npm install --save-dev compression-webpack-plugin\nproductionGzip: false,\n```\n\n**服务端开启gzip压缩:**\n\n修改服务器的配置，这里的服务器是Nginx \n找到conf目录下的nginx.conf ,开启gzip,并设置gzip的类型，如下\n开启后，访问服务器的js文件时，会优先查找`.gz`文件，如果没有则会查找`.js`文件\n\n``` \ngzip on; #开启或关闭gzip on off\ngzip_disable \"msie6\"; #不使用gzip IE6\ngzip_min_length 100k; #gzip压缩最小文件大小，超出进行压缩（自行调节）\ngzip_buffers 4 16k; #buffer 不用修改\ngzip_comp_level 5; #压缩级别:1-10，数字越大压缩的越好，时间也越长\ngzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; #  压缩文件类型 \n```\n\n## HappyPack插件优化\n\n由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以Webpack 需要处理的事情需要一件一件的做，不能多件事一起做。\n我们需要Webpack 能同一时间处理多个任务，发挥多核 CPU 电脑的威力，[HappyPack](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack) 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。\n\n安装:\n\n```bash\nnpm i -D happypack\n```\n\n在webpack.config.js中添加plugins\n\n``` javascript\nmodule.exports = {\n    // ... 一些模块配置\n    plugins: [\n            // ... 一些插件配置\n        new HappyPack({\n            //用id来标识 happypack处理那里类文件\n          id: 'happyBabel',\n          //如何处理  用法和loader 的配置一样\n          loaders: [{\n            loader: 'babel-loader?cacheDirectory=true',\n          }],\n          //共享进程池\n          threadPool: happyThreadPool,\n          //允许 HappyPack 输出日志\n          verbose: true,\n        })\n    ]\n}\n```\n\n\n\n## 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块\n\n作用:优化打包速度\n\n因此我们首先需要在我们的项目根目录下创建一个 webpack.dll.config.js 文件。然后配置代码如下：\n\n``` javascript\nconst path = require('path');\nconst DllPlugin = require('webpack/lib/DllPlugin');\n\nmodule.exports = {\n  // 入口文件\n  entry: {\n    // 项目中用到该两个依赖库文件\n    jquery: ['jquery'],\n    echarts: ['echarts']\n  },\n  // 输出文件\n  output: {\n    // 文件名称\n    filename: '[name].dll.js', \n    // 将输出的文件放到dist目录下\n    path: path.resolve(__dirname, 'dist'),\n    /*\n     存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll\n     是为了防止全局变量冲突。\n    */\n    library: '_dll_[name]'\n  },\n  plugins: [\n    // 使用插件 DllPlugin\n    new DllPlugin({\n      /*\n       该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。\n       比如在jquery.manifest文件中有 name: '_dll_jquery'\n      */\n      name: '_dll_[name]',\n\n      /* 生成manifest文件输出的位置和文件名称 */\n      path: path.join(__dirname, 'dist', '[name].manifest.json')\n    })\n  ]\n};\n\n```\n\n在webpack.config.js中配置它:\n\n``` javascript\n// 引入 DllReferencePlugin\nconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n\n// 使用插件\nmodule.exports = {\n  plugins: [\n    // 告诉webpack使用了哪些第三方库代码\n    new DllReferencePlugin({\n      // jquery 映射到json文件上去\n      manifest: require('./dist/jquery.manifest.json')\n    }),\n    new DllReferencePlugin({\n      // echarts 映射到json文件上去\n      manifest: require('./dist/echarts.manifest.json')\n    })\n  ]\n}\n\n```\n\n**执行构建：**\n\n最后一步就是构建代码了，先生存第三方库文件，因此我们运行如下命令：\n\n```\nwebpack --config webpack.dll.config.js\n```\n\n在`package.json`中添加如下代码:\n\n```\n\"scripts\": {\n  \"dev\": \"webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline\",\n  \"build\": \"webpack --progress --colors --devtool cheap-module-source-map\",\n  \"build:dll\": \"webpack --config webpack.dll.config.js\"\n},\n```\n\n最后运行`npm run build:dll`打包即可\n\n## 按需引入组件实现优化打包体积\n\n如果只需要一个库的一部分功能，尽量按需导入而不是使用 `Vue.use(Plugin)`","tags":["webpack"],"categories":["webpack"]},{"title":"vue性能优化9法","url":"/haoge744.github.io/2019/09/01/vue性能优化/","content":"\n在2019年3月VueConf US大会上，有人分享了一个Vue性能优化9法的相关演讲，在此和大家分享。\n\n- 演讲视频\n    - http://www.youtube.com/watch?v=5B66qer8cZo\n- 演讲稿\n    - https://slides.com/akryum/vueconfus-2019#/\n- 演示网站\n    - https://vue-9-perf-secrets.nettlify.com\n- 演示代码\n    - https://github.com/Akryum/vue-9-perf-secrets\n\n<!-- more -->\n## 函数型组件\n\n优化前\n``` javascript\n<template>\n    <div class=\"cell\">\n        <div v-if=\"value\" class=\"on\"></div>\n        <section v-else class=\"off\"></section>\n    </div>\n</template>\n<script>\n    export default{\n        props:['value']\n    }\n</script>\n```\n优化后\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\"></div>\n    <section v-else class=\"off\"></section>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['value']\n}\n</script>\n```\n可以看到两段代码的不同仅仅是 `template`标签加了一个`functional`属性，加了这个属性有什么用呢，就是把当前组件变成函数组件，他的一系列生命周期的钩子方法不会调用。省去了这些钩子后，性能将会得到优化。\n\n## 子组件拆分\n优化前\n``` javascript\n<template>\n  <div :style=\"{ opacity: number / 300 }\">\n    <div>{{ heavy() }}</div> \n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['number'],\n  methods: {\n    heavy () { /* 非常耗时，计算量大的处理 */ }\n  }\n}\n</script>\n\n```\n\n优化后\n``` javascript\n<template>\n  <div :style=\"{ opacity: number / 300 }\">\n    <ChildComp/>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['number'],\n  components: {\n    ChildComp: {\n      methods: {\n        heavy () { /* 耗时计算逻辑放到子组件当中 */ }\n      },\n      render (h) {\n        return h('div', this.heavy())\n      }\n    }\n  }\n}\n</script>\n```\n在主组件当中把一个非常耗时耗性能的处理仅仅放在method中，那么每次组件更新时，都会重新调用一下，这样非常耗性能。那么优化之后，把耗时的逻辑放到了子组件中，那么主组件更新，也不会重新计算，提高了性能。\n\n## 局部变量\n\n优化前\n``` javascript\n<template>\n  <div :style=\"{ opacity: start / 300 }\">{{ result }}</div>\n</template>\n\n<script>\nimport { heavy } from '@/utils'\n\nexport default {\n  props: ['start'],\n  computed: {\n    base () { return 42 },\n    result () {\n      let result = this.start\n      for (let i = 0; i < 1000; i++) {\n        result += heavy(this.base) // 每次调用计算属性\n      }\n      return result\n    }\n  }\n}\n</script>\n```\n优化后\n``` javascript\n<template>\n  <div :style=\"{ opacity: start / 300 }\">\n    {{ result }}</div>\n</template>\n\n<script>\nimport { heavy } from '@/utils'\n\nexport default {\n  props: ['start'],\n  computed: {\n    base () { return 42 },\n    result () {\n      const base = this.base // 先声明一个常量，\n      let result = this.start\n      for (let i = 0; i < 1000; i++) {\n        result += heavy(base)// 每次计算时使用常量\n      }\n      return result\n    }\n  }\n}\n</script>\n```\n这个例子比较简单，在循环中处理比较复杂的逻辑时，推荐先声明常量，然后每次计算时用常量而不是计算属性。\n\n## 活用v-show,减少v-if\n\n优化前\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\">\n      <Heavy :n=\"10000\"/>\n    </div>\n    <section v-else class=\"off\">\n      <Heavy :n=\"10000\"/>\n    </section>\n  </div>\n</template>\n```\n\n优化后\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-show=\"props.value\" class=\"on\">\n      <Heavy :n=\"10000\"/>\n    </div>\n    <section v-show=\"!props.value\" class=\"off\">\n      <Heavy :n=\"10000\"/>\n    </section>\n  </div>\n</template>\n```\n这个也很简单，`v-if`显示和隐藏时，是删除和新增dom，而`v-show`是控制dom的css来隐藏显示，所以隐藏显示频繁的组件最好用v-show。\n\n## 使用keep-alive\n\n优化前\n``` javascript\n<template>\n  <div id=\"app\">\n    <router-view/>\n  </div>\n</template>\n```\n优化后\n``` javascript\n<template>\n  <div id=\"app\">\n    <keep-alive>\n      <router-view/>\n    </keep-alive>\n  </div>\n</template>\n```\n保持页面cache，提高页面加载效率\n## 活用延迟装载(Defer)\n优化前\n``` javascript\n<template>\n  <div>\n    <h2>I'm an heavy page</h2>\n\n    <Heavy v-for=\"n in 10\" :key=\"n\"/>\n\n    <Heavy class=\"super-heavy\" :n=\"9999999\"/>\n  </div>\n</template>\n```\n优化后\n``` javascript\n<template>\n  <div>\n    <h2>I'm an heavy page</h2>\n\n    <template v-if=\"defer(2)\">\n      <Heavy v-for=\"n in 10\" :key=\"n\"/>\n    </template>\n\n    <Heavy v-if=\"defer(3)\" class=\"super-heavy\" :n=\"9999999\"/>\n  </div>\n</template>\n\n<script>\nimport Defer from '@/mixins/Defer'\n\nexport default {\n  mixins: [\n    Defer()\n  ]\n}\n</script>\n\n```\n\n延迟加载各组件，使用户感觉界面加载流畅\n``` javascript\n// Defer.js\nexport default function (count = 10) {\n  // @vue/component\n  return {\n    data () {\n      return {\n        displayPriority: 0,\n      }\n    },\n\n    mounted () {\n      this.runDisplayPriority()\n    },\n\n    methods: {\n      runDisplayPriority () {\n        const step = () => {\n          requestAnimationFrame(() => {\n            this.displayPriority++\n            if (this.displayPriority < count) {\n              step()\n            }\n          })\n        }\n        step()\n      },\n\n      defer (priority) {\n        return this.displayPriority >= priority\n      },\n    },\n  }\n}\n```\n## 分批处理(Time Sicing)\n\n优化前\n``` javascript\nfetchItems ({ commit }, { items }) {\n  commit('clearItems')\n  commit('addItems', items)\n}\n```\n优化后\n``` javascript\nfetchItems ({ commit }, { items, splitCount }) {\n  commit('clearItems')\n  const queue = new JobQueue()\n  splitArray(items, splitCount).forEach(\n    chunk => queue.addJob(done => {\n      // Commit array chunks on several frames\n      requestAnimationFrame(() => {\n        commit('addItems', chunk)\n        done()\n      })\n    })\n  )\n  // Start and wait for all the jobs\n  // to finish\n  await queue.start()\n}\n```\n未优化时，同时处理两个提交操作，操作效率慢，把任务分成块执行，按顺序执行，提高渲染性能\n\n## 非相应模式(non-reactive)\n优化前\n``` javascript\nconst data = items.map(\n  item => ({\n    id: uid++,\n    data: item,\n    vote: 0\n  })\n)\n```\n优化后\n``` javascript\nconst data = items.map(\n  item => optimizeItem(item)\n)\n\nfunction optimizeItem (item) {\n  const itemData = {\n    id: uid++,\n    vote: 0\n  }\n  Object.defineProperty(itemData, 'data', {\n    // Mark as non-reactive\n    configurable: false,\n    value: item\n  })\n  return itemData\n}\n```\n在上面，使用map方法来遍历更改对象，每次在循环中赋值时，会改变原对象。并且会触发vue的监视机制从而更新组件。在优化之后，取消了vue对itemData对象的观察，这样不会触发多余的监视方法。从而提高了效率。\n## 仅渲染可视化部分\n\n优化前\n``` javascript\n<div class=\"items no-v\">\n  <FetchItemViewFunctional\n    v-for=\"item of items\"\n    :key=\"item.id\"\n    :item=\"item\"\n    @vote=\"voteItem(item)\"\n  />\n</div>\n```\n优化后\n``` javascript\n<recycle-scroller\n  class=\"items\"\n  :items=\"items\"\n  :item-size=\"24\"\n>\n  <template v-slot=\"{ item }\">\n    <FetchItemView\n      :item=\"item\"\n      @vote=\"voteItem(item)\"\n    />\n  </template>\n</recycle-scroller>\n```\n优化前:一下就选软所有数据项。优化后：只渲染24个组件，只渲染用户能看到的数据。提高渲染性能。\n## 总结\n对于简单的页面，可以忽略优化细节，重点可以放在功能实现上，尤其在工期紧张的时候。而对于页面复杂，计算逻辑过多的应用时，应该充分考虑使用优化技巧。\n不过在时间充足的情况下，可以考虑把性能以及资源加载这部分优化到极致，这不但使应用变得更好，对自己更是一个提升。","tags":["vue"],"categories":["vue"]},{"title":"围棋入门","url":"/haoge744.github.io/2019/08/31/围棋入门/","content":"\n有段时间对围棋比较感兴趣，不过之前对于围棋的规则还不是很了解，只是觉得围棋很复杂、深奥。于是在B站上补了补课，学习了围棋的相关规则，还有就是看了一下名局的讲解(看不太懂，但感觉很厉害)。可能现在人们下的比较多的就是象棋、五子棋这些吧。还有比较有名的是国际象棋和日本的将棋。国际象棋和中国象棋很像，但是有一些特殊的规则，比如王车易位、吃过路兵、小兵升级等。将棋的规则相比前两个要复杂很多，先是将棋棋子中几乎所有棋子都可以升级，并且吃完对手的棋子后，可以归为己用，重新下在棋盘上。这个规则大幅度提高了将棋的复杂度。\n中国象棋、国际象棋、将棋这三种棋都有一些相同的地方,比如开局要摆放好固定的阵型，获胜的方式都是将死对面的老大。围棋和它们不一样，一开始要双方自己布局，下棋的方式也不一样，以上三种棋是运子，围棋是落子。\n\n<!-- more -->\n> 围棋易学难精！！！　　围棋的规则十分简单，却拥有十分广大的空间可以落子，使得围棋变化多端，比象棋更为复杂。这就是围棋的魅力所在。下一盘围棋的时间没有规定，快则五分钟，慢则要几天，多数时候下一盘棋需要一到二个小时。首先，它包含着极为丰富的哲学内涵：哲学家可以从中领悟到哲学矛盾范畴中对立与统一规律，量变与质变规律，否定之否定规律。现象与本质，认识与实践等等辩证关系。　　军事家可以从中领悟到军事领域内斗智斗勇的奥秘，历史上有很多的军事家都是围棋高手，如曹操，谢玄等都精通围棋。有很多围棋理论著作都是借战争理论加以阐述的。汉马融的《围棋赋》上说：“观围棋兮，法于用兵，三尺之局兮，为战斗场”。宋围棋国手刘仲青《棋诀》中写道：盖布棋之先务，如兵之先阵而后敌也。围棋十诀与毛老人家的十大军事原则有异曲同工之妙。　　另外围棋具备修身益智的作用。关于围棋是早的说法就是：昔者尧造围棋以教彤朱。并且在历史上围棋向来与神仙有不解之缘，从烂柯故事到很多名画，中间的道具都基本上是围棋。\n\n\n## 介绍\n\n围棋，起源于中国，中国古代称为“弈”，可以说是棋类之鼻祖，围棋至今已有4000多年的历史。据先秦典籍《世本》记载，“尧造围棋，丹朱善之。”晋张华在《博物志》中继承并发展了这种说法：“尧造围棋，以教子丹朱。若白：舜以子商均愚，故作围棋以教之。”\n\n## 围棋的规则\n围棋是一个圈地盘的游戏，谁圈的地盘大，谁就获胜。围棋棋盘由19*19组成，形成361个交叉点，棋子下在交叉点上而不是格子里，棋盘上有9个黑点，称为星位，中间的那个最特殊，只有它没有对称的点。称为天元。一个棋子下在棋盘上，他的相邻的上下左右四个相邻点称之为这个棋子的气。注意斜方向不算，如果有相邻的棋子连在一起，可以把这两个棋子看成是一个整体，他们的气是共享的。如下图,左边的白棋有9气，右边的白棋有6气。\n![气](围棋入门/气.png)\n气没有了，棋子就`死`了,如下图，如果白棋下在A点黑棋就`死`了,这时候这个棋子就要从棋盘上拿掉了。\n![打吃](围棋入门/打吃.png)\n\n### 禁入点\n围棋的棋子不能下在不入气的地方，这个地方也称为禁入点，如下图，白棋是不能下在A的位置的，因为一下在棋盘上，他就没有气了，所以这个点是白棋的禁入点。如下图\n![禁入点](围棋入门/禁入点.png)\n但是也有例外，我们看下图的这个棋形。\n![打劫](围棋入门/打吃2.png)\n白棋先行，按理来说白棋不能下在A这个位置，因为一下在棋盘上，就没有气了。但是白棋下下来之后，上面的黑棋被吃掉了，这时候黑棋被提子之后，白棋又有气了。所以这种情况白棋是可以下在A点的。但是我们观察发现，这时候黑棋又可以下在刚刚被吃掉的地方，再把A点的白棋吃掉。再之后白棋又可以下在A点的地方吃掉黑棋... 那这样不是没完没了吗。所以围棋中有一个规定，刚刚被吃掉子的那个点，第一手不可以再落子。比如说第一手白棋下在A的位置，吃掉了黑棋，那么黑棋不能马上在B下棋了。这种情况围棋术语称为打劫，之后黑棋在其他地方落子，称为找劫财。如果白棋在被吃黑子后再下在B点，那么这个打劫就结束了。\n\n### 围棋的\"死\" \"活\"\n\n> 在围棋的范围中，研究单方死或活的关于眼的问题叫做死活。死活是围棋的根本，要想围棋计算力提高必须做死活题，否则棋艺不会提高。\n\n随着棋局的进行，棋盘上最后剩下的就只会有活棋，那么什么是活棋?就是永远都有气的棋，那么怎样才能让棋永远都有气呢?可以看下面这个棋形.\n![活棋](围棋入门/活棋.png)\n可以看到黑棋中间是围了两个禁入点，白棋不论怎么围，始终不能把黑棋的气给杀干净，所以黑棋是活棋.因为黑棋围住的两个点像两只眼睛。所以我们把不入气点成为\"眼\"。**想要活棋必须要做出两个或两个以上的眼**\n\n#### 假眼\n![假眼](围棋入门/假眼.png)\n我们看上面这个棋形，虽然黑棋好像做出了两个眼，但是我们发现，黑棋下面有一颗棋子被白棋打吃了，只要白棋下在B的位置，那么黑棋的这个眼就被破坏掉了，那这个时候黑棋就只剩下一只眼了，那么黑棋只剩一只眼是不能活棋的，最后还是会被白棋给吃掉。\n那么稍微调整下棋形，思考下面这个棋形，黑棋是死棋还是活棋。\n![假眼](围棋入门/活棋2.png)\n\n#### 双活\n\n双方棋子互相包围，且不具备两只真眼，形成双方均不能杀死对方的局面，此时双方都算活棋，这种活棋的方法叫作双活。\n\n![双活](围棋入门/双活.png)\n\n我们看到，黑白双方都不能落子，如果谁先动手，那么反过来会被对方吃掉。这种棋形就是双活。\n\n#### 死活题\n\n如果下面这个棋形黑棋先下，怎么杀掉白棋呢？\n![死活题](围棋入门/死活.png)\n\n只要黑棋下在B点，那么白棋就死了，我们从上面的结论得出，**想要活棋必须有两个眼**，所以我们把黑棋下在B点，白棋就没有空间做出两个眼。那么白棋就死了。反过来，如果白棋先下，下在B点就是活棋了。\n\n### 棋局的胜负\n\n如果不是有一方中盘认输的情况下，下到围棋上不能在下的情况下，棋局就结束了。那么如何判断棋局的胜负呢?\n\n本文一开头说了，围棋是一个圈地盘的游戏，谁的地盘大谁就赢。中国规则是子空皆地，什么意思呢，就是你下在棋盘上的棋子+你围住的空的总数~~谁的总数多，谁就赢\n\n用己方棋子围住的棋盘上的交叉点，这些交叉点叫“目”，也叫“空”，常说这块有“N目空”；对局过程中被吃掉的子，终局后要放回己方的空内；然后比较哪方的“空”多，与棋盘上存在多少棋子无关。\n\n日韩规则都规定，黑方先行，因此贴6.5目，因此日韩规则下的胜负结果就是“黑胜半目”或“黑胜N目半”。\n\n一颗子的价值等于两目，中国规则黑贴3又3/4子，换算成目就是7.5目。两相比较，同样执黑棋，用中国规则就比用日韩规则稍微吃亏。\n\n\n## 围棋的三个阶段\n\n### 布局\n>  布局，又称布石，围棋术语，指围棋的开局走法，一般在几手到几十手的范围内。\n\n布局阶段的主要目标是抢占空地，因为在角上的围空效率更高，所以初期棋盘的四个角上的争斗会比较多。\n![](围棋入门/古力的布局(执黑).png)\n古力的布局(执黑)\n\n### 中盘\n>  中盘是围棋术语。进入中盘阶段后，棋局变化莫测。所以，中盘战斗力量是棋手提高棋力的关键，是下棋者的乐趣所在，也是围棋艺术美的根本。相对而言，布局和收官可以从书籍、定式和高手的对局通过模仿学习，而中盘战斗则是围棋中最难以掌握的技术之一。\n\n中盘的阶段，落子要注意效率，不能靠的太近，靠的太近效率低，围空少，也不能靠的太远，太远容易被分隔开。并且要注意棋子的死活。中盘阶段的变化非常多，这里不多细说，可以自己下下看。\n\n### 收官\n\n> 收官是一个汉语词语，拼音是shōu guān，又称“作官子”，是围棋比赛中三个阶段（布局、中盘、官子）中的最后一个阶段，指双方经过中盘的战斗，地盘及死活已经大致确定之后，确立竞逐边界的阶段。\n\n收官阶段，棋盘上已经下满了棋子了，这个阶段开始争抢一些所剩无几的利益。很多时候棋局并不会进入到收官阶段，因为如果中盘阶段出现了较大的悬殊，那么落后的一方很可能就投资认输了。如果能进入到收官阶段说明双方的底盘是不分伯仲的。这个时候每步棋就要精打细算，寸土必争。不要小看一些细小的利益，很多时候就是因为半目的差距就会输掉比赛。\n\n## 对弈\n\n我上面使用的围棋打谱软件叫MultiGo,也可以支持和ai对战，但是要下一个GNUGO的ai引擎,棋力对于初学者来说已经非常强了。另外也可以去弈城围棋、腾讯围棋等网络平台在线与人对弈。\n\n[MultiGo下载地址](http://www.ruijiang.com/multigo/chs/download.php)\n\n[GNU Go官方下载地址](http://gnugo.baduk.org/)\n\n","tags":["生活记事","围棋"],"categories":["生活记事"]},{"title":"vue中使用stylus","url":"/haoge744.github.io/2019/08/29/vue中使用stylus/","content":"\n## 介绍\n\n![logo](vue中使用stylus/logo.png)\n`stylus`是css的预处理框架。和Sass、Less是一类东西。在`stylus`中可以 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件。\n\n<!-- more -->\n\n### 安装\n\n``` bash\ncnpm install stylus stylus-loader --save-dev\n```\n\n### 在组件中使用\n\n执行完安装命令之后不需要任何配置就可以使用了。\n\n在组件中使用只要把在`style`标签中增加`lang=\"stylus\"`就可以用了\n\n### 在vue文件中引用\n\n```stylus\n<style lang=\"stylus\">\n  @import \"assets/common.styl\";\n  .main_wrapper\n      padding 12 20px\n</style>\n```\n### stylus 编码风格\n\n``` stylus\n$shadow = 0px 3px 6px -2px rgba(0,0,0,0.3)\n\n// mixins\nflexvc()\n    display flex\n    items-align center\n\n// method\nadd (a,b = 10)\n    a + b // 函数可省略返回值\n\n.card\n.card2\n    box-shadow $shadow\n    &:hover\n        background-color #F4F5F6\n\t.footer\n        border-top #ededef\n```\n\n可以看到stylus的写法非常简洁，层级关系使用缩进来表示，分号、冒号、大括号都是可选项，可写可不写。\n\n## 使用语法\n\n1. **选择器**\n   stylus选择器规则和css一样.class选择、#id选择、[type=textarea]属性选择器等等\n   ``` stylus\n   p\n    color #f00\n   ```\n   编译后\n   ``` css\n   p{\n       color: #f00;\n   }\n   ```\n   多个选择器共用\n   ``` stylus\n   .card,.box\n   or    \n   .card\n   .box\n       box-shadow 0px 3px 6px -2px rgba(0,0,0,0.3)\n   ```\n   父级引用,stylus中使用&指向父选择器，可以用来做各种伪类选择器，伪元素等等\n   ``` stylus\n   li\n       background-color #F3F4F5\n       border-bottom 1px solid #f4f5f6\n       &:hover\n           background-color #ccc\n       &:last-child\n           border-bottom none\n   ```\n2. **变量**\n\n   ``` stylus\n   primary-bg = #3A75E7\n   .main_wrapper\n       background-color primary-bg\n   ```\n\n   **标识符**（变量名，函数等），也可能包括`$`字符。例如：\n\n   ``` stylus\n   $font-size = 14px\n   p\n       font-size $font-size\n   ```\n\n   **属性查找**\n\n   Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下：\n\n   ``` stylus\n   #logo\n     position: absolute\n     top: 50%\n     left: 50%\n     width: w = 150px\n     height: h = 80px\n     margin-left: -(w / 2)\n     margin-top: -(h / 2)\n   ```\n   我们不使用这里的变量`w`和`h`, 而是简单地前置`@`字符在属性名前来访问该属性名对应的值：\n   ``` stylus\n   #logo\n     position: absolute\n     top: 50%\n     left: 50%\n     width: 150px\n     height: 80px\n     margin-left: -(@width / 2)\n     margin-top: -(@height / 2)\n   ```\n3. **函数**\n   一个简单的函数\n   ``` stylus\n   add(a,b)\n       a + b // 省略return\n   body\n       padding add(10px, 5)\n   ```\n   默认参数\n   ``` stylus\n   add(a, b =a)\n       a = unit(a, px) // unit把单位都变成px\n       b = unit(b, px)\n   \ta + b\n   add(15%, 10deg)\n       // => 25\n   ```\n   多个返回值\n   ``` stylus\n   paddings()\n       25px 12px\n   \n   .main \n       padding paddings()\n       // 编译后 => padding: 25px 12px;\n   ```\n4. **混合**\n   混合和函数定义差不多，但是效果不一样。函数有返回值，混合没有。\n   比如我们想定义一个垂直居中的横向flex布局可以像下面这样:\n   ``` stylus\n   flexvc()\n   \tdisplay flex\n       align-items center\n   .main-list\n       flexvc()\n   ```\n   父级引用\n   比如说我们想创建一个条纹表格,`even`和`odd`均提供了默认颜色值，每行也指定了`background-color`属性。我们可以在`tr`嵌套中使用`&`来引用`tr`，以提供`even`颜色。\n   ``` stylus\n   stripe(even = #fff, odd = #eee)\n    tr\n      background-color odd\n      &.even\n      &:nth-child(even)\n          background-color even\n   ```\n   然后利用混合书写,如下:\n   ``` stylus\n   table\n       stripe()\n   \n   table#data-grid\n       stripe(#212121, #494848)\n   \ttd\n           color white\n   ```\n5. **插值**\n\n   Stylus支持通过使用`{}`字符包围表达式来插入值，其会变成标识符的一部分。例如，`-webkit-{'border' + '-radius'}`等同于`-webkit-border-radius`.\n\n   比较好的例子就是私有前缀属性扩展：\n\n   ``` stylue\n   vendor(prop, args)\n   \t{prop} args\n   .well\n   \tborder-radius 4px\n   ```\n\n   **选择器插值**\n\n   ``` stylus\n   table\n     for row in 1 2 3 4 5\n       tr:nth-child({row})\n         height: 10px * row\n   ```\n\n   编译后\n\n   ``` stylus\n   table tr:nth-child(1) {\n     height: 10px;\n   }\n   table tr:nth-child(2) {\n     height: 20px;\n   }\n   table tr:nth-child(3) {\n     height: 30px;\n   }\n   table tr:nth-child(4) {\n     height: 40px;\n   }\n   table tr:nth-child(5) {\n     height: 50px;\n   }\n   ```\n\n6. **注释**\n\n   单行注释\n\n   ``` stylus\n   // 单行注释\n   ```\n\n   多行注释\n\n   ``` stylus\n   /*\n    * 多行注释\n    */\n   ```\n\n   ## 总结\n\n   总的来说写法和很多css预处理语言很相似，但是stylus写法更简洁一些，入门也更简单。上面介绍到的功能和用法能满足大部分日常使用需要了。如果还需了解的更加深入的话可以去读下这份[文档](www.zhangxinxu.com/jq/stylus/)。","tags":["vue"],"categories":["vue"]},{"title":"vue自定义指令实现功能级权限","url":"/haoge744.github.io/2019/08/24/vue自定义指令实现功能级权限/","content":"\n### 自定义指令使用介绍\n\n在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。\n\n自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n\n<!-- more -->\n\n#### 钩子函数参数\n- `el`：指令所绑定的元素，可以用来直接操作 DOM 。\n- `binding`：一个对象，包含以下属性：\n  - `name`：指令名，不包括 v- 前缀。\n  - `value`：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n  - `oldValue`：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n  - `arg`：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n  - `modifiers`：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n- `vnode`：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。\n- `oldVnode`：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n\n### 功能实现\n\n权限的获取是在登录时获取，获取完之后缓存至cookie和vuex中，防止用户刷新后出现的问题。然后每次刷新初始化时尝试从cookie中取出权限项再次放入vuex。\n\n``` javascript\n// store/morules/user.js 用户存储的状态信息\nimport {setRoles, getRoles} from '@/utils/cookieHelper'\nimport Vue from 'vue'\nconst user = {\n  state: {\n    roles: getRoles()\n  },\n  mutations: {\n    SET_ROLES: (state, val) => {\n      setRoles(state, val)\n      Vue.set(state,'roles', val)\n    }\n  },\n  actions: {\n\n  }\n}\nexport default user\n```\n\n``` javascript\n// cookieHelper.js \nimport Cookies from 'js-cookie' // cookie存取使用了js-cookie的组件\n\nexport function setRoles (roles) {\n  return Cookies.set('roles', roles.split())\n}\n\nexport function getRoles () {\n  // const roleStr = Cookies.get('roles')\n  const roleStr = 'admin' // 先写死一个变量 利于测试\n  if (roleStr) {\n    return roleStr.split(',')\n  } else {\n    return []\n  }\n}\n```\n\n#### 实现自定义指令功能\n\n``` javascript\n// 新建 directive/auth.js\n\nimport Vue from 'vue'\nimport store from '../store'\n\n\nVue.directive('permission', {\n  inserted: (el, binding) => { // 如果使用bind钩子会找不到父元素\n    const { value } = binding\n    let hasPermission = false\n    const myRoles = store.getters.roles\n    if (value && value instanceof Array && value.length > 0){\n      hasPermission = value.some(item => {\n        return myRoles.includes(item)\n      })\n    }else {\n      throw new Error('参数错误')\n    }\n    if(!hasPermission){ // 没有权限移除该元素\n      el.parentNode.removeChild(el)\n    }\n  }\n})\n\n\n```\n\n``` javascript\n    // 在main.js中引入auth.js\n\t// 测试成功后，把cookieHelper中的返回的权限改为其他值后，按钮隐藏了\n\t<el-button v-permission=\"['add', 'admin']\">添加</el-button>\n```\n","tags":["vue"],"categories":["vue"]},{"title":"活着-生命的意义","url":"/haoge744.github.io/2019/08/19/活着-生命的意义/","content":"![活着](活着-生命的意义/tolive.jpg)\n\n<!-- more -->\n\n### 内容梗概\n\n主人公富贵在年轻时是一个地主家的大少爷，整天游手好闲，无所事事，又嫖又赌，每天还骑着一个胖嘟嘟的妓女和老丈人打招呼，还不以为耻。最终家产被败光。父亲被他气死。所幸妻子家珍对他不离不弃，并且激励富贵要好好生活。富贵好不容易又重燃对生活的信心，不料母亲病倒了，富贵去城里找郎中却又遇上了国民党抓壮丁。被编入了队伍，好不容易没被子弹打死，没有饿死，之后被共产党俘虏，费劲千辛万苦总算回到家乡。本以为回到家一切都会好起来，谁知却是悲剧的开端，母亲病逝了，女儿凤霞也因为发高烧没能及时医治成为了聋哑人。富贵心里别提多难受了。不过自己还有个儿子呢。不过烦心的事又来了，儿子有庆到了上学的年龄，但富贵却根本付不起学费。于是和家珍商量着把凤霞送去给有钱人当丫鬟，这才让儿子有学上。直到有一天凤霞因为太想念父母，而自己偷溜回家看看，富贵此时又舍不得送她走了，又将她留在家里，给家里的农活帮忙，日子也能过。一家人整整齐齐，日子也这么开心的过下去，直到有一天，有庆忽然死了，原来有庆因为跑去给县夫人输血，被医生活活抽血抽死在了医院里。本想着要找县长偿命，但县长居然是之前富贵的战友春生，富贵是即悲痛又无奈。家珍说她这辈子不会原谅春生，他欠她们家一条命。\n\n日子又一天天的过去，没转眼凤霞也到了结婚的年纪，经人介绍认识了县城的工人二喜，虽说二喜有点残疾但是人憨厚老实对凤霞又体贴，不嫌弃凤霞不会说话，这么说来二喜对凤霞来说也算是个好归宿。只是没想到幸福这么短暂，凤霞因为生孩子大出血也死在了那家医院。留下一个男孩苦根。富贵的两个孩子相继去世后，家珍也因为辛苦劳作患上软骨病，最终也在家中逝世。一大家子只剩下富贵、女婿二喜和孙子苦根相依为命。几年后,二喜也因为工地发生意外死了。老年的富贵就把外孙苦根接回了乡下和富贵一起生活。一天富贵为苦根熬了豆子，便出去干活，哪想到，苦根因为很久没吃到好吃的，吃了太多的豆子，活活被撑死了。富贵眼睁睁的看着自己的亲人一个个离自己而去，现在只剩他一个人和一头牛陪伴了。\n\n### 总结\n\n读完整本书，很庆幸自己活在一个比较安定的社会中。不会有不会有国民党抓壮丁，不会有大跃进吃不饱肚子也不会有文化大革命被批斗。\n\n富贵在今天看来是旧社会的一个代表性悲剧人物，每次好像快要抓住幸福了，但是上天又会突如其来的给与下一场考验，把你迅速拉向地狱。或许这样的故事才贴近生活吧，才能引发读者的无限遐想。\n虽然年轻时不懂事，因为好赌败光了土地和家产。但是之后正好碰上土改。因为富贵家正好在这之前就已经是贫农了所以才幸免遇难。富贵是个乐观豁达的人，他在面对接踵而至的灾祸时，每次都能挺过来、能坚强的活着。我不知道如果我遇到富贵的遭遇我会不会对人生放弃希望，我经常思考人生活着的意义是什么，是奋发图强出人头地，还是只追求快乐只顾眼前。人们总说要知足，但是如果一知足就会安于现状不去做任何努力。也有人说人到了二十多岁就已经死了只是到八十岁才埋葬，之后工作，成家立业，然后又等着下一辈的出生。又让他们读书成家立业养育后代。如此反复,重复着一天天的生活，像一具行尸走肉。或许真像文中那样说的吧：\n\n> “人应该为活着本身而活着，不是为了活着之外的任何事物所活着。”\n\n家珍是我在文中很喜欢的人物，她是一个聪明善良坚强的人，富贵在赌场赌博的时候，家珍一直都想把他给拉走。只不过不得而终，自己一个人又走了十几里路回家，那个时候她可是大着肚子啊，可见家珍一直都是想把丈夫给拉回正轨的。并且富贵每次在妓院彻夜不归的时候，家珍也没有什么怨言，并且在外人面前也一直照顾丈夫的面子，替他说话。后面富贵家破产家珍也没有怨言跟着富贵搬到茅草屋住。后来家珍的父亲因为富贵败家把家珍给接走了。所幸后来又回来了，但是没有人知道她付出的代价是什么。在富贵服兵役的两年间，婆婆病倒，凤霞发烧变成聋哑人，她不知道富贵去了哪，也不知道他是否能回来，他只能自己在扛着。谁能知道她有多少次绝望，她在夜里哭过多少次呢。在大饥荒期间，好不容易拉下脸去父亲那要回了一小袋米。才让家里吃上了几顿粥，之后队长来苦苦相求要一点的时候家珍也没有吝啬，给了他一些带回给家里，由此可见她的善良。在有庆死后，富贵并没有马上告诉家珍，但家珍还是从丈夫的神情和反常的行为中发现了儿子已死，但是她并没有大哭大闹，反而只是提议带她去儿子的墓看一看。这段经历也体现出家珍的聪明和冷静。在我看来这样一个善良聪慧又忠诚的女子在现实中是不可多得的，也是现在女性学习的榜样。\n\n### 写在后面\n\n这本小说是差不多2年前读的，剧情在脑中也有些模糊了，文中所有难免会有些误差。请见谅。\n","tags":["生活记事","读后感"],"categories":["生活记事"]},{"title":"filco入手评测","url":"/haoge744.github.io/2019/08/15/filco入手评测/","content":"## 使用感受\n\n话说花一千多块买一把键盘到底值不值？不过我为了体验顶级键盘的手感，还是忍痛割爱了。\n说实话这款键盘我早就看中了，犹豫了很久。最后还是没忍住哈哈。\n对于程序猿这种重度使用键盘的人群，给自己一把好一点的键盘，我觉得也是可以奖励给自己的啊。毕竟时不时给自己一个小礼物，有助于提升自己的幸福感呢。\n\n![包装图](filco入手评测/filco1.jpg)\n包装图\n<!-- more -->\n\n\n包装中规中矩吧，上面也显示支持有线和蓝牙连接，赠送了一个拔键器、防尘罩、两节电池、还有两个键帽，这个待会再说有什么用。\n\n![包装图](filco入手评测/filco2.jpg)\n键盘整体图\n\n从外观上说我觉得还可以，没有现在游戏键盘那么多花里胡哨的各种灯，各种特效。我比较喜欢这种稳重的黑，也没有背光灯。给人看起来比较低调。\nfilco采用的是Abs材质的键帽，懂行的可能知道，Abs键帽虽然手感好，但是时间长了之后，键帽容易打油。个人更喜欢Abs的键帽，虽然Pbt的键帽不会打油，但是磨砂的手感完全比不上Abs类肤的手感。尤其是filco，键帽的厚度和大键的手感调试的非常好。大键和小键的手感几乎完全一样，一般中低端的樱桃轴键盘，大键的手感要么很肉，要么给人感觉就像黑轴一样 很硬。filco给人的感觉相当完美。\n\n![包装图](filco入手评测/filco3.jpg)\nLOGO特写\n\n由于我买的是青轴，声音非常清脆，打字声音比较大，但还可以接受。另外键盘手感比我的 IKBC DC108好了很多。IKBC给我的感觉有点偏硬了。\n因为我喜欢桌面整洁，所以选了双模版，这款键盘支持4台设备切换，但是它这个蓝牙连接方式，要看说明书才能学会。另外键盘右下方好像没有菜单键，这时候赠送的键帽就派上用场了，可以把右win换成菜单键，开一下键盘底下的一个开关就好了,然后换一下键帽，完美。\n## 总结\n根据这几个星期的使用感受，我总结了以下优缺点：\n优点：\n1. 手感。filco的手感一直是它最大的卖点，这点我非常满意。\n2. 双模 没有线的束缚，如果再配上一个无线鼠标，简直爽的一批。\n3. 设计 键帽整体设计给我感觉落落大方，键帽的字体我也很喜欢，还有就是右上角雕刻的LOGO，设计也很棒。\n\n缺点：\n\n1. 贵。\n2. 键帽易打油，这是Abs通用的缺点，使用1至2年就需要更换键帽了。","tags":["生活记事"],"categories":["生活记事"]},{"title":"嫌疑人X的献身读后感","url":"/haoge744.github.io/2019/08/13/嫌疑人X的献身读后感/","content":"\n## 内容简介:\n\n百年一遇的数学天才石神，每天唯一的乐趣，便是去固定的便当店买午餐，只为看一眼在便当店做事的邻居靖子。靖子与女儿相依为命，失手杀了前来纠缠的前夫。为救靖子，石神提出由他料理善后。石神以数学家缜密的逻辑思考设了一个匪夷所思的局，为靖子提供了天衣无缝的不在场证据，令警方始终只能在外围敲敲打打，根本无法与案子沾边。\n\n![封面图](嫌疑人X的献身读后感/timg.jpg)\n\n<!-- more -->\n\n## 正文:\n\n看书封面的简介，确实很吸引读者去阅读，这本推理小说和普通推理小说不同的是，一开始就告诉你犯罪嫌疑人是谁了，真正让读者感兴趣的是，石神是利用什么手法和技巧和警方斗智斗勇,制造骗局的。\n\n石神是个数学天才，深爱着数学，可以为了一道数学谜题孜孜不倦到深夜。某天早晨，石神像往常一样离开公寓，路过公园，径直去靖子打工的便利店买便当，路上碰到熟人打了个招呼，随后到了便利店。像往常一样来了一份便当打包带走，他依然不敢直视靖子。石神走后没多久，没想到靖子的前夫慎二又前来纠缠，在靖子家里成功索财后，还不忘威胁道：“你们逃不出我的手掌心”,这个时候实在忍不住的靖子的女儿美里给了他一榔头，慎二顿时大怒和母女厮打在一起，为了保护女儿，靖子也失去了理智，等到回过神来，前夫慎二已经被她用被炉电线勒死。此时 惊魂未定的母女还未从刚刚的灾难中缓过神来，敲门声突然响起。仓促收拾现场后，靖子开了门.\n\n\n\n> 一开门，只见石神那张大圆脸。细缝般的小眼睛对着靖子，他面无表情，这点令人毛骨悚然。\n> “呃……请问……有什么事吗？”靖子对他挤出微笑，她知道自己的脸颊僵硬。\n> “因为我听到很大的声音。”石神依旧用难以判读情绪的表情说道，“出了什么事吗？”\n> “不，什么事也没有。”她用力摇头，“对不起，给您添麻烦了。”\n> “没事就好。”\n> 靖子发现石神的小眼睛正朝室内看去，全身顿时一热。\n> “呃，是蟑螂……”她情急之下脱口而出。\n> “蟑螂？”\n> “对。因为有蟑螂，所以……我跟我女儿想打蟑螂……所以才引起骚动。”\n> “杀死了吗？”\n> “啊？……”石神的问题，令靖子的脸颊突然绷紧。\n> “蟑螂消灭了吗？”\n> “啊……对。那当然是解决了。已经没事了，对。”靖子频频点头。\n> “这样吗？如果有什么我能帮忙的尽管说，别客气。”\n> “谢谢。吵到您，真的很不好意思。”靖子鞠个躬，关上门，顺便锁上。听到石神回到住处关门的声音，她呼的吐出一口大气，忍不住当场蹲了下来。\n\n\n\n没想到石神通过室内的物品摆放，聊天对话以及气味，已经判断出发生了什么。在靖子母女考虑要不要自首的时候，石神打电话来了,他直接开门见山的说 “女人是无法处理尸体的”，他说他可以帮忙，一方面被石神的逻辑能力和冷静震惊一方面她也只好让石神帮忙。靖子好奇为什么他会知道，问他原因:\n\n> “刚才我来的时候，府上仍留有烟味，所以我本来以为有客人在，却没有看到客人的鞋子。但暖桌底下却好像有人，暖桌的电线也没插上。如果要躲应该躲进屋里。换句话说，这表示暖桌下的人不是躲起来而是被藏起来。再加上之前打斗的声音，你又罕见的蓬头散发，当然想像得到发生了什么事。还有一点，这栋公寓没有蟑螂，我在这已定居多年可以打包票。”\n\n剧透就到这里了。石神和母女说他会搞定尸体，为靖子母子布置了一个匪夷所思的局，一个完美的不在场证明，把他们保护在安全港中，为了他们的安全，石神不顾一切，不惜把自己塑造成一个杀人犯，跟踪狂，只为让靖子安稳度过余生。如果不是石神的天才校友汤川学洞察了这一切，恐怕剧本真的会朝着石神想的那样走。替靖子顶罪，给世人留下一个变态杀人跟踪狂的骂名。\n\n但靖子最终还是从汤川中获知了惊人的真相。她实在无法理解石神居然会为了自己这么一个毫无长处, 长相平凡的女人毁了一生。她之后在之前交换信封的盒子里翻出了这样一句话。\n\n> “工藤邦明先生似乎是个诚实可靠的人。和他结婚，你和美里获得幸福的几率应该比较高。请把我完全忘记，千万不要有罪恶感。因为如果你过得不幸福，我的行为将会完全成为徒劳。”\n> 她看了又看，再次落泪。\n> 她以前从没遇到过这么深的爱情，不，她连世上有这种深情都不知道。石神面无表情的背后，其实藏着常人难以理解底蕴的爱情。\n\n完\n\n## 感悟\n\n这本书全文几乎没有一句废话，一些不起眼的细节也有可能是伏笔。相比其早年的作品，文笔越加狠辣、细腻。让人读起来过瘾。此外，谜底的设计也惊为天人，整本书逻辑相辅而成，没有太多的剧情bug。\n\n其实几年前就读过这本书，一直都想写篇读后感。为了写这篇读后感，我几乎将整本书重看了一遍。而且正是这本书让我对作者有了全新的认知，之前我只读过他的《解忧杂货店》，没想到他的推理小说 更精彩，之后读了他的相关《白夜行》《恶意》《放学后》等推理小说，觉得特别好，除了巧妙的布局之外还经常描写人性，让人意味深长。\n\n另外东野圭吾曾想几度冲击直木奖，但是都只得到了提名，但是这次《嫌疑人x的献身》终于让他如愿以偿，并且还冲击了当年年度推理小说本格奖和推理小说排行榜第一，这让东野圭吾的知名度得到了很高的提升，我觉得正是这个原因，才有了东野圭吾作品大量翻拍成电影、电视剧的现象。","tags":["生活记事","读后感"],"categories":["生活记事"]},{"title":"v-slot的使用","url":"/haoge744.github.io/2019/08/12/v-slot的使用/","content":"\n## v-slot介绍\n\n`vue2.6.x`开始，vue为具名和范围插槽引入了一个全新的语法,即`v-slot`。目的就是想统一`slot`和`scope-slot`语法，使代码更加规范和清晰。\n\n还在`2.5.x`的小伙伴注意`v-slot`只支持在`vue2.6`以上使用，想用的同学请先升级版本哦。\n\n我们看看v-slot和之前的语法区别吧。\n\n<!-- more -->\n### 局名插槽\n\n``` html\n<!-- base-layout.vue -- >\n<div class=\"container\">\n\t<header>\n\t\t<slot name=\"header\"></slot>\n\t</header>\n\t\n\t<main>\n\t\t<slot></slot>\n\t</main>\n\t<footer>\n\t\t<slot name=\"footer\"></slot>\n\t</footer>\n</div>\n```\n\n使用\n\n``` html\n<!-- 过时语法 -->\n<base-layout>\n\t<template slot=\"header\">\n\t\t<h1>ssss</h1>\n\t</template>\n\t<p>12125125<p>\n\t<p>198248924</p>\n\t<template slot=\"footer\">\n\t\t<p>Some Description</p>\n\t</template>\n</base-layout>\n```\n\n使用v-slot指令改写:\n\n``` vue\n<base-layout>\n\t\t<template v-slot:header>\n\t\t\t<h1>title</h1>\n\t\t</template>\n\t\t<p>some content</p>\n\t\t<p>some content</p>\n\t\tor\n\t\t<template v-slot:default>\n\t\t</template>\n\t\t<template v-slot:footer>\n\t\t\t<p>some content</p>\n\t\t</template>\n\t</base-layout>\n```\n\n### 作用域插槽:\n\n``` vue\n<!-- 首先定义绑定对象 -->\n<span>\n    <slot v-bind:user=\"user\">\n    </slot>\n</span>\n```\n\n\n\n``` vue\n<!-- 过时语法 -->\n<slot-example>\n  <template slot-scope=\"slotProps\">\n    {{ slotProps.user.name }}\n  </template>\n</slot-example>\n```\n\n``` vue\n<!-- v-slot的写法 -->\n<slot-example>\n  <template v-slot=\"slotProps\">\n    {{ slotProps.user.name }}\n  </template>\n</slot-example>\n\n<!-- 可解构赋值改写成以下内容 -->\n<slot-example>\n  <template v-slot=\"{user}\">\n    {{ user.name }}\n  </template>\n</slot-example>\n\n<!-- 可以给结构变量赋默认值,防止未定义 -->\nv-slot=\"{user = {name: 'ghost'} }\"\n```\n\n### 简写形式\n\n事件绑定和数据绑定使用的是@和:，v-slot推出后也有一个简写符号，即使用# 代替v-slot例如\n\n``` vue\n<base-layout>\n\t\t<template #header>\n\t\t\t<h1>title</h1>\n\t\t</template>\n\t\t<p>some content</p>\n\t\t<p>some content</p>\n\t\tor\n\t\t<template #default>\n\t\t</template>\n\t\t<template #footer>\n\t\t\t<p>some content</p>\n\t\t</template>\n</base-layout>\n```\n\n然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n\n``` vue\n<!-- 这样会触发一个警告 -->\n<current-user #=\"{ user }\">\n    {{ user.firstName }}\n</current-user>\n```\n\n如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：\n\n``` html\n<current-user #default=\"{ user }\">\n    {{ user.firstName }}\n</current-user>\n```\n\n## 实际使用\n\n接下来写一个导航组件，每个导航可能会有图标或者badge，这个实际使用要看后台数据。首先先写两个组件\n\n``` vue\n<!-- NavList.vue 导航的父组件 -->\n<template>\n  <nav class=\"nav_wrapper\">\n    <!-- 循环迭代导航列表，默认只显示导航的名称 -->\n    <slot v-for=\"item in navList\" v-bind:item=\"item\">\n      <NavItem>\n        {{ item.name }}\n      </NavItem>\n    </slot>\n  </nav>\n</template>\n\n<script>\nimport NavItem from './NavItem'\nexport default {\n  components: {\n    NavItem\n  },\n  props: {\n    navList: {\n      required: true,\n      type: Array\n    }\n  },\n  name: 'NavList'\n}\n</script>\n\n<style scoped lang=\"stylus\">\n.nav_wrapper\n  background-color #545c64\n  color white\n  display flex\n  flex-flow row nowrap\n  padding 0px 40px\n  height 40px\n  align-items stretch\n  & >>> .nav_item // 让子组件的css生效\n    text-decoration none\n    padding 0 40px\n    cursor: pointer\n    display flex\n    align-items center\n    &:hover\n      background-color black\n  & >>> .nav_item_icon img <!-- 给子组件的导航图标设置的样式 -->\n    width 30px\n    height 30px\n    display flex\n    align-items center\n    margin-right 10px\n\n</style>\n```\n\n``` vue\n<!-- 导航的子组件 NavItem.vue -->\n<template>\n  <a class=\"nav_item\">\n    <!-- 导航的图标,默认没有, 在slot标签上设置class不生效,所以用span包裹一下 -->\n    <span class=\"nav_item_icon\"> \n      <slot name=\"icon\"></slot>\n    </span>\n    <slot></slot>\n    <slot name=\"badge\" class=\"nav_item_badge\"></slot>\n  </a>\n</template>\n\n<script>\nexport default {\n  name: 'NavItem'\n}\n</script>\n\n<style scoped>\n</style>\n```\n\n两个相互搭配的组件写好了，接下来开始使用了:\n\n``` vue\n<!-- index.vue -->\n<template>\n  <div>\n    <NavList :navList=\"navList\">\n      <template v-slot=\"{item}\">\n        <NavItem>\n          <!-- 菜单项中有图标则显示、没有则隐藏 -->\n          <template v-slot:icon v-if=\"item.icon\">  \n            <img :src=\"item.icon\" alt=\"\" >\n          </template>\n          {{ getName(item) }}\n\t\t  <!-- 菜单项中有badge则显示、没有则隐藏 -->\n          <template v-slot:badge v-if=\"item.badge\">\n\t\t\t<!-- badge的样式是在父组件中定义的， -->\n            <span class=\"nav_item_badge\">\n              {{ item.badge }}\n            </span>\n          </template>\n        </NavItem>\n      </template>\n      \n    </NavList>\n  </div>\n</template>\n\n<script>\nimport NavList from '@/components/NavList'\nimport NavItem from '@/components/NavItem'\nexport default {\n  name: 'index',\n  components: {\n    NavList,\n    NavItem\n  },\n  data () {\n    return {\n      navList: [{ // 导航菜单的列表\n        name: 'home',\n        icon: require('../../assets/icon.png')\n      },{\n        name: 'news',\n        badge: 2\n      },{\n        name: 'tags'\n      },{\n        name: 'about',\n        icon: require('../../assets/logo.png'),\n        badge: 3\n      }]\n    }\n  },\n  methods: {\n    getName (item) {\n      return item.name.toUpperCase()\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"stylus\">\n  .nav_item_badge \n    width 10px\n    height 10px\n    padding 5px\n    display flex\n    align-items center\n    justify-content center\n    margin-top -12px\n    margin-left 4px\n    font-size 10px\n    border-radius 50%\n    background-color red\n    color: white\n</style>\n```\n\n效果如下:\n\n![效果](v-slot的使用/slot.png)\n\n\n可能样式不是很完美，但是今天主题还是v-slot, 为什么不在NavItem里设置badge的样式呢？这是因为badge的宽高设定之后，父组件无法控制其隐藏。我目前暂时没有想到好的办法。另外本身badge这个东西也应该封装成一个组件的，如果在子组件里写死了那么久丧失了灵活性。另外这个导航本身实际项目中应该不会这样写，这只是一个v-slot的使用样例，仅供参考。\n","tags":["vue"],"categories":["vue"]},{"title":"echarts地图钻取位置异常的解决办法","url":"/haoge744.github.io/2019/08/08/echarts地图钻取位置异常的解决办法/","content":"因为有需求要做一个中国地图下钻到市的功能，但是在钻取中放大的时候碰到了地图位置显示异常的问题，切换地图的时候偶尔会出现地图找不到的问题，如下图:\n\n![错误图](echarts地图钻取位置异常的解决办法/map1.gif)\n\n<!-- more -->\n地图下钻逻辑，初始化的时候缓存全国的地图，省的多次加载，我这里实现echarts下钻的核心方法是 `registerMap(mapName,geoJson,specialAreas)`作用是向echarts内注册一个地图，这个地图的第一个参数是地图名字，可以自定义，第二个是geoJson，可以自己画geojson的数据也可以在echarts的github地址里找到关于中国省市区的地图数据(echarts官网已经下载不了了),访问这个[链接](https://github.com/apache/incubator-echarts/tree/master/map)可以下载到。第三个是可选参数，具体参考文档。\n\n在官网上看到了地图的series中可以设置`center`参数，然后在地图json中看到了每个城市也有经纬度的数据所以可以每次钻取的时候给series设置当前城市的中心点来避免问题发生。\n![广东省地图geoJSON数据](echarts地图钻取位置异常的解决办法/json1.png)\n\n\n\n### 代码:\n\n``` javascript\nexport default {\n    // ... somecode\n    methods: {\n        // ...somecode\n        init () { // 地图初始化，把画布大小调整为全屏以及注册点击事件\n          const dom = document.getElementById('map-wrapper')\n          dom.style.width = document.body.clientWidth + 'px'\n          dom.style.height = document.body.clientHeight + 'px'\n          this.chartInstance = echarts.init(dom)\n          this.chartInstance.on('click', this.chartClickHandler)\n        },\n        chartClickHandler (params) { // 地图点击事件\n          if (params.name in provinces) { // 点省级或者直辖市\n            if (special.indexOf(params.name) >= 0) {\n              this.$toast('直辖市不支持放大')\n              return\n            }\n            this.isNational = false \n            const key = provinces[params.name]\n            const name = params.name\n            this.$toast.loading({\n              mask: true,\n              duration: 0\n            })\n            // 请求static路径下城市的geoJSON.json数据\n            getMapJson(`./static/map/province/${key}.json`).then(async response => {\n              let cityData = []\n              let cityMap = {}\n              console.log(response.data.features[0].properties.name)\n              const lat = response.data.features[0].properties.cp // 获取json里第一个城市的经纬度\n              response.data.features.forEach(item => { // 没有数据的展示零\n                cityMap[item.properties.name] = 0\n              })\n              try {\n                if (this.provIdKeyMap.get(name)) {\n                    // 根据省的id拿到后台数据展示\n                  let cData = await getCityData(this.provIdKeyMap.get(name).split('_')[0]) // 根据省id 获取市的数据\n                  if (cData.status === 200) {\n                    cData.data.forEach(item => {\n                      cityMap[item.cityname] = item.ftreermb\n                    })\n                  }\n                }\n                this.$toast.clear()\n              } catch (error) {\n                this.$toast('加载地图数据失败')\n              }\n              for (let a in cityMap) { // 遍历组装所有市的数据\n                let showLabel = cityMap[a] ? true : false \n                cityData.push({\n                  name: a,\n                  value: cityMap[a],\n                  label: {\n                    show: showLabel\n                  }\n                })\n              }\n              echarts.registerMap(name, response.data) // 注册地图\n              this.renderMap(name, cityData, lat) // 渲染\n            })\n          } else {\n            this.isNational = true\n            this.renderMap('china', this.nationalData)\n          }\n        },\n        // 渲染地图\n        renderMap (map, data, lat = [103.754, 34.452]) { // 地图名字, 数据, 经纬度\n          this.$set(this.option.title, 'subtext', map)\n          const series = [{\n            name: map,\n            type: 'map',\n            mapType: map,\n            roam: true,\n            zoom: 2,\n            nameMap: {'china': '中国'},\n            left: 20,\n            top: '30%',\n            center: lat, // 设置中心点 默认中国的中心点\n            showLegendSymbol: false,\n            label: {\n              normal: {\n                show: true,\n                textStyle: {color: '#000', fontSize: 14}\n              },\n              emphasis: {\n                show: true,\n                textStyle: {color: '#999', fontSize: 14}\n              }\n            },\n            itemStyle: {\n              normal: {\n                areaColor: '#E6E6FA',\n                borderColor: 'dodgerblue',\n                label: {\n                  show: true,\n                  formatter: '{b}\\n{c} '\n                }},\n              emphasis: {\n                areaColor: 'darkorange'\n              }\n            },\n            data: data\n          }]\n          //设置option\n          this.$set(this.option, 'series', series)\n          this.chartInstance.setOption(this.option)\n        }\n    }\n}\n```\n\n完成后效果如下:\n\n![虽然有点瑕疵,但好歹还是解决了问题](echarts地图钻取位置异常的解决办法/map2.gif)\n\n### 不显示数据为零的地名\n\nseries里的data也可以设置label的样式和隐藏显示,设置标签位置等等等。详细配置请访问[链接](https://echarts.baidu.com/option.html#series-map.map)\n\n``` javascript\n{\n    name: a,\n        value: cityMap[a],\n            label: {\n                show: showLabel // 判断数据是否为空或者零\n            }\n}\n```\n\n\n\n","tags":["echarts","移动开发"],"categories":["echarts"]},{"title":"vue项目使用lottie动画","url":"/haoge744.github.io/2019/08/08/vue项目使用lottie动画/","content":"Lottie是一个开源动画框架，支持Android，IOS，ReactNative以及web开发，这篇文章主要讲Lottie在vue项目中如何使用。[GitHub地址](https://github.com/chenqingspring/vue-lottie),我在官方社区看了一下，交互性非常好，动画支持倍速播放，倒放，暂停等功能，能熟练使用的话，交互性能提升很多。\n\n### 安装\n\n在安装目录执行以下命令:\n\n``` bash\nnpm install --save vue-lottie\n```\n\n<!-- more -->\n\n## 使用\n\n准备好动画json文件。可以让UI处理好:\n\n1. UI使用AE--安装bodymovin插件-将AE中的动画工程文件通过bodymovin转换为.json文件--发给开发-开发集成Lottie框架-直接在项目中使用。\n\n2. 或者是在官方库里找:[链接](https://lottiefiles.com/popular)。\n\n具体代码:\n\n``` javascript\n<template>\n    <div>\n        <Lottie :options=\"defaultOptions\" v-on:animCreated=\"handleAnimation\" />\n    </div>\n</template>\n\n<script>\nimport Lottie from 'vue-lottie'\n// 引用动画json文件，在官网下载的。\nimport * as animeData from '../assets/anime.json'\nexport default {\n  name: 'animate',\n  components: {\n      Lottie\n  },\n  data () {\n    return {\n        // ... some code\n        defaultOptions:{\n            animationData: animeData\n        }\n    }\n  },\n  methods: {\n    handleAnimation: function (anim) {\n        this.anim = anim\n    }\n  }\n}\n</script>\n\n<style scope>\n    ...some code\n</style>\n\n```\n\n效果:\n![使用效果](vue项目使用lottie动画/lottie.gif)\n\n### 常用配置:\n\n以上配置只用到了animationData,下面列出一些常用的，更多配置项请在该[链接](https://github.com/bodymovin/bodymovin)中查看\n\n- animationData:  动画json\n- path: 可直接指定动画json // 路径\n- loop: true / false / number //循环\n- autoplay: true / false // 自动播放\n- name:  // 给动画取名字,方便方法调用\n- renderer: 'svg' / 'canvas' / 'html'  //渲染方式\n- container: the dom element on which to render the animation // 可直接指定dom节点渲染\n\n\n\n","tags":["移动开发","vue"],"categories":["vue"]},{"title":"uni随手笔记一","url":"/haoge744.github.io/2019/08/04/uni随手笔记一/","content":"\n自己看官方文档做的一些笔记，记了一些和vue差异的地方和印象较深的地方。看看就好哈哈。\n\n<!-- more -->\n\n### 编写uni注意事项\n\n用uni-app想兼容多端，不能使用带dom、window操作的库，并且最好是纯flex布局，如果只开发h5端，推荐还是用vue-cli构建项目。\n\n### 新老编译模式:\n\n``` javascript\n在manifast.json中配置{\n\t// ...\n\tapp-plus: { // app h5+相关\n\t\tusingComponents: true // 如果是true则是自定义组件模式/否则不是 \n\t},\n\twp-wexin: { // 微信小程序相关\n\t}\n}\n```\n\n**最新版本的XHbuilder默认是自定义组件模式**\n**不支持v-slot新语法 // vue2.6新增**\n\n### npm支持情况\n\n初始化项目\n\n初始化 package.json文件 npm init -y\n\n安装依赖 npm install packageName --save\n\n使用\n\n``` import package from 'packageName'\nconst package = require('packageName')\n* 注意非H5端不支持使用含有dom、window等操作的vue组件和js模块,安装的模块及其依赖的模块使用的api必须是uni-app已有的api, 说明npm 的插件极其难找\n* 支持安装 mpvue组件，但npm方式不支持小程序自定义组件(如wxml格式的vant-weapp)\n```\n\n## 生命周期:\n\n全局生命周期:\n\n| 属性  | 类型 |\n| ------ | ------------ |\n| onLaunch | 当uni-app 初始化完成时触发（全局只触发一次） |\n| onShow | 当uni-app 启动，或从后台进入前台显示 |\n| onHide | 当uni-app 从前台进入后台 |\n| onUniNViewMessage | 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 |\n\n\t组建中新增 onBackPress(event) -- 返回 event ={form: backbutton | navigateBack}\n\t自定义返回键可以看这篇文章:http://ask.dcloud.net.cn/article/35120\n组件生命周期除了vue的基本生命周期额外增加了一些生命周期\n 建议使用 uni-app 的 onReady代替 vue 的 mounted。\n 建议使用 uni-app 的 onLoad 代替 vue 的 created。\n\n`static` 目录下的 `js` 文件不会被编译，如果里面有 `es6` 的代码，不经过转换直接运行，在手机设备上会报错。\n\n## 条件编译及判断运行环境\n\n判断开发环境和生产环境: (方便切换生产环境和正式环境 后台url)\n\n```\n// uEnvDev\nif(process.env.NODE_ENV === 'development'){\n    console.log('开发环境')\n}else{\n    console.log('生产环境')\n}\n```\n\n平台条件编译 \n\n```\n// #ifdef H5\n    alert(\"只有h5平台才有alert方法\")\n// #endif\n```\n\n**注意在css或scss等其他样式中，要使用/* #ifdef MP-WEIXIN */代替**\nifdef的可取值如下\n\tAPP-PLUS、APP-PLUS-NVUE（Weex）、H5、MP-WEIXIN、MP-ALIPAY、MP-BAIDU、MP-TOUTIAO、MP-QQ(qq小程序目前仅cli版支持)、MP(非h5和app+/weex)\n\n#### 样式导入:\n\n​\t使用@import 语句导入\n​\t@import \"../../common/uni.css\";\n内联样式以及动态样式\n​\t<view :style=\"color: color\" />\n​\t注意:\n​\t\tpage相当于body节点，例如:\n​\t\tpage {  background-color: #ccc }\n\n#### css 内置变量 快捷键`hei`\n\n\tvar(--status-bar-height)  //系统状态栏高度\n\tvar(--window-top) //内容区域距离顶部的距离 -- NavagationBar的高度\n\tvar(--window-bottom) // 内容区域距离底部的距离 -- tabBar的高度\n注意导航栏和底部选项卡最好用px作为单位\n\t##注意:背景图片仅支持以 ~@ 开头的绝对路径(不支持相对路径!)\n#### 字体图标\n\n\t支持网络路径图标，网络路径必须加协议头https\n\n### vue 使用注意\n\n\t1.1建议使用 uni-app 的 onReady代替 vue 的 mounted。\n\t1.2建议使用 uni-app 的 onLoad 代替 vue 的 created。\n\n事件处理:\n\t// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件\n\n```javascript\n{\n    click: 'tap',\n    touchstart: 'touchstart',\n    touchmove: 'touchmove',\n    touchcancel: 'touchcancel',\n    touchend: 'touchend',\n    tap: 'tap',\n    longtap: 'longtap',\n    input: 'input',\n    change: 'change',\n    submit: 'submit',\n    blur: 'blur',\n    focus: 'focus',\n    reset: 'reset',\n    confirm: 'confirm',\n    columnchange: 'columnchange',\n    linechange: 'linechange',\n    error: 'error',\n    scrolltoupper: 'scrolltoupper',\n    scrolltolower: 'scrolltolower',\n    scroll: 'scroll'\n}\n```\n\n### 基本元素:\nuni-app推荐使用`view`、`text`等元素替代原来的html元素 用`navigator`替代 `a` ,虽然写`div`或者`a`之类的h5标签也不影响使用但是推荐按照官方的来\n\n元素 共同属性类型\n\n| 属性   | 类型         | 说明                                                      |\n| ------ | ------------ | --------------------------------------------------------- |\n| id     | String       | 组件的唯一标示\t保持整个页面唯一                        |\n| class  | String       | 组件的样式类\t在对应的 css 中定义的样式类               |\n| style  | String       | 组件的内联样式\t可以动态设置的内联样式                  |\n| hidden | Boolean      | 组件是否隐藏\t所有组件默认是显示的                      |\n| data-* | Any          | 自定义属性\t组件上触发的事件时，会发送给事件处理函数    |\n| @*     | EventHandler | 组件的事件\t详见各组件详细文档，事件绑定参考 事件处理器 |\n\n","tags":["移动开发","uni-app"],"categories":["uni-app"]},{"title":"vue3.0 新特性","url":"/haoge744.github.io/2019/08/01/vue3-0-新特性/","content":"\n目前vue最新的版本是19年2月份发布的2.6.x,更新了一些插槽、动态参数等，据说3.0也会在下半年发布，下面根据尤大的视频分享总结3.0的新特性。\n<!-- more -->\n\n## Vue3.0即将带来哪些新东西:\n\n- 更快\n- 更小\n- 更易于维护\n- 更好的多端渲染支持\n- 新功能\n\n判断元素是html原生还是组件的时候把这个动作放到了编译时，提高了运行时的性能。跳过不需要的条件判断，生成更易于被JS引擎优化的代码。\n\n#### 优化Slots生成\n\nVue2.0存在父组件更新时，子组件也关联着也更新了。在vue3.0中优化了这一问题。避免不必要的组件渲染。检测组件更新变得更精确。\n\n#### 静态属性提取\n\n跳过整块静态内容的更新\n及时静态内容在列表中被重复也可以生效。\n跳过单个元素的patch，但依然处理子元素。\n\n主要意思是避免元素不必要的更新。\n\n#### 内联时间函数提取\n\n解决组件重新渲染后 再重新创建函数的问题，3.0中第一次创建后会缓存，那么每次重新渲染之后可以避免这个问题。\n\n#### 数据监听改为Proxy\n\n之前的数据监听系统是由Object.definedProperty的，3.0中会修改为Proxy提高了性能。再大规模数据监听的情况下，性能提升明显。\n\n据说提升后组件实例初始化效率加倍，内存占用减半\n\n## 更小\n\n### 代码结构优化\n\n和Tree-shaking(把没有用到的代码，在最后编译时给优化掉)配合，减小包的体积。\n3.0中内置的模块可以按需引入。只引入最基本模块的情况下,依赖包只有10kb左右。\n\n## 更易于维护\n\n对于vue开发团队而言，更易于维护。用TypeScript完全重写vue的源码。并且不影响用户使用。\n\n源码的各个模块更加解耦。更加利于对阅读源码的理解。\n\n#### 编译器重构\n\n使用插件化设计\n带位置信息的parser(source maps!)\n为更好的IDE供给链铺路\n\nruntime时出错提示优化\n\n## 更好的多端渲染支持\n\nvue衍生出Wexx、NativeVue、wePy 等小程序终端。\nvue3会进行更好的优化。\n推出Custom Renderer API，为多端提供更好的渲染。\n\n``` javascript\nimport { createRenderer } from '@vue/runtime-core'\nconst {render} = createRenderer({\n    nodeOps,\n    patchData\n})\n```\n\n## 新功能\n\n#### 响应式数据监听API\n\n``` javascript\nimport {observable, effect} from 'vue'\nconst state = observable({\n    count: 0\n})\neffect(() => {\n    console.log(`count is: ${state.count} `) //每次更改状态时触发的函数\n})// count is: 0\nstate.count ++ //count is : 1\n```\n\n可以很简单的在多组件中实现状态共享\n\n#### 轻松排查组件更新的触发原因\n\n``` javascript\nconst Comp = {\n    render(props) {\n        return h('div', props.count)\n    },\n    renderTriggered(event){\n        debugger // 可在此检查是在哪触发的组件更新\n        //event可查看更多信息，更改了那个key，哪行代码做的更改..等\n    }\n}\n```\n\n#### 更好的TypeScript支持\n\n提升了性能。支持tsx\n\n#### 更好的警告信息\n\n- 组件堆栈包含函数式组件\n- 可以直接在警告信息中查看组件的props\n- 在更多的警告中提供组件堆栈信息\n\n#### 新加Experimental HooksAPI\n\n类似React Hooks,大概率取代mixins。逻辑重用机制。\n\ngithub上已有Vue Hooks这个项目\n\n#### Experimental Time Slicing Support\n\n把js中复杂的计算切成一帧一帧(每16毫秒)，解决用户界面卡顿的问题。\n\n开启Time Slicing，在js计算的时候每次只占用16毫秒左右的工作量，之后把主动权交还给浏览器，这样浏览器有时间去相应用户的操作\n\n## 关于IE\n\n会有一个专门的版本在IE11中自动降级为旧的getter/setter机制。并对IE中不支持的用法给出警告。但在ie中可能享受不到vue的一些新功能。\n\n> 整理的比较乱，具体功能以及使用需要参考相关官方文档。","tags":["vue"],"categories":["vue"]},{"title":"uni-app 入坑系列一","url":"/haoge744.github.io/2019/07/31/uni-app-入坑系列一/","content":"\n# uni的简介和优点\n\n> `uni-app`是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可编译到iOS、Android、H5、以及各种小程序等多个平台。\n\nuni-app的特点和优势在于，跨平台数量多、性能体验好、生态环境好、开发效率高等特点，确实值得现在开发者学习，学习成本也不高。\n\n<!-- more -->\n\n# 项目目录结构\n\n一个uni-app工程，默认包含如下目录及文件：\n```\n    ┌─components            uni-app组件目录\n    │  └─comp-a.vue         可复用的a组件\n    ├─hybrid                存放本地网页的目录，详见\n    ├─platforms             存放各平台专用页面的目录，详见\n    ├─pages                 业务页面文件存放的目录\n    │  ├─index\n    │  │  └─index.vue       index页面\n    │  └─list\n    │     └─list.vue        list页面\n    ├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此\n    ├─wxcomponents          存放小程序组件的目录，详见\n    ├─main.js               Vue初始化入口文件\n    ├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期\n    ├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见\n    └─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见\n```\n# uni-app 和普通Vue项目开发上有什么区别\n\n## 路由\n\nvue项目配置路由页面在`src/router/index.js`文件下配置\nuni-app在项目根目录下的`pages.json`文件配置，并且结构和vue不一样。`pages.json`具体配置项可见[详情](https://uniapp.dcloud.io/collocation/pages)。\n\n路由跳转\nvue使用vue-router的`router-view`和`vue-router`的api进行页面跳转\nuni-app使用[navigator](https://uniapp.dcloud.io/component/navigator)组件跳转、或者调用[API](https://uniapp.dcloud.io/api/router)跳转。\n\n## 组件开发\n\nuni-app和vue一样也使用`.vue`文件来编写组件\n\n但是uni-app的tmeplate层内的标签是使用类似微信小程序的标签元素来编写的，例如用`<view>`和`<text>`来替代html中的`<div>`和`<span>`标签。\n\n## 第三方组件引入\n\n可以[访问](https://ask.dcloud.net.cn/article/35489)进行查看区别。\n\n## 配置文件\n\nuni-app使用manifast.json配置各平台相关信息，\nvue使用package.json webpack.*.conf.js 等配置文件配置\n\n## 状态管理\n\nuni-app也可以使用vuex来管理生命周期，但是nvue模式下不支持。\n\n## 生命周期\n\nuni-app给app环境下添加了几个全局的生命周期\n    onLaunch 当uni-app 初始化完成时触发（全局只触发一次）\n\tonShow\t当 uni-app 启动，或从后台进入前台显示\n\tonHide\t当 uni-app 从前台进入后台\n\tonUniNViewMessage\t对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯\n\n## webpack 配置\n    uni-app也支持使用webpack安装插件，但是只推荐h5平台使用，其他只支持flex布局和不操作dom的库，制作APP个人不推荐使用webpack安装第三方组件。\n","tags":["移动开发","uni-app"],"categories":["uni-app"]},{"title":"hexo项目搭建","url":"/haoge744.github.io/2019/07/21/hexo项目搭建/","content":"\n## 安装\n\n1. 安装Node.js和git 此处不再阐述\n\n2. 执行一下命令全局安装hexo\n\n   ```\n   $ npm install -g hexo-cli\n   或者\n   $ cnpm install -g hexo-cli\n   ```\n<!-- more -->\n\n### 建站\n\n安装完成后执行以下命令\n\n```\nhexo init <folder>\ncd <folder>\nnpm install\n```\n\n### 目录结构\n\n#### 安装完成之后会生成以下目录\n\n```\n.\n├── _config.yml // 网站的配置信息\n├── package.json // package.json 依赖信息，可查看安装了哪些依赖包\n├── scaffolds // \n├── source // 资源文件夹\n|   ├── _drafts\n|   └── _posts\n└── themes // 主题文件夹\n```\n\n## 写作\n\n在hexo目录下 执行以下命令:\n\n``` \nhexo new \"post title\" \n//写完之后执行 hexo g 生成页面\nhexo s \n\n//生成草稿、 草稿不会生成页面\nhexo new draft \"draft title\"\n\n//生成纯页面\nhexo new page \"page title\"\n\n// 发布草稿\nhexp pulic [layout] <filename>\n```\n\n## 命令\n\n部署:\n\n启动本地服务:\n``` bash\nhexo s -g\n```\n\n```bash\nhexo g -d\n```\n","tags":["hexo"],"categories":["hexo"]}]