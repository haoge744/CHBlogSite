[{"title":"vue使用mixins提升开发效率","url":"/haoge744.github.io/2019/11/12/vue使用mixins提升开发效率/","content":"\n> 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n<!-- more -->\n\n在开发一些后台系统的时候，像这样的界面随处可见，那么能不能把其中相同的逻辑抽离出来来节省开发效率呢。vue给我们提供了`mixins`这样的一个混合工具，让我们可以抽离出一部分代码来进行\"合并\"。\n\n![后台管理系统](vue使用mixins提升开发效率/ht.png)\n\n大多数的列表界面都是类似的，不同的地方可能是功能以及数据的列不一样。所以可以把列表的查询条件，查询方法，分页等数据做一个`mixins`。\n\n## 开始使用\n\n``` javascript\n    // 新建 ListMixins.js\n    // 请求后台的方法，传递url和查询参数即可返回列表值，需要后台统一查询接口\n    import { queryListData } from \"@/api/dataTable\";\n    export default {\n        data () {\n            _url: '', // 请求数据的url\n            list: [], // 数据列表\n            page: { // 分页参数\n                pageNum: 1,\n                pageSize: 10,\n                total: 0\n            },\n            loading: false, // 加载状态\n        },\n        methods: {\n            del() { // 删除提示也可以抽出来，在实际的组件中覆盖 doDelete方法就行了\n                this.$confirm('是否确认删除?', '提示', {\n                    confirmButtonText: '确定',\n                    cancelButtonText: '取消',\n                    type: 'warning'\n                }).then(() => {\n                    this.doDelete()\n                })\n            },\n            getQueryParam() { // 获取查询参数 默认是查询条件和分页混合在一起 如果有额外的需求自行添加\n                return {...this.query, ...this.page }\n            },\n            queryListData() { // 加载列表数据\n                const param = this.getQueryParam() // 获取上面定义的参数\n                return new Promise((resolve, reject) => {\n                    this.loading = true // 设置loading\n                    initData(this._url, param).then(res => {\n                        this.loading = false\n                        this.page.total = res.data.total // 设置总数 \n                        resolve(res.data.list)\n                    }).catch(error => {\n                        this.loading = false\n                        reject(error)\n                    })\n                })\n            },\n            init () {}\n        },\n        created () {\n            // 初始化函数， 需要在里面做url和数据的处理\n            this.init()\n        }\n      }\n    }\n\n```\n\n组件中使用:\n\n``` vue\n<template>\n  <div>\n    <!-- 查询部分 -->\n    <div>\n        <el-form :inline=\"true\" size=\"small\" :model=\"query\" class=\"demo-form-inline\">\n            <el-form-item label=\"名称\">\n                <el-input  v-model=\"query.name\" placeholder=\"请输入关键字\"></el-input>\n            </el-form-item>\n            <el-form-item label=\"电话\">\n                <el-input v-model=\"query.phone\" placeholder=\"请输入关键字\"></el-input>\n            </el-form-item>\n            <el-button @click=\"queryData\">查询</el-button>\n        </el-form>\n        <div class=\"pull-right\">\n            <el-button type=\"default\">新增</el-button>\n            <el-button type=\"default\" @click=\"edit\">编辑</el-button>\n            <el-button type=\"default\" @click=\"del\">删除</el-button>\n        </div>\n    </div>\n\t\n    <!-- 列表部分 -->\n    <el-table :data=\"list\">\n        <el-table-column label=\"用户名\" prop=\"name\" align=\"center\">\n        </el-table-column>\n        <el-table-column label=\"电话\" prop=\"name\" align=\"center\">\n        </el-table-column>\n    </el-table>\n    <el-pagination\n          style=\"text-align: center;\"\n          :current-page.sync=\"page.pageNum\"\n          :page-size.sync=\"page.pageSize\"\n          :total=\"page.total\"\n          :page-sizes=\"[10,20,50]\"\n          layout=\"total, sizes, prev, pager, next, jumper\"\n          @size-change=\"queryData\"\n          @current-change=\"queryData\"/>\n  </div>\n</template>\n\n<script>\n    import ListMixin from '../mixins/ListMixins'\n\texport default {\n        mixins: [ListMixin],\n        methods: {\n            init () {\n                this._url = 'xxx/xxx/query' // 覆盖查询的url\n                this.queryData()\n            },\n            doDelete () {\n              // 调用删除接口  \n            },\n            queryData () {\n                this.queryListData().then(res => {\n                    this.list = res\n                })\n            }\n        }\n    }\n</script>\n\n```\n\n我这里用的是`element-ui`，关于el-table和el-pagination的可以自己再封装，这里不演示了，只演示mixins的相关内容。\n\n## 总结\n\n封装好mixins后使用既方便了开发，维护起来也方便了很多，比如说我的默认页要调整到20页，我该一行代码就可以了，关键是把真正项目中公用的地方抽离出来，这个要考虑好。\n\n虽然mixins好用，但是也不是没有缺点，如果说你一个组件引入的mixins过多，那么容易产生我这个数据或方法不知道从哪来的，会产生不确定性。\n\n","tags":["vue"],"categories":["vue"]},{"title":"vue3.0之vue-composition-api尝鲜","url":"/haoge744.github.io/2019/11/05/vue3-0之vue-composition-api尝鲜/","content":"\n# 简介\n\n根据vue作者尤雨溪去年发布的vue3.0开发路线，vue3.0很可能会在2019年下半年推出。\n\n此前vue官方也提供过了vue3.0特性的尝鲜版本，叫做`vue-function-api`,此后推出的最新版本为`vue-composition-api`,之前的`vue-function-api`已经淘汰了不再推荐学习了。\n\n虽然vue3.0还没有正式发布，但是已经可以安装`composition-api`插件来体验了。\n\n本篇文章将介绍`composition-api`基础使用以及最重要的一些新特性,例如`setup()`函数、`reactive()`、`ref()`等这些Vue Hooks。\n\n<!-- more -->\n\n# 安装\n\n1. 安装@vue/cli3\n\n   ```\n   npm install -g @vue/cli\n   ```\n\n2. 创建项目\n\n   ``` bash\n   vue create my-project\n   ```\n\n3. 安装`composition-api`\n\n   ``` bash\n   npm install @vue/composition-api --save\n   ```\n\n4. 使用\n\n   ``` javascript\n   // 在main.js使用\n   import Vue from 'vue'\n   import VueCompositionApi from '@vue/composition-api'\n   \n   Vue.use(VueCompositionapi)\n   \n   ```\n\n\n\n\n# 使用\n\n## setup函数\n\n**setup**函数是vue3中，专门为组件提供的新属性，它为我们使用vue3的Composition API 提供了同意的入口\n\n生命周期:\n\n**setup**会在**beforeCreate**之后，**created**之前执行。\n\n```javascript\n// comp1.vue\nexport default{\n    props: {\n        title: String\n    },\n    setup(props, ctx) {\n        console.log(props.title)\n    }\n}\n// 使用\n<compSetup title=\"access\" aaa=\"app\"></compSetup>\n\n```\n\n#### setup函数的形参\n\n**props**对应的是组件的参数，并且必须在`props`中声明才能访问的到，否则会出现在`Vue inheritAttrs`中\n\n**ctx**对应的是一个上下文对象，包含了一些有用的属性，这些属性在`vue2.x`中通过`this`才能访问，在vue3.x中集成到了**ctx**属性中。如图\n![setup](vue3-0之vue-composition-api尝鲜/setup.png)\n\n> 注意：在`setup()`函数中无法访问`this`\n\n### reactive\n\n`reactive()`函数接受一个普通的对象，返回一个响应式的数据对象\n\n#### 基本语法\n\n等价于Vue2.x中的`Vue.observable()`函数\n\n``` javascript\nimport { reactive } from '@vue/composition-api'\nexport default {\n    setup (props, ctx) {\n        const state = reactive({count : 0})\n        // 将响应式对象state 返回出去，否则外界访问不到\n        return state\n    }\n}\n```\n\n模板中访问\n\n``` vue\n<template>\n\t<span>{{ count }}</span>\n\t<!-- 每次点击加1，同时页面也会更新 -->\n\t<button @click=\"count += 1\">\n        +1\n    </button>\n</template>\n\n```\n\n使用方式和原来差不多，只不过原来是data属性，现在集成到了setup函数中，写法有点像react了\n\n### ref\n\n`ref()`函数的作用是根据给定的值创建一个响应式的数据对象，`ref()`函数调用的返回值是一个对象，且该对象只有一个属性:`value`\n\n#### 使用:\n\n``` vue\n<template>\n  <div>\n    <!-- 在模板中使用不需要.value -->\n    {{ count }}\n    <button @click=\"count += 1\">\n        +1\n    </button>\n  </div>\n</template>\n\n<script>\nimport {ref} from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const count = ref(0)\n        count.value++ // 在setup中使用需要.value ref返回的是对象\n        return {\n            count\n        }\n    }\n}\n</script>\n```\n\n`ref`的功能和`reactive`很像，但在`vue3`中推荐使用`ref`创建响应式对象\n\n#### ref和reactive配合使用\n\n``` javascript\n<script>\nimport {ref, reactive} from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const cc = ref(0)\n        const state = reactive{\n            cc\n        }\n        console.log(state.cc) // 输出0 此处不需要.value就能直接访问原始值\n        state.cc++\n        console.log(state.cc) // 输出1\n        return state\n    }\n}\n</script>\n```\n\n**注意:在setup创建的任何成员，想要使用必须在setup()中return**\n\n> 新的ref会覆盖就的ref:\n\n``` javascript\nconst a1 = ref(0)\nconst state = reactive({\n    a1\n})\nconst a2 = ref(10)\n\nstate.a1 = a2 // 将旧ref a1指向 新ref a2\nstate.a1++\nconsole.log(state.a1) // 输出 11\nconsole.log(a2) // 输出11\nconsole.log(a1.value) // 输出0\n```\n\n### isRef\n\n作用是判断该对象是否是`ref`方法创建的\n\n``` javascript\nimport {isRef} from '@vue/composition-api'\nconst objValue = isRef(obj) ? obj.value : obj\n```\n\n### toRefs的使用\n\ntoRefs函数的作用是将reactive()创建出来的对象，转换成普通的对象，只不过这个对象的每一个属性都是ref类型的响应式数据。\n\n应用场景:\n\n``` vue\n<template>\n\t<div>\n        {{ count }}\n        <button @click=\"increment\">+1</button>\n    </div>\n</template>\n<script>\nimport {toRefs, reactive} from '@vue/composition-api'\n\nexport default {\n    setup () {\n        \n        const state = reactive({\n            count: 0\n        })\n        \n        // 定义页面上的事件处理函数\n        const increment = () => {\n            state.count++\n        }\n        \n        // 在setup中返回一个对象供页面调用 可以包含响应式的数据，也可以包含供页面调用的函数\n        return {\n            ...toRefs(state),\n            // 增加的处理函数\n            increment\n        }\n    }\n}\n</script>\n```\n\n在vue3中推荐在setup中写函数而不是在`metods`中写， 但是如果要返回响应式的值，又要返回函数的话，直接使用`...state`会让响应式失去作用，所以就有了`toRefs`函数，他把对象中所有的属性改为了ref类型，所以给页面提供了响应式的功能。\n\n### computed计算属性\n\n `computed()` 用来创建计算属性，`computed()` 函数的返回值是一个 `ref` 的实例。使用 `computed` 之前需要按需导入： \n\n``` javascript\nimport { computed } from '@vue/composition-api'\n```\n\n只读计算属性\n\n``` vue\n<template>\n  <div>\n      count的值：{{ count }}\n      计算属性：{{ plusOne }}\n      <button @click=\"count += 1\">+</button>\n  </div>\n</template>\n\n<script>\nimport { computed,ref } from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const count = ref(0)\n        const plusOne = computed(() => count.value + 1)\n        return {\n            count, plusOne\n        }\n    }\n}\n</script>\n```\n\n可读写的计算属性:\n\n``` javascript\n\nconst count = ref(0)\nconst plusOne = computed({\n    get: () => count.value + 1\n    set: (val) => count.value =  val - 1\n})\n//为计算属性赋值会触发set函数\nplusOne.value = 10\nconsole.log(count.value) // 输出9\n```\n\n### watch\n\n和vue2.x的`watch`作用一致，只是用法不一样\n\n#### 基础用法\n\n``` javascript\nimport { watch, ref } from '@vue/composition-api'\nconst count = ref (0)\n// 每次改变count 都会打印count的值\nwatch(() => console.log(count.value))\n```\n\n#### 监听reactive和ref\n\n``` javascript\nconst state = reactive({count: 0})\n// 监视state.count的数据变化\nwatch(\n\t() => state.count, // 第一个参数设置监听的数据源\n    (count, oldCount) => { // 第二个参数为监听方法\n        // TODO\n    },\n    {\n        lazy: true, // watch创建的时候会自动执行一次，设置lazy可以关闭\n    }\n)\n// 监听ref\nconst c2 = ref(0)\nwatch(c2, \n\t(val, oldVal) => {\n    \t// TODO\n\t}    \n)\n```\n\n在vue2.x中监听多个数据源，需要写多个watch,在vue3中支持监听多个数据源:\n\n#### 监听多个数据源:\n\n``` javascript\nconst state = reactive({ count: 0, name: 'zs' })\n\nwatch(\n  [() => state.count, () => state.name], // Object.values(toRefs(state)),\n  ([count, name], [oldCount, oldName]) => { // 按顺序解构赋值\n    console.log(count) // 新的 count 值\n    console.log(name) // 新的 name 值\n    console.log('------------')\n    console.log(oldCount) // 旧的 count 值\n    console.log(oldName) // 新的 name 值\n  },\n  {\n    lazy: true \n  }\n)\n\nsetTimeout(() => {\n  state.count++\n  state.name = 'ls'\n}, 1000)\n```\n\n监听多个ref:\n\n``` javascript\nconst count = ref(0)\nconst name = ref('zs')\n\nwatch(\n  [count, name], // 需要被监视的多个 ref 数据源\n  ([count, name], [oldCount, oldName]) => {\n    console.log(count)\n    console.log(name)\n    console.log('-------------')\n    console.log(prevCount)\n    console.log(prevName)\n  },\n  {\n    lazy: true\n  }\n)\n\nsetTimeout(() => {\n  count.value++\n  name.value = 'xiaomaolv'\n}, 1000)\n```\n\n#### 清除watch监视\n\n在组件销毁的时候会自动清除watch的监听，但是如果需要手动清除的话可以用以下的方法\n\n```\nconst stop = watch(() => {})\n// 调用watch的返回值就可以停止监听\nstop()\n```\n\n#### 清除无效的异步任务\n\n 有时候，当被 `watch` 监视的值发生变化时，或 `watch` 本身被 `stop` 之后，我们期望能够清除那些无效的异步任务，此时，`watch` 回调函数中提供了一个 `cleanup registrator function` 来执行清除的工作。这个清除函数会在如下情况下被调用： \n\n- watch 被重复执行了\n- watch 被强制 `stop` 了\n\n**Template 中的代码示例如下**：\n\n```html\n/* template 中的代码 */ <input type=\"text\" v-model=\"keywords\" />\n```\n\n**Script 中的代码示例如下**：\n\n```js\n// 定义响应式数据 keywords\nconst keywords = ref('')\n\n// 异步任务：打印用户输入的关键词\nconst asyncPrint = val => {\n  // 延时 1 秒后打印\n  return setTimeout(() => {\n    console.log(val)\n  }, 1000)\n}\n\n// 定义 watch 监听\nwatch(\n  keywords,\n  (keywords, prevKeywords, onCleanup) => {\n    // 执行异步任务，并得到关闭异步任务的 timerId\n    const timerId = asyncPrint(keywords)\n\n    // 如果 watch 监听被重复执行了，则会先清除上次未完成的异步任务\n    onCleanup(() => clearTimeout(timerId))\n  },\n  // watch 刚被创建的时候不执行\n  { lazy: true }\n)\n\n// 把 template 中需要的数据 return 出去\nreturn {\n  keywords\n}\n```\n\n实现之后的效果是,等输入框输入暂停时才会触发打印，有了这个功能防抖就好做了 (;￢＿￢)  \n\n### New LifeCycle Hooks\n\n新的生命周期方法，可以按需导入到组件中，且只能在 `setup()` 函数中使用，代码示例如下： \n\n``` javascript\nimport { onMounted, onUpdated, onUnmounted } from '@vue/composition-api'\n\nconst MyComponent = {\n  setup() {\n    onMounted(() => {\n      console.log('mounted!')\n    })\n    onUpdated(() => {\n      console.log('updated!')\n    })\n    onUnmounted(() => {\n      console.log('unmounted!')\n    })\n  }\n}\n\n```\n\n下面的列表，是 `vue 2.x` 的生命周期函数与新版 Composition API 之间的映射关系：\n\n- ~~`beforeCreate`~~ => use `setup()`\n- ~~`created`~~ => use `setup()`\n- `beforeMount` => `onBeforeMount`\n- `mounted` => `onMounted`\n- `beforeUpdate `=> `onBeforeUpdate`\n- `updated` => `onUpdated`\n- `beforeDestroy` => `onBeforeUnmount`\n- `destroyed` => `onUnmounted`\n- `errorCaptured` => `onErrorCaptured`\n\n### provide和inject\n\n`provide()`和`inject()`用于实现嵌套组件之间的数据传递，这两个函数只能在setup中使用。\n\n父组件使用provide向下分享数据，inject在子组件中进行接收数据\n\n### 用法\n\n父组件传递主题颜色\n\n``` vue\n// 父组件\n<template>\n  <div>\n    <h1 :style=\"{color: color}\">父节点</h1>\n    <comp1 />   \n  </div>\n</template>\n\n<script>\nimport { provide,ref } from '@vue/composition-api'\nimport inject1 from './inject1'\nexport default {\n    components: {\n        'comp1': inject1\n    },\n    setup(props, ctx) {\n        const color = ref('#fad0c4')\n        provide('textColor', color)\n\n        setTimeout(() => { // 2秒后变为淡蓝色\n            color.value = '#8fd3f4'\n        },2000)\n        return {\n            color\n        }\n    }\n}\n</script>\n\n// 子组件 inject1.vue\n<template>\n  <div>\n      <h2 :style=\"{color: color}\">子组件</h2>\n      <inject2 />\n  </div>\n</template>\n\n<script>\ninject\nimport {inject} from '@vue/composition-api'\nimport inject2 from './inject2'\nexport default {\n    components: {\n        'inject2': inject2\n    },\n    setup(props, ctx) {\n        const color = inject('textColor')\n        return {\n            color\n        }\n    }\n}\n</script>\n// 孙组件 inject2.vue\n<template>\n  <div>\n      <h3 :style=\"{color: color}\">孙组件</h3>\n  </div>\n</template>\n\n<script>\nimport {inject} from '@vue/composition-api'\nexport default {\n    setup(props, ctx) {\n        const color = inject('textColor')\n        return {\n            color\n        }\n    }\n}\n</script>\n```\n\n### template refs\n\nref也支持vue2.x中的 ref属性，下面看看是怎么实现的\n\n#### 引用页面元素和组件\n\n``` vue\n<template>\n\t<div>\n       \t<h1 ref=\"refTitle\"></h1>\n        <comp1 ref=\"refComp\"/>\n    </div>\n</template>\n<script>\nimport {ref, onMounted} from '@vue/composition-api'\nimpot comp1 from './comp'\nexport default {\n    components: {\n        comp1\n    },\n    setup(props, ctx) {\n     \tconst refTitle = ref(null)\n        const refComp = ref(null)\n        onMounted(() => { // onMounted后dom才渲染完成\n            refTitle.value.style.color = 'red'\n        })\n        return { // 保持和元素中的ref一致\n            refTitle,\n            refComp\n        }\n    }\n}\n</script>\n\n```\n\n### createComponent\n\n> 这个函数是非必须的，除非你想要结合typescript进行vue项目的开发\n\n``` typescript\nimport {createComponent} '@vue/composition-api'\nexport default createComponent({\n    props: {\n        foo: String\n    },\n    setup(props) {\n     \tprops.foo   \n    }\n})\n```\n## 总结\n\n把`composition-api`都体验了一遍，虽然没有做像样的例子，但是感觉还是比较容易上手的，特别如果是有2.x经验的话。\n看的出来使用`this`的地方变少或者没有了。还有就是在vue3中应该不能像以前那样用Mixins了，Mixins本身有个缺点就是数据来源不明，如果引用的多的话更是如此。\n还有就是对ts的支持更加友好了,这里我还没体验过不作过多说明。\n\n## Tips\n\nVue 3将支持全局tree-shaking,这意味着如果你不使用它的某些功能，这些则不会出现在你打包的文件中。\n\n``` javascript\nimport {nextTick, observable} from 'Vue'\nnextTick(() => {})\nconst obj = objservable({})\n```\n\nVue3的响应式由`Object.defineProperty `换为`Proxy`后给对象，数组赋值不需要再使用`Vue.set`方法\n\n``` javascript\nVue.set(obj, key, value)\n=>\nthis.obj[key] = value\n```\n\n","tags":["vue"],"categories":["vue"]},{"title":"东野圭吾-《秘密》读后感","url":"/haoge744.github.io/2019/10/29/东野圭吾-《秘密》读后感/","content":"\n![封面图](东野圭吾-《秘密》读后感/cover.jpg)\n\n## 秘密\n\n> 这篇书评可能有关键情节透露。\n\n用了两个晚上把这本书 看完了，第一天看了50页，第二天看了270多页。一直看到凌晨一点（´Д`）。很久没有进入这种感觉了，平时太忙，或者是有其它一些诱惑或者心情焦虑，静不下心来。\n好的作品确实能 激发读者的遐想，感悟书中的道理，体验书中人物的人生。虽然看完之后心里堵得慌。但是也是学习到了一些人生的哲理，同时也冒出了很多的疑问。特别是以我这个男性的眼光来看，故事的结局并不好。\n\n<!-- more -->\n\n### 创作背景\n\n据说这本书创作时，东野圭吾刚刚和相伴14年的妻子离婚。在这种情况的影响下创作出了这本书，这本书里的内容可能有一些是作者的写照 或者缩影吧。\n\n### 内容梗概\n\n------\n\n主人公**杉田平介**的妻子和女儿坐滑雪大巴回家时，发生了事故，幸亏妻子**直子**的拼死保护才让女儿**藻奈美**幸存下来。妻子最终还是抢救无效去世了，女儿醒来之后无法做出正常的反应。平介虽然心情悲痛但是还是要在女儿面前控制自己的情绪。然而神奇的事情发生了，在女儿身体里的灵魂居然是妻子直子的。这一下平介心理就混乱了。妻子的肉体虽然死亡了，但是灵魂却寄居在女儿身体里，虽然女儿的灵魂不在，但是身体却是健康的。\n\n夫妻俩也别无他法了，只好隐瞒真相继续生活下去，直子提议要继续藻奈美的生活，上学，因为这种事情说出去别人也不会相信。并且直子觉得，之前的人生并不完美，现在有重新来的机会，更要好好把握，好好学习，让以后自己的生活的选择更多，不至于只能做一个家庭主妇。\n\n随着生活的进行，家里两个人也发生了微妙的变化，藻奈美的身体第一次来了例假，还有平介对藻奈美的班主任有好感，但是介于与直子之间夫妻关系，平介并没有想发展下去，另外藻奈美表示想上私立中学，自己要好好备考，认真学习。\n\n有一次平介喝了点酒回家，刚好直子在洗澡，但是直子对于在平介面前,露出身体以及身体接触很抵抗。可能藻奈美身体的发育和在学校的环境影响让直子的心理产生了一些变化，此时两人之间的沟壑越来越深了。\n\n对于平介的生活来说，每天就是日常的上班，下班，还有就是在家陪伴直子。但是直子的生活就很丰富了，每天过着很精彩的生活，此外高中时还加入了社团，直子的想法是，既然人生让她以这样的方式重新来一遍，她也不能\"浪费\"藻奈美身体的使用权，要过的比之前更加精彩，她觉得这样的生活的才有意义。\n\n在高中时期，直子因为加入棒球社团，她居然早出晚归了，有时候不能给平介做饭了。这让平介心中起了疑心，并且偶尔听到直子偷偷和男同学私通电话，终于在占有欲的情况下，平介开始监听了她的电话。终于他听到有一天那位同学在圣诞节约起了直子，平介心中泛起很大不安和嫉妒，于是赶到现场阻止了直子，把她强行带回了家。直子对于出现在现场的平介感到不解和震惊，最终发现了平介偷听的事实...\n\n可能直子是在环境的影响下或者是藻奈美青春期身体的荷尔蒙的作用下吧，她的思维也改变了。他们的关系也出现了很大的裂痕，从上次那件事之后，直子仿佛活的像个机器人，没有灵魂。社团也退了，每天早早的回家做饭，但是她的脸上从那以后，没有笑过。终于有一天，平介决定放手，他开始以`藻奈美`叫她，并且表示让她今后一直以女儿的身份生活下去。藻奈美感动的哭了。\n\n但是第二天早上却发现了神奇的事，女儿藻奈美的意识苏醒了，但是不记得过去几年的事情，平介给他讲了这几年直子一直在她的身体里替她生活的事。但是没过多久藻奈美睡去,醒来的又是直子的意识。就这样两个人的意识交替的出现。但是过了几天后，直子的意识出现的时间越来越少，终于在某天，直子和平介在他们初次约会的公园，完成了告别。平介很伤心，这意味着直子真的消失了。\n\n。。。\n\n几年之后，平介在女儿的婚礼上发现了装有两人钻戒的小熊公仔，他意识到，原来之前藻奈美的意识都是直子装出来的，她在那之后一直以藻奈美的身份生活了下去。藻奈美的意识从来没有出现过。。\n\n本书完。\n\n------\n\n### 书评\n\n我所理解的结局是，直子一直在扮演藻奈美。虽然这个结局对平介来说很不公平，却很现实。\n\n我记得一开始直子扮演藻奈美开始说的一句话。\n\n> 说什么傻话，我会一直陪着你的。\n\n其实看完句话开始我就觉得结局不会很明朗了，至少对平介来说。\n\n直子是焕发第二春了，有了新的人生目标、新的爱好、新的人际交往、新的眼界。那么平介呢，我记得书中说\n\n> 我今后该怎样生活下去呢？他在心里想着这个问题。自己是父亲又不是父亲，是丈夫又不是丈夫，是男人又不是男人。他的心在无情的现实面前颤抖着。\n>\n\n书中男女主心理的变化也很吸引读者的阅读欲望。两夫妻从那次灾难之后就维持着一段奇怪的关系，丈夫不知道如何看待当时的妻子。当妻子看待却又是女儿的身体，当女儿看待又会吃醋嫉妒。妻子也不知道该如何看待丈夫，是维持夫妻关系，还是用女儿年轻的身体再活一次(当然这种想法在我看来有点自私)。这让我想到之前很火的一个送命题：假如女友和丈母娘灵魂对换，必须和其中一个发生关系才能恢复，你怎么选？\n\n记得当时看到直子和同学暧昧的时候，我有点体会到当父亲时女儿要被某个野小子夺走的心情(╬￣皿￣)=○，相当的嫉妒啊。同时结局时也很心疼男主，即失去了妻子，又失去了女儿。这样的话还不如不察觉到那个秘密呢。\n\n总结来说这本书是一本不错的书，出了灵魂对调的事情外，书中的情节都合情合理，书中也对人物的心理描写很丰富。书中的人物关系连接的很奇妙。总归来说是本不错的书，值得一看\n\n可能每个人有每个人的看法，我觉得男主还是可怜啊o(╥﹏╥)o","tags":["生活记事","读后感"],"categories":["生活记事"]},{"title":"Vue inheritAttrs的使用","url":"/haoge744.github.io/2019/10/17/Vue-inheritAttrs的使用/","content":"\n## 介绍\n\n`Vue inheritAttrs`诞生于vue2.4.0版本,目的是为了解决父孙组件传递参数的问题。\n在以前如果要父组件要给孙组件传值只能给子组件设置一套值，然后再给孙组件再设置一套相同的值，这样代码太过冗余并且工作量，还有一个方法就是用`provide`和`inject`,但是貌似这个方法也不是很好，组件多的话很难控制。\n所以vue2.4发布后解决了这个问题，还增加了关于事件向上传递的相关api `$listeners`\n\n<!-- more -->\n\n如果你使用的是vue2.4之后的版本，那么当前的vue组件实例中会默认带一个属性，这个就是`$attrs`属性,这个属性用来保存没有在`props`中声明的参数属性。什么意思呢，就是你定义一个组件，这个组件的props只有一个count，但是我父组件调用的时候除了给了count，比如说还传递了一个:age=\"12\",那么子组件就可以通过`$attrs`来获取到age。\n\n``` vue\n// parent.vue\n<template>\n  <div>\n      <children :count=\"10\" :age=\"15\"/>\n  </div>\n</template>\n\n<script>\nimport children from './children'\nexport default {\n    components: {\n        children\n    }\n}\n</script>\n```\n\n``` vue\n//  children.vue\n<template>\n  <div>\n      {{ count }}\n      {{ $attrs.age }}\n  </div>\n</template>\n<script>\nexport default {\n    props: {\n        count: Number\n    },\n    mounted() {\n        console.log(this)\n    }\n}\n</script>\n```\n\n把children.vue实例打印出来如下图。\n![attrs](Vue-inheritAttrs的使用/attrs.png)\n\n比如说项目中有这样有个功能，弹出一个有table的dialog，只是表格的字段和查询条件不一样。并且很多地方用得到，这样最好是封装成一个组件，然后我要用element的dialog和table进行封装。\n\n![dialogTable](Vue-inheritAttrs的使用/table.png)\n\n``` vue\n\n<template>\n  <el-dialog\n    <!-- sync是不支持的,所以要额外写参数 -->\n    :visible.sync=\"visible\"\n    <!-- 给dialog组件传递参数 -->\n    v-bind=\"$attrs\">\n    <div style=\"padding: 5px;\">\n      <el-table class=\"data-table-container\" :data=\"tableData\" style=\"width: 100%\" v-loading=\"loading\" border>\n        <el-table-column type=\"index\" align=\"center\" label=\"序号\" v-if=\"showNumber\" width=\"50\">\n        </el-table-column>\n        <!-- 循环表格的列，并且给表格列设置绑定属性为item -->\n        <el-table-column v-for=\"(item, index) in head\" v-bind=\"item\" :key=\"index\">\n          <template v-slot=\"scope\">\n            <!-- 如果类型是slot的话给表格的列设置插槽 -->\n            <slot :name=\"item.prop\" v-if=\"item.type === 'slot'\" :data=\"scope.row\"></slot>\n            <template v-else>\n              {{ scope.row[scope.column.property] }}\n            </template>\n          </template>\n        </el-table-column>\n      </el-table>\n    </div>\n  </el-dialog>\n</template>\n\n<script>\n  import request from '@/utils/request'\n\n  export default {\n    name: 'tableGridDialog',\n    props: {\n      head: { // 表格的列\n        required: true\n      },\n      showNumber: {\n        type: Boolean,\n        default: true\n      },\n      url: {\n        type: String\n      },\n      params: {\n        type: Object\n      },\n      httpMethod: {\n        type: String,\n        default: 'get'\n      },\n      show: {\n        type: Boolean\n      },\n      formatDataMethod: {\n        type: Function\n      }\n    },\n    data() {\n      return {\n        tableData: [],\n        loading: false,\n        visible: false,\n      }\n    },\n    methods: {\n      initList() {\n        const queryData = {\n          url: this.url,\n          method: this.httpMethod\n        }\n        if (this.params) {\n          if (this.httpMethod.toLowerCase() === 'get') {\n            queryData.params = this.params\n          } else {\n            queryData.data = this.params\n          }\n        }\n        this.loading = true\n        request(queryData).then(res => {\n          this.loading = false\n          if (res.status === 200) {\n            // 如果有数据格式化方法，执行完之后赋值\n            if (this.formatDataMethod) {\n              this.tableData = this.formatDataMethod(res.data)\n            } else {\n              this.tableData = res.data\n            }\n          }\n        }).catch(error => {\n          console.log(error)\n          this.loading = false\n        })\n      }\n    },\n    created() {\n\n    },\n    watch: {\n      params: {\n        handler(val) {\n          if (val) this.initList()\n        },\n        immediate: true\n      },\n      url (val) {\n        if (val) this.initList()\n      },\n      show: {\n        handler(val) {\n          if (val !== this.visible) {\n            this.visible = val\n          }\n        },\n        immediate: true\n      },\n      visible(val) {\n        if (val !== this.show) {\n          this.$emit('update:show', val)\n        }\n      }\n    }\n  }\n</script>\n```\n\n使用\n\n``` vue\n<template>\n\t<tableGridDialog\n      :url=\"changeUrl\"\n      width=\"740px\"\n      title=\"xx明细\"\n      :params=\"param\"\n      :head=\"changeDesignHead\"\n      :show.sync=\"showchangeDesign\">\n      <template v-slot:createTime=\"{data}\">\n        {{ data.createTime | dateFormat}}\n      </template>\n    </tableGridDialog>\n\n</template>\n\n<script>\nexport default {\n    data () {\n        changeUrl: 'xxx',\n        param: {\n          queryId: 'xxx'  \n        },\n        changeDesignHead: [\n          {\n            prop: 'createTime',\n            label: '日期',\n            align: 'center',\n            type: 'slot'\n          }, {\n            prop: 'name',\n            label: '变更名称',\n            align: 'center',\n            type: 'slot'\n          }, {\n            prop: 'content',\n            label: '内容',\n            align: 'center',\n            width: '200px'\n          }\n        ]\n    },\n    // ...\n}\n</script>\n\n```\n\n使用的话代码也比较简单，不作太多讲解了。总结来说在组件嵌套这块解决了很大的问题。\n\n\n","tags":["vue"],"categories":["vue"]},{"title":"win10更新后提示未安装任何音频设备","url":"/haoge744.github.io/2019/10/10/win10更新后提示未安装任何音频设备/","content":"\n某天正常开启自己的笔记本电脑发现右上角的音量图标划伤了叉号，明明前几天用的好好的，最多就是windows自动更新了下系统，没想到就给更新挂了!!!∑(ﾟДﾟノ)ノ \n\n点击了音量图标，然后弹出个框一直在loading,读取完之后提示我重启之后就好了，但是每次重启之后还是这样提示我重启(╬￣皿￣)=○，无限循环。。。\n\n最后百度后找到了一下三种解决方法\n\n### 更新声卡驱动\n\n下载了驱动精灵安装,并更新声卡驱动到最新版本，并没有啥用￣へ￣\n\n### 卸载声卡设备\n\n操作步骤是这样的：\n\n1. 右键此电脑 => 管理\n\n2. 左侧菜单切换到设备管理器\n3. 找到声音、视频和游戏控制器\n4. 把里面关于声音的设备全部卸载了\n5. 重启电脑 再回到设备管理器右键选择 `扫描检测硬件改动`\n\n但是我试了这种方法也不行\n\n### 秘之方法\n\n最后在csdn的秘之方法，据说是国外大神的。\n\n直接在命令行输入\n\n``` bash\nnet localgroup Administrators /add networkservice\nnet localgroup Administrators /add localservice\n```\n\n没想到意外解决了，所以记下此次记录，希望帮助更多人。\n\n\n","tags":["生活"],"categories":["生活"]},{"title":"webpack基础使用及配置","url":"/haoge744.github.io/2019/10/07/webpack基础使用及配置/","content":"\nVueCli用的比较多了，但是没有系统性的学过webpack,今天不基于任何脚手架工具单纯用webpack搭建一个小项目,加深自己对webpack的理解,以及一些常用配置。另外本文使用的是`webpack4.41.0`,在一些插件的使用上用了最新的方案。\n\n<!-- more -->\n\n## 初始化\n\n``` bash\n-- 创建一个项目文件夹名字任意\n-- 新建src/main.js\n-- 新建src/index.html\ncd 项目文件夹\n-- 初始化package.json\nnpm init -y \n\n-- 安装相关组件\nyarn\nyarn add webpack --dev\nyarn add html-webpack-plugin --dev\nyarn add webpack-dev-server --dev\nyarn add webpack-cli --dev\n```\n\n## 创建配置文件\n\n``` javascript\n// 创建webpack.config.js\nconst path = require('path')\nconst htmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry:  path.join(__dirname, './src/index.js'),// 入口文件\n    output: { // 输出文件\n      path: path.join(__dirname, './dist'),\n      filename: 'bundle.js'\n    },\n    plugins: [ // 插件\n        new htmlWebpackPlugin({\n            template: path.join(__dirname, './src/index.html'),\n            filename: 'index.html'\n        })\n    ]\n}\n```\n\n### 配置启动命令行\n\n``` json\n// package.json\n{\n  ...\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n      // --open自动打开浏览器 端口 3000, 热修复\n    \"dev\": \"webpack-dev-server --open --port 3000 --hot\"\n  },\n}\n\n```\n\n### 添加模式\n\n作用是为了区分生产环境和测试环境\n\n``` \n// package.json\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --open --port 3000 --hot --mode development\",\n    \"prod\": \"\"webpack-dev-server --open --port 3000 --hot --mode production\"\n  },\n}\n```\n\nmode属性是`webpack4.0.0`后增加的，内容可以是`development`和`production`,在dev和prod环境下`process.env.NODE_ENV`打印的值分别为development和production。\n\n项目是可以跑起来了,但是还有一些欠缺，没有对css/scss、图片资源等资源进行处理；还有没有对es6语法进行兼容性问题处理。这个时候就需要用到webpack的loader了。\n\n## 添加loader\n\n在src中新建`css/index.scss`文件和目录,然后给一个div设置背景图片\n\n![比如这样](webpack基础使用及配置/scss.png)\n\n在main.js中引入\n\n```\nimport './css/index.scss'\n```\n\n然后运行后设置的css是无效的，因为没有给css和scss配置对应的loader，代码没有转换，所以会出现错误。\n\n![error](webpack基础使用及配置/error.png)\n\n### **配置样式loader**\n\n``` bash\nyarn add style-loader css-loader sass-loader node-sass url-loader file-loader --dev\n```\n修改`webpack.config.js`\n``` javascript\nmodule.exports = {\n    // 入口、输出、插件等配置在这里省略...\n    module: {\n        rules: [\n           //some rule loaders... ,\n            { test: /\\.css$/, use: ['style-loader', 'css-loader'] },\n            { test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] },\n            { test: /\\.(png|gif|bmp|jpg)$/, use: ['url-loader?limit=5000']},\n        ]\n    }\n}\n```\n\n### **配置babel**\n\n``` bash\nyarn add babel-core babel-loader babel-plugin-transform-runtime babel-preset-env babel-preset-stage-0 --dev\n```\n修改`webpack.config.js`\n``` javascript\nmodule.exports = {\n    // 入口、输出、插件等配置在这里省略...\n    module: {\n        rules: [\n           //some rule loaders... ,\n           // 对js文件使用babel-loader, 排除node_modules中的文件\n           { test: /\\.js$/, use 'babel-loader', exclude: /node_modules/ }\n        ]\n    }\n}\n```\n\n在根目录新建`.babelrc`文件\n\n``` json\n// json格式\n{\t\n    // 刚刚装的babel-preset-x 在这里写上\n    \"presets\": [\"env\", \"stage-0\"],\n    // 使用的插件 babel-plugin-transform-runtime\n    \"plugins\": [\"transform-runtime\"]\n}\n\n```\n关于babel相关的配置及.babelrc文件的编写可以查看[这篇文章](https://excaliburhan.com/post/babel-preset-and-plugins.html)\n\n配置完后就可以使用scss、图片、es6等最新语法了\n\n----- \n\n## 打包\n\n打包前需要安装几个全局依赖(如果没有安装的话)\n\n``` bash\nnpm install webpack -g\nnpm install webpack-cli -g\n```\n\n然后直接在当前目录执行`webpack`命令就可以打包到`dist`目录下了\n\n### 打包相关配置优化\n\n很多时候我们开发和打包的相关配置希望单独存放\n\n复制`webpack.config.js`重命名`webpack.config.build.js`\n\n在`package.json`中添加`build`命令\n\n``` json\n{\n    // ... \n    \"scripts\": {\n        // ... some scripts\n        // 自定义设置文件\n        \"build\": \"webpack --config webpack.config.build.js --mode production\"\n    }\n}\n```\n\n然后运行 `npm run build`就okl了\n\n#### 优化图片路径及名称\n\n``` javascript\n{ test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000] }\n// 改为\n// 图片名称改为8为哈希值-图片名.后缀名, 路径生成到images下面                              \n{ test: /\\.(png|gif|bpm|jpg)$/, use: ['url-loader?limit=5000&name=images/[hash:8]-[name].[ext]'] }\n```\n\n#### 每次打包前删除dist文件\n\n安装插件\n\n``` bash\nyarn add clean-webpack-plugin --dev\n```\n\n在config中添加\n\n``` javascript\nconst clearWebpackPlugin = require('clean-webpack-plugin')\n\nmodule.exports = {\n\t// ...\n    plugins: [\n        // 数组中传入需要删除的文件夹名\n        new clearWebpackPlugin(['dist'])\n    ]\n}\n\n------------- 新写法----------------------\nconst {CleanWebpackPlugin} = require('clean-webpack-plugin')\nmodule.exports = {\n\t// ...\n    plugins: [\n        // 数组中传入需要删除的文件夹名\n        new clearWebpackPlugin()\n    ]\n}\n```\n\n### 抽取第三方包\n\n在开发项目中会用到各种各样的第三方包,我们目前的这个打包方式会把第三方包和自己写的业务代码都放在bundle.js文件中，这样太臃肿了。\n\n``` javascript\n// 修改webpack.config.build.js文件\nconst webpack = require('webpack') // 导入webpack\n// 修改entry入口节点 把原来的入口文件改为对象\nmodule.exports = {\n    entry: { // 配置入口节点\n        app: path.join(__dirname, './src/main.js'),\n        // 这个名字要和chunk插件中的name对应\n        vendors: ['jquery','moment'] // 数组内为要分割的第三方包\n    },\n// 修改plugins\n// ------------------ 这是 webpack 3.x.x的写法 -----------------------\n    plugins: [\n        ...\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'vendors', // 指定要抽离的入口名称\n            filename: 'vendors.js' // 打包时除了会有一个bundle.js还有一个vendors.js文件里面存放了第三方包\n        })\n    ]\n// ------------------  webpack 4.x.x的写法 -----------------------\n    // 配置optimization(和entry同级的属性)\n    optimization: {\n        splitChunks: {\n            cacheGroups: {\n                commons: {\n                    name: \"vendors\",\n                    chunks: \"initial\",\n                    minChunks: 2\n                }\n            }\n        }\n    },\n}\n```\n\n随着webpack4升级chunk得配置也发生了变化\n\n![chunk](webpack基础使用及配置/chunk.png)\n\n[相关链接](https://webpack.docschina.org/plugins/split-chunks-plugin/)\n\n### html-webpack-plugin的优化\n\n``` \n// 修改打包配置文件\n{\n\tplugins: [\n        new htmlWebpackPlugin({\n            template: path.join(__dirname, './src/index.html'),\n            filename: 'index.html',\n            minify: { // html优化项\n                collapseWhitespace: true,// 清除多余的空格\n                removeComments: true, // 清除注释\n                removeAttributeQuotes: true // 清除属性上的双引号\n            }\n        }),\n\t]\n}\n```\n\n还有更多选项[Github](https://github.com/kangax/html-minifier#options-quick-reference)\n\n### css相关优化\n\n#### 抽取css文件\n\n##### 安装插件\n\nwebpack 3.x.x使用**extract-text-webpack-plugin**(这里不做介绍)\n\n```bash\nnpm install --save-dev mini-css-extract-plugin\n```\n\n[github](https://github.com/webpack-contrib/extract-text-webpack-plugin)\n\nwebpack 4.x.x使用**mini-css-extract-plugin**\n\n[github地址](https://github.com/webpack-contrib/mini-css-extract-plugin)\n\n```\nnpm install --save-dev mini-css-extract-plugin\n```\n\n##### 修改配置文件\n\n``` javascript\n// webpack.build.config.js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin') // 引入插件\n\nmodule.exports = {\n    plugins: [\n        // ... some another plugins\n        new MiniCssExtractPlugin({ \n            filename: '[hash:8]-[name].css',\n            chunkFilename: '[id],css',\n            ignoreOrder: false, // Enable to remove warnings about conflicting order\n        })\n    ],\n    module: {\n        rules: [        \n        \t{ \n                test: /\\.css$/, \n                // use: ['style-loader', 'css-loader'] // 注释之前的loader\n                use: [\n                    {\n                        loader: MiniCssExtractPlugin.loader,\n                        options: {\n                            publicPath: (resourcePath, context) => {\n                                // 资源路径，如果你的css打包至css/xxx.css中，那么要返回../\n                                return './';\n                            },\n                        }\n                    },\n                    // style-loader不能引入否则会报错\n                    'css-loader'\n                ]\n            },\n            { \n                test: /\\.scss$/, // 配置scss\n                // use: ['style-loader', 'css-loader', 'sass-loader']\n                use: [\n                    {\n                        loader:MiniCssExtractPlugin.loader,\n                        options: {\n                            publicPath: (resourcePath, context) => {\n                                return './';\n                            },\n                            hmr: process.env.NODE_ENV === 'development'\n                        },\n                    },\n                    // style-loader不能引入否则会报错\n                    'css-loader',\n                    'sass-loader'\n                ]\n            },\n        ]\n    }\n}\n```\n\n","tags":["webpack"],"categories":["webpack"]},{"title":"typescript随手笔记1","url":"/haoge744.github.io/2019/10/02/typescript随手笔记1/","content":"\n## 介绍\n\nTypeScript是Javascript的超集，具有静态类型特性，旨在简化大型JavaScript应用程序的开发，也被称为Javascript that scales(可扩展的JavaScript)\n\n<!-- more -->\n\n### 优点\n\n- 在开发周期中能更早地捕获潜在的错误。\n- 管理大型代码库\n- 更易于重构\n- 更易于团队合作：代码的耦合性越强，不同开发人员访问代码库时越不容易造成无意的破坏\n- 文档特性：类型本身就是一种文档信息，方便日后开发者本人或者其他开发者查询。\n\n### 缺点\n\n- 需要学习周期\n- 类型错误多种多样\n- 配置极大地影响运行\n\n## TS的类型\n\n#### Boolean\n\n``` typescript\nconst loading: boolean = true;\n```\n\n#### Number\n\n``` typescript\nconst decimal: number = 1;\nconst binary: number = 0b110;\n```\n\n#### String\n\n``` typescript\nconst str: string = 'hello world'\n```\n\n#### Array\n\n``` typescript\nlet arr: Array = [2,4,5,6]\n// 使用泛型\nlet arr2: Array<number> = [2,6,55]\n```\n\n#### Tuple(元组)\n\n数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n\n元组起源于函数编程语言（如 F#），这些语言中会频繁使用元组。\n\n``` typescript\nlet tom: [string, number] = ['Tom', 25];\n```\n\n#### Any (任意类型)\n\n``` typescript\nlet variable: any = 123\nvariable = 'bbb'\nvariable = [12,23]\n```\n\n#### void 空值\n\nvoid表示没有任何类型。它通常用作没有返回值的函数的返回类型\n\n``` typescript\nfunction sayHello(name: string): void {\n    console.log(`hello ${name}`)\n}\n```\n\n#### Never\n\nneverl类型表示的是那些用不存在的值得类型。一般用于错误处理函数\n\n``` typescript\nfunction error(message: string): never {\n    throw new Error(message);\n}\n```\n\n#### 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n``` typescript\nvar a: string | number = 'abc'\na = 212\n\n```\n\n#### Null & Undefined\n\n在 TypeScript 中，可以使用 `null` 和 `undefined` 来定义这两个原始数据类型：\n\n``` typescript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n`undefined` 和 `null` 是所有类型的子类型。也就是说 `undefined` 类型的变量，可以赋值给 `number` 类型的变量：\n\n```\n// 这样不会报错let num: number = undefined;\n// 这样也不会报错let u: undefined;let num: number = u;\n\n// 这样会报错\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n下一篇会写些关于接口和类相关的内容\n\n> 更多详细内容推荐阅读[此篇教程](https://ts.xcatliu.com/)","tags":["typescript"],"categories":["typescript"]},{"title":"moment.js基础使用","url":"/haoge744.github.io/2019/09/28/moment-js基础使用/","content":"\n## moment.js基础使用\n\n开发中不可避免的会经常碰到一些对日期的操作，使用moment.js可以很简单的实现很多对日期的一些操作，像日期的格式化，转换，计算，当月的第一天或最后一天等等之类的需求，它都可以快速实现。\n\n<!-- more -->\n\n#### 安装\n\nmoment.js也支持使用包管理器安装\n\n```bash\nnpm install moment\n// or \n<script src=\"moment.js\"></script>\n```\n\n#### 创建moment对象\n\n```javascript\nmoment() // 当前时间\nmoment().format('YYYY-MM-DD HH:mm:ss') // 当前事件格式化\nmoment('2019-12-12 ', 'YYYY-MM-DD') // 字符串格式化转为对象\nmoment(new Date().getTime()) // 使用时间戳毫秒转\nconst day = moment(\"1995-12-25\");\n```\n\n#### 格式化\n\n```javascript\nmoment().format('YYYY-MM-DD')\n```\n\n#### 日期计算\n\n```javascript\nmoment().days(3) // days函数取得是在周中的天数，比如传入3求的是下个周三的日期\nmoment().day(-7); // 上周三 (0 - 7)\n// weekday的用法和days大致相同\nmoment().weekday(3) // 获取本周三的日期\nmoment().weekday(-1) // 获取上周末的日期 相当于这周一减1的日期\nmoment().weekday(-10) // 获取上上周周五的日期 本周-10\n```\n\n#### 日期加减\n\n```javascript\nmoment().add(1, 'days') // 可以使用简写\nmoment().subtract(1, 'days') // 求昨天的日期\n```\n\n| Key          | Shorthand |\n| :----------- | :-------- |\n| years        | y         |\n| quarters     | Q         |\n| months       | M         |\n| weeks        | w         |\n| days         | d         |\n| hours        | h         |\n| minutes      | m         |\n| seconds      | s         |\n| milliseconds | ms        |\n\n#### 日期相减\n\n```javascript\n// 计算当前两个日期相差多少天\nmoment().diff(moment('2019-08-05', 'YYYY-MM-DD'), 'days')\n```\n\n我目前常用的也就是格式化和互相转换,还有日期相减之类的，具体更多方法请参照官方[api文档](http://momentjs.cn/docs/#/use-it/)\n\n","tags":["moment"],"categories":["javascript"]},{"title":"vue-cli3.0升级","url":"/haoge744.github.io/2019/09/15/vue-cli3-0升级/","content":"\n## 全局安装\n\n目前执行 `install Vue-cli -g`命令只会安装到Vue-cli 2.9.6,因为Vue cli以后的版本改了包名 改为了 @vue/cli\n\n所以要先卸载掉Vue-cli 2.x.x的版本,在进行安装\n\n```bash\nnpm uninstall -g vue-cli\nnpm install -g @vue/cli\n```\n\n``` bash\nyarn global remove vue-cli\nyarn global add @vue/cli\n```\n\n<!-- more -->\n## 创建vue-cli3项目\n\n```\nvue create <projectName>\n// 之后可以选择以下选项 (空格=单选 a=全选 i= 反选)\n1. Babel 使用babel做编译以兼容IE浏览器\n2. TypeScript 支持TypeScript\n3. Progressive Web App (PWA) support 支持pwa应用\n4. router 路由\n5. vuex 状态管理\n6. Css Pre-processors css 预处理\n7. Linter / Formatter 代码风格校验\n8. Unit Testing  单元测试\n9. E2E Testing 端对端测试\n```\n\n除了使用命令行创建项目还可以使用图形化界面创建\n\n``` bash\nvue ui\n```\n\n运行命令后会自动打开浏览器，点击选择好目录可以点击`在此创建新项目`创建项目了，\n\n![img](vue-cli3.0升级/ui1.png)\n\n然后输入一些基本信息\n\n![img](vue-cli3.0升级/ui2.png)\n\n然后选择项目配置，我选了手动配置,然后可以选择一些基本功能，router,vuex,linter,css预处理之类的功能，css预处理有scss、less、stylus之类。全部选好之后就会自动创建项目了。\n\n![img](vue-cli3.0升级/ui3.png)\n\n创建完成后可以进入图形化的项目管理界面。功能分为5个大模块\n\n1. 项目仪表盘 可以做一些之运行任务、关闭端口、更新插件依赖的功能(可以自定义菜单)\n2. 插件 可以查看、安装插件。\n3. 依赖 可以查看、安装依赖。\n4. 配置 对Vue Cli、Eslint、Css编译进行配置\n5. 任务 一些运行、构建、lint之类的指令。\n\n![img](vue-cli3.0升级/ui4.png)\n\nvue-ui具体更多功能和效果需要自己动手去摸索。\n\n## 启动\n\n``` bash\ncd <project-name>\nnpm run serve\nnpm run build // 构建\n```\n\n启动参数:\n\n```text\nvue-cli-service serve [options] [entry]\n选项：\n\n  --open    在服务器启动时打开浏览器\n  --copy    在服务器启动时将 URL 复制到剪切版\n  --mode    指定环境模式 (默认值：development)\n  --host    指定 host (默认值：0.0.0.0)\n  --port    指定 port (默认值：8080)\n  --https   使用 https (默认值：false)\n```\n\n构建参数:\n\n```text\n用法：vue-cli-service build [options] [entry|pattern]\n\n选项：\n\n  --mode        指定环境模式 (默认值：production)\n  --dest        指定输出目录 (默认值：dist)\n  --modern      面向现代浏览器带自动回退地构建应用\n  --target      app | lib | wc | wc-async (默认值：app)\n  --name        库或 Web Components 模式下的名字 (默认值：package.json 中的 \"name\" 字段或入口文件名)\n  --no-clean    在构建项目之前不清除目标目录\n  --report      生成 report.html 以帮助分析包内容\n  --report-json 生成 report.json 以帮助分析包内容\n  --watch       监听文件变化\n```\n\n## 工程结构\n\n Vue-cli3目录\n\n``` \n┌─src            源码目录\n│  └─assets             资源目录\n│  └─components         组件目录\n│  └─api                后端交互相关模块(需自己手动添加,这里只是建议)\n│  └─views              所有路由组件\n│  └─router             所有路由配置文件目录\n│  └─store              所有状态管理配置文件目录\n│  └─main.js            vue入口文件\n│  └─App.js             入口vue文件\n├─package.json          项目基本信息,包依赖信息等\n├─platforms             存放各平台专用页面的目录，详见\n├─public                public静态资源文件，打包时会被复制到输出目录(dist)中\n│  └─index.html\n│  └─favicon.ico\n├─vue.config.js         可选配置文件，下面会介绍\n```\n\n![img](vue-cli3.0升级/dict.png)\n\n可以看到Vue Cli3和Vue Cli2相比少了config和build文件夹，少了很多配置文件，变得更加简洁。但是如果要修改webpack相关配置的话需要就用到`vue.config.js`文件了。\n\nvue.config.js部分属性说明:\n\n``` javascript\nmodule.export{\n    // 做文件打包后部署用的。如果你的公共路径是 http://www.xxx.com 那么使用默认的 '/'\n    // 如果是 http://www.xxx.com/app 则需要修改成'/app'\n    publicPath: '/', // 最新版本使用publicPath替代原来的 baseUrl\n    outputPath: 'dist', // 构建之后\n    lintOnSave: true, // 是否在保存时执行eslint检查\n    devServer: {\n        host: '',\n        port: 8181,\n        open: true, //配置自动启动浏览器\n        proxy: {\n            ...\n        }\n    },\n    configureWebpack: { // Object | Function\n        plugs: [\n        \tnew webpack.DefinePlugin({ // 使用definePlugin定义全局变量\n                'process.env.api_url': '',\n            })   \n        ]\n    },\n    chainWebpack(config) { // 使用chainWebpack自定义loader\n        config.module\n           .rule('svg')\n           .exclude.add(resolve('src/icons'))\n           .end()\n       config.module // 使用svg-sprite-loader组件加载svg文件\n          .rule('icons')\n          .test(/\\.svg$/)\n          .include.add(resolve('src/icons'))\n          .end()\n          .use('svg-sprite-loader')\n          .loader('svg-sprite-loader')\n          .options({\n            symbolId: 'icon-[name]'\n          })\n          .end()\n    },\n\tpluginOptions: {} // 第三方插件配置        \n}\n```\n\n关于`vue-config`的更多配置请参考[官方文档](https://cli.vuejs.org/zh/config/#vue-config-js)\n\n## 配置环境变量\n\n前端开发过程中，一般来说会经历本地开发、测试脚本、开发自测、测试环境、预上线环境，然后才能正式的发布。对应每一个环境可能都会有所差异，比如说服务器地址、接口地址、websorket地址…… 等等。在各个环境切换的时候，就需要不同的配置参数，所以就可以用环境变量和模式，来方便我们管理。\n\nVue Cli2.x.x的配置主要是在 `config/dev.env.js` 和`config/prod.env.js`中配置,但是到了Vue Cli3后这个配置文件没有了，但是不用担心，到了Vue Cli3中后这个功能变得更加灵活了，可以配置更多种环境变量。\n\n比如说我们配置开发、生产环境的后台地址变量:\n\n```\n// 新建 '.env.development' 文件\n# api地址\nVUE_APP_BASE_API = '/development/api'\n// 新建 '.env.production' 文件\n# api地址\nVUE_APP_BASE_API = '/production/api'\n```\n\n新建完成后会自动根据当前运行环境来读取对应配置文件中的变量了。\n\n### 自定义模式\n\n假如我们要创建一个预上线的环境需要另外一套配置,比如说叫做`staging`。\n\n在package.json中添加一个命令(也可以在启动时添加 ---mode参数)\n\n``` json\n\"scripts\": {\n    \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lint\": \"vue-cli-service lint\",\n    \"staging\": \"vue-cli-service serve --mode staging\"\n  },\n```\n\n创建 `.env.staging`, **文件后缀需要与 `--mode` 后面跟的值一样**\n\n``` \nNODE_ENV = 'production'\nVUE_APP_BASE_API = '/staging/api'\n```\n\n> 注意: *只有以 `VUE_APP_` 开头的变量会被 `webpack.DefinePlugin` 静态嵌入到客户端侧的包中。*\n\n关于环境变量和模式的[官方介绍文档](https://cli.vuejs.org/zh/guide/mode-and-env.html)\n\n## Tips\n\n安装Vue cli3前必须卸载Vue cli2,如果安装完Vue cli3 之后，还想用Vue-cli2.x 版本呢\nVue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 Vue init 功能，你可以全局安装一个桥接工具：\n\n``` bash\nnpm install -g @vue/cli-init\n// 安装完后 就还可以使用 vue init 命令\nvue init webpack my_project\n```","tags":["vue"],"categories":["vue"]},{"title":"webpack打包优化配置","url":"/haoge744.github.io/2019/09/03/webpack打包优化配置/","content":"\n## 关闭source-map配置\n\n\n关闭source-map之后可以大大减少打包后文件体积，关掉之后出现的弊端是如果出现报错信息，无法准确判断问题在哪。\n\n``` javascript\t\n// config/index.js\n// 把productionSourceMap属性的true改成false即可生效\nmodule.exports = {\n    build: {\n        productionSourceMap: true => false\n    }\n}\n\n```\n\n<!-- more -->\n\n## gzip压缩优化\n\ngzip可以优化页面加载时的速度，这个操作需要后台配合开启gzip,并且安装`compression-webpack-plugin`的时候要注意版本，像我用的`webpack 3.6`安装了`compression-webpack-plugin 3.0.0`然后就出现错误了。\n\n**开启gzip后,js会生成`js.gz`文件，会略微增加打包文件的体积:**\n\n``` javascript\t\n\n// Gzip off by default as many popular static hosts such as\n// Surge or Netlify already gzip all static assets for you.\n// Before setting to `true`, make sure to:\n// npm install --save-dev compression-webpack-plugin\nproductionGzip: false,\n```\n\n**服务端开启gzip压缩:**\n\n修改服务器的配置，这里的服务器是Nginx \n找到conf目录下的nginx.conf ,开启gzip,并设置gzip的类型，如下\n开启后，访问服务器的js文件时，会优先查找`.gz`文件，如果没有则会查找`.js`文件\n\n``` \ngzip on; #开启或关闭gzip on off\ngzip_disable \"msie6\"; #不使用gzip IE6\ngzip_min_length 100k; #gzip压缩最小文件大小，超出进行压缩（自行调节）\ngzip_buffers 4 16k; #buffer 不用修改\ngzip_comp_level 5; #压缩级别:1-10，数字越大压缩的越好，时间也越长\ngzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; #  压缩文件类型 \n```\n\n## HappyPack插件优化\n\n由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以Webpack 需要处理的事情需要一件一件的做，不能多件事一起做。\n我们需要Webpack 能同一时间处理多个任务，发挥多核 CPU 电脑的威力，[HappyPack](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack) 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。\n\n安装:\n\n```bash\nnpm i -D happypack\n```\n\n在webpack.config.js中添加plugins\n\n``` javascript\nmodule.exports = {\n    // ... 一些模块配置\n    plugins: [\n            // ... 一些插件配置\n        new HappyPack({\n            //用id来标识 happypack处理那里类文件\n          id: 'happyBabel',\n          //如何处理  用法和loader 的配置一样\n          loaders: [{\n            loader: 'babel-loader?cacheDirectory=true',\n          }],\n          //共享进程池\n          threadPool: happyThreadPool,\n          //允许 HappyPack 输出日志\n          verbose: true,\n        })\n    ]\n}\n```\n\n\n\n## 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块\n\n作用:优化打包速度\n\n因此我们首先需要在我们的项目根目录下创建一个 webpack.dll.config.js 文件。然后配置代码如下：\n\n``` javascript\nconst path = require('path');\nconst DllPlugin = require('webpack/lib/DllPlugin');\n\nmodule.exports = {\n  // 入口文件\n  entry: {\n    // 项目中用到该两个依赖库文件\n    jquery: ['jquery'],\n    echarts: ['echarts']\n  },\n  // 输出文件\n  output: {\n    // 文件名称\n    filename: '[name].dll.js', \n    // 将输出的文件放到dist目录下\n    path: path.resolve(__dirname, 'dist'),\n    /*\n     存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll\n     是为了防止全局变量冲突。\n    */\n    library: '_dll_[name]'\n  },\n  plugins: [\n    // 使用插件 DllPlugin\n    new DllPlugin({\n      /*\n       该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。\n       比如在jquery.manifest文件中有 name: '_dll_jquery'\n      */\n      name: '_dll_[name]',\n\n      /* 生成manifest文件输出的位置和文件名称 */\n      path: path.join(__dirname, 'dist', '[name].manifest.json')\n    })\n  ]\n};\n\n```\n\n在webpack.config.js中配置它:\n\n``` javascript\n// 引入 DllReferencePlugin\nconst DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n\n// 使用插件\nmodule.exports = {\n  plugins: [\n    // 告诉webpack使用了哪些第三方库代码\n    new DllReferencePlugin({\n      // jquery 映射到json文件上去\n      manifest: require('./dist/jquery.manifest.json')\n    }),\n    new DllReferencePlugin({\n      // echarts 映射到json文件上去\n      manifest: require('./dist/echarts.manifest.json')\n    })\n  ]\n}\n\n```\n\n**执行构建：**\n\n最后一步就是构建代码了，先生存第三方库文件，因此我们运行如下命令：\n\n```\nwebpack --config webpack.dll.config.js\n```\n\n在`package.json`中添加如下代码:\n\n```\n\"scripts\": {\n  \"dev\": \"webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline\",\n  \"build\": \"webpack --progress --colors --devtool cheap-module-source-map\",\n  \"build:dll\": \"webpack --config webpack.dll.config.js\"\n},\n```\n\n最后运行`npm run build:dll`打包即可\n\n## 按需引入组件实现优化打包体积\n\n如果只需要一个库的一部分功能，尽量按需导入而不是使用 `Vue.use(Plugin)`","tags":["webpack"],"categories":["webpack"]},{"title":"vue性能优化9法","url":"/haoge744.github.io/2019/09/01/vue性能优化/","content":"\n在2019年3月VueConf US大会上，有人分享了一个Vue性能优化9法的相关演讲，在此和大家分享。\n\n- 演讲视频\n    - http://www.youtube.com/watch?v=5B66qer8cZo\n- 演讲稿\n    - https://slides.com/akryum/vueconfus-2019#/\n- 演示网站\n    - https://vue-9-perf-secrets.nettlify.com\n- 演示代码\n    - https://github.com/Akryum/vue-9-perf-secrets\n\n<!-- more -->\n## 函数型组件\n\n优化前\n``` javascript\n<template>\n    <div class=\"cell\">\n        <div v-if=\"value\" class=\"on\"></div>\n        <section v-else class=\"off\"></section>\n    </div>\n</template>\n<script>\n    export default{\n        props:['value']\n    }\n</script>\n```\n优化后\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\"></div>\n    <section v-else class=\"off\"></section>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['value']\n}\n</script>\n```\n可以看到两段代码的不同仅仅是 `template`标签加了一个`functional`属性，加了这个属性有什么用呢，就是把当前组件变成函数组件，他的一系列生命周期的钩子方法不会调用。省去了这些钩子后，性能将会得到优化。\n\n## 子组件拆分\n优化前\n``` javascript\n<template>\n  <div :style=\"{ opacity: number / 300 }\">\n    <div>{{ heavy() }}</div> \n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['number'],\n  methods: {\n    heavy () { /* 非常耗时，计算量大的处理 */ }\n  }\n}\n</script>\n\n```\n\n优化后\n``` javascript\n<template>\n  <div :style=\"{ opacity: number / 300 }\">\n    <ChildComp/>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['number'],\n  components: {\n    ChildComp: {\n      methods: {\n        heavy () { /* 耗时计算逻辑放到子组件当中 */ }\n      },\n      render (h) {\n        return h('div', this.heavy())\n      }\n    }\n  }\n}\n</script>\n```\n在主组件当中把一个非常耗时耗性能的处理仅仅放在method中，那么每次组件更新时，都会重新调用一下，这样非常耗性能。那么优化之后，把耗时的逻辑放到了子组件中，那么主组件更新，也不会重新计算，提高了性能。\n\n## 局部变量\n\n优化前\n``` javascript\n<template>\n  <div :style=\"{ opacity: start / 300 }\">{{ result }}</div>\n</template>\n\n<script>\nimport { heavy } from '@/utils'\n\nexport default {\n  props: ['start'],\n  computed: {\n    base () { return 42 },\n    result () {\n      let result = this.start\n      for (let i = 0; i < 1000; i++) {\n        result += heavy(this.base) // 每次调用计算属性\n      }\n      return result\n    }\n  }\n}\n</script>\n```\n优化后\n``` javascript\n<template>\n  <div :style=\"{ opacity: start / 300 }\">\n    {{ result }}</div>\n</template>\n\n<script>\nimport { heavy } from '@/utils'\n\nexport default {\n  props: ['start'],\n  computed: {\n    base () { return 42 },\n    result () {\n      const base = this.base // 先声明一个常量，\n      let result = this.start\n      for (let i = 0; i < 1000; i++) {\n        result += heavy(base)// 每次计算时使用常量\n      }\n      return result\n    }\n  }\n}\n</script>\n```\n这个例子比较简单，在循环中处理比较复杂的逻辑时，推荐先声明常量，然后每次计算时用常量而不是计算属性。\n\n## 活用v-show,减少v-if\n\n优化前\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-if=\"props.value\" class=\"on\">\n      <Heavy :n=\"10000\"/>\n    </div>\n    <section v-else class=\"off\">\n      <Heavy :n=\"10000\"/>\n    </section>\n  </div>\n</template>\n```\n\n优化后\n``` javascript\n<template functional>\n  <div class=\"cell\">\n    <div v-show=\"props.value\" class=\"on\">\n      <Heavy :n=\"10000\"/>\n    </div>\n    <section v-show=\"!props.value\" class=\"off\">\n      <Heavy :n=\"10000\"/>\n    </section>\n  </div>\n</template>\n```\n这个也很简单，`v-if`显示和隐藏时，是删除和新增dom，而`v-show`是控制dom的css来隐藏显示，所以隐藏显示频繁的组件最好用v-show。\n\n## 使用keep-alive\n\n优化前\n``` javascript\n<template>\n  <div id=\"app\">\n    <router-view/>\n  </div>\n</template>\n```\n优化后\n``` javascript\n<template>\n  <div id=\"app\">\n    <keep-alive>\n      <router-view/>\n    </keep-alive>\n  </div>\n</template>\n```\n保持页面cache，提高页面加载效率\n## 活用延迟装载(Defer)\n优化前\n``` javascript\n<template>\n  <div>\n    <h2>I'm an heavy page</h2>\n\n    <Heavy v-for=\"n in 10\" :key=\"n\"/>\n\n    <Heavy class=\"super-heavy\" :n=\"9999999\"/>\n  </div>\n</template>\n```\n优化后\n``` javascript\n<template>\n  <div>\n    <h2>I'm an heavy page</h2>\n\n    <template v-if=\"defer(2)\">\n      <Heavy v-for=\"n in 10\" :key=\"n\"/>\n    </template>\n\n    <Heavy v-if=\"defer(3)\" class=\"super-heavy\" :n=\"9999999\"/>\n  </div>\n</template>\n\n<script>\nimport Defer from '@/mixins/Defer'\n\nexport default {\n  mixins: [\n    Defer()\n  ]\n}\n</script>\n\n```\n\n延迟加载各组件，使用户感觉界面加载流畅\n``` javascript\n// Defer.js\nexport default function (count = 10) {\n  // @vue/component\n  return {\n    data () {\n      return {\n        displayPriority: 0,\n      }\n    },\n\n    mounted () {\n      this.runDisplayPriority()\n    },\n\n    methods: {\n      runDisplayPriority () {\n        const step = () => {\n          requestAnimationFrame(() => {\n            this.displayPriority++\n            if (this.displayPriority < count) {\n              step()\n            }\n          })\n        }\n        step()\n      },\n\n      defer (priority) {\n        return this.displayPriority >= priority\n      },\n    },\n  }\n}\n```\n## 分批处理(Time Sicing)\n\n优化前\n``` javascript\nfetchItems ({ commit }, { items }) {\n  commit('clearItems')\n  commit('addItems', items)\n}\n```\n优化后\n``` javascript\nfetchItems ({ commit }, { items, splitCount }) {\n  commit('clearItems')\n  const queue = new JobQueue()\n  splitArray(items, splitCount).forEach(\n    chunk => queue.addJob(done => {\n      // Commit array chunks on several frames\n      requestAnimationFrame(() => {\n        commit('addItems', chunk)\n        done()\n      })\n    })\n  )\n  // Start and wait for all the jobs\n  // to finish\n  await queue.start()\n}\n```\n未优化时，同时处理两个提交操作，操作效率慢，把任务分成块执行，按顺序执行，提高渲染性能\n\n## 非相应模式(non-reactive)\n优化前\n``` javascript\nconst data = items.map(\n  item => ({\n    id: uid++,\n    data: item,\n    vote: 0\n  })\n)\n```\n优化后\n``` javascript\nconst data = items.map(\n  item => optimizeItem(item)\n)\n\nfunction optimizeItem (item) {\n  const itemData = {\n    id: uid++,\n    vote: 0\n  }\n  Object.defineProperty(itemData, 'data', {\n    // Mark as non-reactive\n    configurable: false,\n    value: item\n  })\n  return itemData\n}\n```\n在上面，使用map方法来遍历更改对象，每次在循环中赋值时，会改变原对象。并且会触发vue的监视机制从而更新组件。在优化之后，取消了vue对itemData对象的观察，这样不会触发多余的监视方法。从而提高了效率。\n## 仅渲染可视化部分\n\n优化前\n``` javascript\n<div class=\"items no-v\">\n  <FetchItemViewFunctional\n    v-for=\"item of items\"\n    :key=\"item.id\"\n    :item=\"item\"\n    @vote=\"voteItem(item)\"\n  />\n</div>\n```\n优化后\n``` javascript\n<recycle-scroller\n  class=\"items\"\n  :items=\"items\"\n  :item-size=\"24\"\n>\n  <template v-slot=\"{ item }\">\n    <FetchItemView\n      :item=\"item\"\n      @vote=\"voteItem(item)\"\n    />\n  </template>\n</recycle-scroller>\n```\n优化前:一下就选软所有数据项。优化后：只渲染24个组件，只渲染用户能看到的数据。提高渲染性能。\n## 总结\n对于简单的页面，可以忽略优化细节，重点可以放在功能实现上，尤其在工期紧张的时候。而对于页面复杂，计算逻辑过多的应用时，应该充分考虑使用优化技巧。\n不过在时间充足的情况下，可以考虑把性能以及资源加载这部分优化到极致，这不但使应用变得更好，对自己更是一个提升。","tags":["vue"],"categories":["vue"]},{"title":"围棋入门","url":"/haoge744.github.io/2019/08/31/围棋入门/","content":"\n有段时间对围棋比较感兴趣，不过之前对于围棋的规则还不是很了解，只是觉得围棋很复杂、深奥。于是在B站上补了补课，学习了围棋的相关规则，还有就是看了一下名局的讲解(看不太懂，但感觉很厉害)。可能现在人们下的比较多的就是象棋、五子棋这些吧。还有比较有名的是国际象棋和日本的将棋。国际象棋和中国象棋很像，但是有一些特殊的规则，比如王车易位、吃过路兵、小兵升级等。将棋的规则相比前两个要复杂很多，先是将棋棋子中几乎所有棋子都可以升级，并且吃完对手的棋子后，可以归为己用，重新下在棋盘上。这个规则大幅度提高了将棋的复杂度。\n中国象棋、国际象棋、将棋这三种棋都有一些相同的地方,比如开局要摆放好固定的阵型，获胜的方式都是将死对面的老大。围棋和它们不一样，一开始要双方自己布局，下棋的方式也不一样，以上三种棋是运子，围棋是落子。\n\n<!-- more -->\n> 围棋易学难精！！！　　围棋的规则十分简单，却拥有十分广大的空间可以落子，使得围棋变化多端，比象棋更为复杂。这就是围棋的魅力所在。下一盘围棋的时间没有规定，快则五分钟，慢则要几天，多数时候下一盘棋需要一到二个小时。首先，它包含着极为丰富的哲学内涵：哲学家可以从中领悟到哲学矛盾范畴中对立与统一规律，量变与质变规律，否定之否定规律。现象与本质，认识与实践等等辩证关系。　　军事家可以从中领悟到军事领域内斗智斗勇的奥秘，历史上有很多的军事家都是围棋高手，如曹操，谢玄等都精通围棋。有很多围棋理论著作都是借战争理论加以阐述的。汉马融的《围棋赋》上说：“观围棋兮，法于用兵，三尺之局兮，为战斗场”。宋围棋国手刘仲青《棋诀》中写道：盖布棋之先务，如兵之先阵而后敌也。围棋十诀与毛老人家的十大军事原则有异曲同工之妙。　　另外围棋具备修身益智的作用。关于围棋是早的说法就是：昔者尧造围棋以教彤朱。并且在历史上围棋向来与神仙有不解之缘，从烂柯故事到很多名画，中间的道具都基本上是围棋。\n\n\n## 介绍\n\n围棋，起源于中国，中国古代称为“弈”，可以说是棋类之鼻祖，围棋至今已有4000多年的历史。据先秦典籍《世本》记载，“尧造围棋，丹朱善之。”晋张华在《博物志》中继承并发展了这种说法：“尧造围棋，以教子丹朱。若白：舜以子商均愚，故作围棋以教之。”\n\n## 围棋的规则\n围棋是一个圈地盘的游戏，谁圈的地盘大，谁就获胜。围棋棋盘由19*19组成，形成361个交叉点，棋子下在交叉点上而不是格子里，棋盘上有9个黑点，称为星位，中间的那个最特殊，只有它没有对称的点。称为天元。一个棋子下在棋盘上，他的相邻的上下左右四个相邻点称之为这个棋子的气。注意斜方向不算，如果有相邻的棋子连在一起，可以把这两个棋子看成是一个整体，他们的气是共享的。如下图,左边的白棋有9气，右边的白棋有6气。\n![气](围棋入门/气.png)\n气没有了，棋子就`死`了,如下图，如果白棋下在A点黑棋就`死`了,这时候这个棋子就要从棋盘上拿掉了。\n![打吃](围棋入门/打吃.png)\n\n### 禁入点\n围棋的棋子不能下在不入气的地方，这个地方也称为禁入点，如下图，白棋是不能下在A的位置的，因为一下在棋盘上，他就没有气了，所以这个点是白棋的禁入点。如下图\n![禁入点](围棋入门/禁入点.png)\n但是也有例外，我们看下图的这个棋形。\n![打劫](围棋入门/打吃2.png)\n白棋先行，按理来说白棋不能下在A这个位置，因为一下在棋盘上，就没有气了。但是白棋下下来之后，上面的黑棋被吃掉了，这时候黑棋被提子之后，白棋又有气了。所以这种情况白棋是可以下在A点的。但是我们观察发现，这时候黑棋又可以下在刚刚被吃掉的地方，再把A点的白棋吃掉。再之后白棋又可以下在A点的地方吃掉黑棋... 那这样不是没完没了吗。所以围棋中有一个规定，刚刚被吃掉子的那个点，第一手不可以再落子。比如说第一手白棋下在A的位置，吃掉了黑棋，那么黑棋不能马上在B下棋了。这种情况围棋术语称为打劫，之后黑棋在其他地方落子，称为找劫财。如果白棋在被吃黑子后再下在B点，那么这个打劫就结束了。\n\n### 围棋的\"死\" \"活\"\n\n> 在围棋的范围中，研究单方死或活的关于眼的问题叫做死活。死活是围棋的根本，要想围棋计算力提高必须做死活题，否则棋艺不会提高。\n\n随着棋局的进行，棋盘上最后剩下的就只会有活棋，那么什么是活棋?就是永远都有气的棋，那么怎样才能让棋永远都有气呢?可以看下面这个棋形.\n![活棋](围棋入门/活棋.png)\n可以看到黑棋中间是围了两个禁入点，白棋不论怎么围，始终不能把黑棋的气给杀干净，所以黑棋是活棋.因为黑棋围住的两个点像两只眼睛。所以我们把不入气点成为\"眼\"。**想要活棋必须要做出两个或两个以上的眼**\n\n#### 假眼\n![假眼](围棋入门/假眼.png)\n我们看上面这个棋形，虽然黑棋好像做出了两个眼，但是我们发现，黑棋下面有一颗棋子被白棋打吃了，只要白棋下在B的位置，那么黑棋的这个眼就被破坏掉了，那这个时候黑棋就只剩下一只眼了，那么黑棋只剩一只眼是不能活棋的，最后还是会被白棋给吃掉。\n那么稍微调整下棋形，思考下面这个棋形，黑棋是死棋还是活棋。\n![假眼](围棋入门/活棋2.png)\n\n#### 双活\n\n双方棋子互相包围，且不具备两只真眼，形成双方均不能杀死对方的局面，此时双方都算活棋，这种活棋的方法叫作双活。\n\n![双活](围棋入门/双活.png)\n\n我们看到，黑白双方都不能落子，如果谁先动手，那么反过来会被对方吃掉。这种棋形就是双活。\n\n#### 死活题\n\n如果下面这个棋形黑棋先下，怎么杀掉白棋呢？\n![死活题](围棋入门/死活.png)\n\n只要黑棋下在B点，那么白棋就死了，我们从上面的结论得出，**想要活棋必须有两个眼**，所以我们把黑棋下在B点，白棋就没有空间做出两个眼。那么白棋就死了。反过来，如果白棋先下，下在B点就是活棋了。\n\n### 棋局的胜负\n\n如果不是有一方中盘认输的情况下，下到围棋上不能在下的情况下，棋局就结束了。那么如何判断棋局的胜负呢?\n\n本文一开头说了，围棋是一个圈地盘的游戏，谁的地盘大谁就赢。中国规则是子空皆地，什么意思呢，就是你下在棋盘上的棋子+你围住的空的总数~~谁的总数多，谁就赢\n\n用己方棋子围住的棋盘上的交叉点，这些交叉点叫“目”，也叫“空”，常说这块有“N目空”；对局过程中被吃掉的子，终局后要放回己方的空内；然后比较哪方的“空”多，与棋盘上存在多少棋子无关。\n\n日韩规则都规定，黑方先行，因此贴6.5目，因此日韩规则下的胜负结果就是“黑胜半目”或“黑胜N目半”。\n\n一颗子的价值等于两目，中国规则黑贴3又3/4子，换算成目就是7.5目。两相比较，同样执黑棋，用中国规则就比用日韩规则稍微吃亏。\n\n\n## 围棋的三个阶段\n\n### 布局\n>  布局，又称布石，围棋术语，指围棋的开局走法，一般在几手到几十手的范围内。\n\n布局阶段的主要目标是抢占空地，因为在角上的围空效率更高，所以初期棋盘的四个角上的争斗会比较多。\n![](围棋入门/古力的布局(执黑).png)\n古力的布局(执黑)\n\n### 中盘\n>  中盘是围棋术语。进入中盘阶段后，棋局变化莫测。所以，中盘战斗力量是棋手提高棋力的关键，是下棋者的乐趣所在，也是围棋艺术美的根本。相对而言，布局和收官可以从书籍、定式和高手的对局通过模仿学习，而中盘战斗则是围棋中最难以掌握的技术之一。\n\n中盘的阶段，落子要注意效率，不能靠的太近，靠的太近效率低，围空少，也不能靠的太远，太远容易被分隔开。并且要注意棋子的死活。中盘阶段的变化非常多，这里不多细说，可以自己下下看。\n\n### 收官\n\n> 收官是一个汉语词语，拼音是shōu guān，又称“作官子”，是围棋比赛中三个阶段（布局、中盘、官子）中的最后一个阶段，指双方经过中盘的战斗，地盘及死活已经大致确定之后，确立竞逐边界的阶段。\n\n收官阶段，棋盘上已经下满了棋子了，这个阶段开始争抢一些所剩无几的利益。很多时候棋局并不会进入到收官阶段，因为如果中盘阶段出现了较大的悬殊，那么落后的一方很可能就投资认输了。如果能进入到收官阶段说明双方的底盘是不分伯仲的。这个时候每步棋就要精打细算，寸土必争。不要小看一些细小的利益，很多时候就是因为半目的差距就会输掉比赛。\n\n## 对弈\n\n我上面使用的围棋打谱软件叫MultiGo,也可以支持和ai对战，但是要下一个GNUGO的ai引擎,棋力对于初学者来说已经非常强了。另外也可以去弈城围棋、腾讯围棋等网络平台在线与人对弈。\n\n[MultiGo下载地址](http://www.ruijiang.com/multigo/chs/download.php)\n\n[GNU Go官方下载地址](http://gnugo.baduk.org/)\n\n","tags":["生活记事","围棋"],"categories":["生活记事"]},{"title":"vue中使用stylus","url":"/haoge744.github.io/2019/08/29/vue中使用stylus/","content":"\n## 介绍\n\n![logo](vue中使用stylus/logo.png)\n`stylus`是css的预处理框架。和Sass、Less是一类东西。在`stylus`中可以 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件。\n\n<!-- more -->\n\n### 安装\n\n``` bash\ncnpm install stylus stylus-loader --save-dev\n```\n\n### 在组件中使用\n\n执行完安装命令之后不需要任何配置就可以使用了。\n\n在组件中使用只要把在`style`标签中增加`lang=\"stylus\"`就可以用了\n\n### 在vue文件中引用\n\n```stylus\n<style lang=\"stylus\">\n  @import \"assets/common.styl\";\n  .main_wrapper\n      padding 12 20px\n</style>\n```\n### stylus 编码风格\n\n``` stylus\n$shadow = 0px 3px 6px -2px rgba(0,0,0,0.3)\n\n// mixins\nflexvc()\n    display flex\n    items-align center\n\n// method\nadd (a,b = 10)\n    a + b // 函数可省略返回值\n\n.card\n.card2\n    box-shadow $shadow\n    &:hover\n        background-color #F4F5F6\n\t.footer\n        border-top #ededef\n```\n\n可以看到stylus的写法非常简洁，层级关系使用缩进来表示，分号、冒号、大括号都是可选项，可写可不写。\n\n## 使用语法\n\n1. **选择器**\n   stylus选择器规则和css一样.class选择、#id选择、[type=textarea]属性选择器等等\n   ``` stylus\n   p\n    color #f00\n   ```\n   编译后\n   ``` css\n   p{\n       color: #f00;\n   }\n   ```\n   多个选择器共用\n   ``` stylus\n   .card,.box\n   or    \n   .card\n   .box\n       box-shadow 0px 3px 6px -2px rgba(0,0,0,0.3)\n   ```\n   父级引用,stylus中使用&指向父选择器，可以用来做各种伪类选择器，伪元素等等\n   ``` stylus\n   li\n       background-color #F3F4F5\n       border-bottom 1px solid #f4f5f6\n       &:hover\n           background-color #ccc\n       &:last-child\n           border-bottom none\n   ```\n2. **变量**\n\n   ``` stylus\n   primary-bg = #3A75E7\n   .main_wrapper\n       background-color primary-bg\n   ```\n\n   **标识符**（变量名，函数等），也可能包括`$`字符。例如：\n\n   ``` stylus\n   $font-size = 14px\n   p\n       font-size $font-size\n   ```\n\n   **属性查找**\n\n   Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下：\n\n   ``` stylus\n   #logo\n     position: absolute\n     top: 50%\n     left: 50%\n     width: w = 150px\n     height: h = 80px\n     margin-left: -(w / 2)\n     margin-top: -(h / 2)\n   ```\n   我们不使用这里的变量`w`和`h`, 而是简单地前置`@`字符在属性名前来访问该属性名对应的值：\n   ``` stylus\n   #logo\n     position: absolute\n     top: 50%\n     left: 50%\n     width: 150px\n     height: 80px\n     margin-left: -(@width / 2)\n     margin-top: -(@height / 2)\n   ```\n3. **函数**\n   一个简单的函数\n   ``` stylus\n   add(a,b)\n       a + b // 省略return\n   body\n       padding add(10px, 5)\n   ```\n   默认参数\n   ``` stylus\n   add(a, b =a)\n       a = unit(a, px) // unit把单位都变成px\n       b = unit(b, px)\n   \ta + b\n   add(15%, 10deg)\n       // => 25\n   ```\n   多个返回值\n   ``` stylus\n   paddings()\n       25px 12px\n   \n   .main \n       padding paddings()\n       // 编译后 => padding: 25px 12px;\n   ```\n4. **混合**\n   混合和函数定义差不多，但是效果不一样。函数有返回值，混合没有。\n   比如我们想定义一个垂直居中的横向flex布局可以像下面这样:\n   ``` stylus\n   flexvc()\n   \tdisplay flex\n       align-items center\n   .main-list\n       flexvc()\n   ```\n   父级引用\n   比如说我们想创建一个条纹表格,`even`和`odd`均提供了默认颜色值，每行也指定了`background-color`属性。我们可以在`tr`嵌套中使用`&`来引用`tr`，以提供`even`颜色。\n   ``` stylus\n   stripe(even = #fff, odd = #eee)\n    tr\n      background-color odd\n      &.even\n      &:nth-child(even)\n          background-color even\n   ```\n   然后利用混合书写,如下:\n   ``` stylus\n   table\n       stripe()\n   \n   table#data-grid\n       stripe(#212121, #494848)\n   \ttd\n           color white\n   ```\n5. **插值**\n\n   Stylus支持通过使用`{}`字符包围表达式来插入值，其会变成标识符的一部分。例如，`-webkit-{'border' + '-radius'}`等同于`-webkit-border-radius`.\n\n   比较好的例子就是私有前缀属性扩展：\n\n   ``` stylue\n   vendor(prop, args)\n   \t{prop} args\n   .well\n   \tborder-radius 4px\n   ```\n\n   **选择器插值**\n\n   ``` stylus\n   table\n     for row in 1 2 3 4 5\n       tr:nth-child({row})\n         height: 10px * row\n   ```\n\n   编译后\n\n   ``` stylus\n   table tr:nth-child(1) {\n     height: 10px;\n   }\n   table tr:nth-child(2) {\n     height: 20px;\n   }\n   table tr:nth-child(3) {\n     height: 30px;\n   }\n   table tr:nth-child(4) {\n     height: 40px;\n   }\n   table tr:nth-child(5) {\n     height: 50px;\n   }\n   ```\n\n6. **注释**\n\n   单行注释\n\n   ``` stylus\n   // 单行注释\n   ```\n\n   多行注释\n\n   ``` stylus\n   /*\n    * 多行注释\n    */\n   ```\n\n   ## 总结\n\n   总的来说写法和很多css预处理语言很相似，但是stylus写法更简洁一些，入门也更简单。上面介绍到的功能和用法能满足大部分日常使用需要了。如果还需了解的更加深入的话可以去读下这份[文档](www.zhangxinxu.com/jq/stylus/)。","tags":["vue"],"categories":["vue"]},{"title":"vue自定义指令实现功能级权限","url":"/haoge744.github.io/2019/08/24/vue自定义指令实现功能级权限/","content":"\n### 自定义指令使用介绍\n\n在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。\n\n自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n\n<!-- more -->\n\n#### 钩子函数参数\n- `el`：指令所绑定的元素，可以用来直接操作 DOM 。\n- `binding`：一个对象，包含以下属性：\n  - `name`：指令名，不包括 v- 前缀。\n  - `value`：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n  - `oldValue`：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n  - `arg`：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n  - `modifiers`：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n- `vnode`：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。\n- `oldVnode`：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n\n### 功能实现\n\n权限的获取是在登录时获取，获取完之后缓存至cookie和vuex中，防止用户刷新后出现的问题。然后每次刷新初始化时尝试从cookie中取出权限项再次放入vuex。\n\n``` javascript\n// store/morules/user.js 用户存储的状态信息\nimport {setRoles, getRoles} from '@/utils/cookieHelper'\nimport Vue from 'vue'\nconst user = {\n  state: {\n    roles: getRoles()\n  },\n  mutations: {\n    SET_ROLES: (state, val) => {\n      setRoles(state, val)\n      Vue.set(state,'roles', val)\n    }\n  },\n  actions: {\n\n  }\n}\nexport default user\n```\n\n``` javascript\n// cookieHelper.js \nimport Cookies from 'js-cookie' // cookie存取使用了js-cookie的组件\n\nexport function setRoles (roles) {\n  return Cookies.set('roles', roles.split())\n}\n\nexport function getRoles () {\n  // const roleStr = Cookies.get('roles')\n  const roleStr = 'admin' // 先写死一个变量 利于测试\n  if (roleStr) {\n    return roleStr.split(',')\n  } else {\n    return []\n  }\n}\n```\n\n#### 实现自定义指令功能\n\n``` javascript\n// 新建 directive/auth.js\n\nimport Vue from 'vue'\nimport store from '../store'\n\n\nVue.directive('permission', {\n  inserted: (el, binding) => { // 如果使用bind钩子会找不到父元素\n    const { value } = binding\n    let hasPermission = false\n    const myRoles = store.getters.roles\n    if (value && value instanceof Array && value.length > 0){\n      hasPermission = value.some(item => {\n        return myRoles.includes(item)\n      })\n    }else {\n      throw new Error('参数错误')\n    }\n    if(!hasPermission){ // 没有权限移除该元素\n      el.parentNode.removeChild(el)\n    }\n  }\n})\n\n\n```\n\n``` javascript\n    // 在main.js中引入auth.js\n\t// 测试成功后，把cookieHelper中的返回的权限改为其他值后，按钮隐藏了\n\t<el-button v-permission=\"['add', 'admin']\">添加</el-button>\n```\n","tags":["vue"],"categories":["vue"]},{"title":"活着-生命的意义","url":"/haoge744.github.io/2019/08/19/活着-生命的意义/","content":"![活着](活着-生命的意义/tolive.jpg)\n\n<!-- more -->\n\n### 内容梗概\n\n主人公富贵在年轻时是一个地主家的大少爷，整天游手好闲，无所事事，又嫖又赌，每天还骑着一个胖嘟嘟的妓女和老丈人打招呼，还不以为耻。最终家产被败光。父亲被他气死。所幸妻子家珍对他不离不弃，并且激励富贵要好好生活。富贵好不容易又重燃对生活的信心，不料母亲病倒了，富贵去城里找郎中却又遇上了国民党抓壮丁。被编入了队伍，好不容易没被子弹打死，没有饿死，之后被共产党俘虏，费劲千辛万苦总算回到家乡。本以为回到家一切都会好起来，谁知却是悲剧的开端，母亲病逝了，女儿凤霞也因为发高烧没能及时医治成为了聋哑人。富贵心里别提多难受了。不过自己还有个儿子呢。不过烦心的事又来了，儿子有庆到了上学的年龄，但富贵却根本付不起学费。于是和家珍商量着把凤霞送去给有钱人当丫鬟，这才让儿子有学上。直到有一天凤霞因为太想念父母，而自己偷溜回家看看，富贵此时又舍不得送她走了，又将她留在家里，给家里的农活帮忙，日子也能过。一家人整整齐齐，日子也这么开心的过下去，直到有一天，有庆忽然死了，原来有庆因为跑去给县夫人输血，被医生活活抽血抽死在了医院里。本想着要找县长偿命，但县长居然是之前富贵的战友春生，富贵是即悲痛又无奈。家珍说她这辈子不会原谅春生，他欠她们家一条命。\n\n日子又一天天的过去，没转眼凤霞也到了结婚的年纪，经人介绍认识了县城的工人二喜，虽说二喜有点残疾但是人憨厚老实对凤霞又体贴，不嫌弃凤霞不会说话，这么说来二喜对凤霞来说也算是个好归宿。只是没想到幸福这么短暂，凤霞因为生孩子大出血也死在了那家医院。留下一个男孩苦根。富贵的两个孩子相继去世后，家珍也因为辛苦劳作患上软骨病，最终也在家中逝世。一大家子只剩下富贵、女婿二喜和孙子苦根相依为命。几年后,二喜也因为工地发生意外死了。老年的富贵就把外孙苦根接回了乡下和富贵一起生活。一天富贵为苦根熬了豆子，便出去干活，哪想到，苦根因为很久没吃到好吃的，吃了太多的豆子，活活被撑死了。富贵眼睁睁的看着自己的亲人一个个离自己而去，现在只剩他一个人和一头牛陪伴了。\n\n### 总结\n\n读完整本书，很庆幸自己活在一个比较安定的社会中。不会有不会有国民党抓壮丁，不会有大跃进吃不饱肚子也不会有文化大革命被批斗。\n\n富贵在今天看来是旧社会的一个代表性悲剧人物，每次好像快要抓住幸福了，但是上天又会突如其来的给与下一场考验，把你迅速拉向地狱。或许这样的故事才贴近生活吧，才能引发读者的无限遐想。\n虽然年轻时不懂事，因为好赌败光了土地和家产。但是之后正好碰上土改。因为富贵家正好在这之前就已经是贫农了所以才幸免遇难。富贵是个乐观豁达的人，他在面对接踵而至的灾祸时，每次都能挺过来、能坚强的活着。我不知道如果我遇到富贵的遭遇我会不会对人生放弃希望，我经常思考人生活着的意义是什么，是奋发图强出人头地，还是只追求快乐只顾眼前。人们总说要知足，但是如果一知足就会安于现状不去做任何努力。也有人说人到了二十多岁就已经死了只是到八十岁才埋葬，之后工作，成家立业，然后又等着下一辈的出生。又让他们读书成家立业养育后代。如此反复,重复着一天天的生活，像一具行尸走肉。或许真像文中那样说的吧：\n\n> “人应该为活着本身而活着，不是为了活着之外的任何事物所活着。”\n\n家珍是我在文中很喜欢的人物，她是一个聪明善良坚强的人，富贵在赌场赌博的时候，家珍一直都想把他给拉走。只不过不得而终，自己一个人又走了十几里路回家，那个时候她可是大着肚子啊，可见家珍一直都是想把丈夫给拉回正轨的。并且富贵每次在妓院彻夜不归的时候，家珍也没有什么怨言，并且在外人面前也一直照顾丈夫的面子，替他说话。后面富贵家破产家珍也没有怨言跟着富贵搬到茅草屋住。后来家珍的父亲因为富贵败家把家珍给接走了。所幸后来又回来了，但是没有人知道她付出的代价是什么。在富贵服兵役的两年间，婆婆病倒，凤霞发烧变成聋哑人，她不知道富贵去了哪，也不知道他是否能回来，他只能自己在扛着。谁能知道她有多少次绝望，她在夜里哭过多少次呢。在大饥荒期间，好不容易拉下脸去父亲那要回了一小袋米。才让家里吃上了几顿粥，之后队长来苦苦相求要一点的时候家珍也没有吝啬，给了他一些带回给家里，由此可见她的善良。在有庆死后，富贵并没有马上告诉家珍，但家珍还是从丈夫的神情和反常的行为中发现了儿子已死，但是她并没有大哭大闹，反而只是提议带她去儿子的墓看一看。这段经历也体现出家珍的聪明和冷静。在我看来这样一个善良聪慧又忠诚的女子在现实中是不可多得的，也是现在女性学习的榜样。\n\n### 写在后面\n\n这本小说是差不多2年前读的，剧情在脑中也有些模糊了，文中所有难免会有些误差。请见谅。\n","tags":["生活记事","读后感"],"categories":["生活记事"]},{"title":"filco入手评测","url":"/haoge744.github.io/2019/08/15/filco入手评测/","content":"## 使用感受\n\n话说花一千多块买一把键盘到底值不值？不过我为了体验顶级键盘的手感，还是忍痛割爱了。\n说实话这款键盘我早就看中了，犹豫了很久。最后还是没忍住哈哈。\n对于程序猿这种重度使用键盘的人群，给自己一把好一点的键盘，我觉得也是可以奖励给自己的啊。毕竟时不时给自己一个小礼物，有助于提升自己的幸福感呢。\n\n![包装图](filco入手评测/filco1.jpg)\n包装图\n<!-- more -->\n\n\n包装中规中矩吧，上面也显示支持有线和蓝牙连接，赠送了一个拔键器、防尘罩、两节电池、还有两个键帽，这个待会再说有什么用。\n\n![包装图](filco入手评测/filco2.jpg)\n键盘整体图\n\n从外观上说我觉得还可以，没有现在游戏键盘那么多花里胡哨的各种灯，各种特效。我比较喜欢这种稳重的黑，也没有背光灯。给人看起来比较低调。\nfilco采用的是Abs材质的键帽，懂行的可能知道，Abs键帽虽然手感好，但是时间长了之后，键帽容易打油。个人更喜欢Abs的键帽，虽然Pbt的键帽不会打油，但是磨砂的手感完全比不上Abs类肤的手感。尤其是filco，键帽的厚度和大键的手感调试的非常好。大键和小键的手感几乎完全一样，一般中低端的樱桃轴键盘，大键的手感要么很肉，要么给人感觉就像黑轴一样 很硬。filco给人的感觉相当完美。\n\n![包装图](filco入手评测/filco3.jpg)\nLOGO特写\n\n由于我买的是青轴，声音非常清脆，打字声音比较大，但还可以接受。另外键盘手感比我的 IKBC DC108好了很多。IKBC给我的感觉有点偏硬了。\n因为我喜欢桌面整洁，所以选了双模版，这款键盘支持4台设备切换，但是它这个蓝牙连接方式，要看说明书才能学会。另外键盘右下方好像没有菜单键，这时候赠送的键帽就派上用场了，可以把右win换成菜单键，开一下键盘底下的一个开关就好了,然后换一下键帽，完美。\n## 总结\n根据这几个星期的使用感受，我总结了以下优缺点：\n优点：\n1. 手感。filco的手感一直是它最大的卖点，这点我非常满意。\n2. 双模 没有线的束缚，如果再配上一个无线鼠标，简直爽的一批。\n3. 设计 键帽整体设计给我感觉落落大方，键帽的字体我也很喜欢，还有就是右上角雕刻的LOGO，设计也很棒。\n\n缺点：\n\n1. 贵。\n2. 键帽易打油，这是Abs通用的缺点，使用1至2年就需要更换键帽了。","tags":["生活记事"],"categories":["生活记事"]},{"title":"嫌疑人X的献身读后感","url":"/haoge744.github.io/2019/08/13/嫌疑人X的献身读后感/","content":"\n## 内容简介:\n\n百年一遇的数学天才石神，每天唯一的乐趣，便是去固定的便当店买午餐，只为看一眼在便当店做事的邻居靖子。靖子与女儿相依为命，失手杀了前来纠缠的前夫。为救靖子，石神提出由他料理善后。石神以数学家缜密的逻辑思考设了一个匪夷所思的局，为靖子提供了天衣无缝的不在场证据，令警方始终只能在外围敲敲打打，根本无法与案子沾边。\n\n![封面图](嫌疑人X的献身读后感/timg.jpg)\n\n<!-- more -->\n\n## 正文:\n\n看书封面的简介，确实很吸引读者去阅读，这本推理小说和普通推理小说不同的是，一开始就告诉你犯罪嫌疑人是谁了，真正让读者感兴趣的是，石神是利用什么手法和技巧和警方斗智斗勇,制造骗局的。\n\n石神是个数学天才，深爱着数学，可以为了一道数学谜题孜孜不倦到深夜。某天早晨，石神像往常一样离开公寓，路过公园，径直去靖子打工的便利店买便当，路上碰到熟人打了个招呼，随后到了便利店。像往常一样来了一份便当打包带走，他依然不敢直视靖子。石神走后没多久，没想到靖子的前夫慎二又前来纠缠，在靖子家里成功索财后，还不忘威胁道：“你们逃不出我的手掌心”,这个时候实在忍不住的靖子的女儿美里给了他一榔头，慎二顿时大怒和母女厮打在一起，为了保护女儿，靖子也失去了理智，等到回过神来，前夫慎二已经被她用被炉电线勒死。此时 惊魂未定的母女还未从刚刚的灾难中缓过神来，敲门声突然响起。仓促收拾现场后，靖子开了门.\n\n\n\n> 一开门，只见石神那张大圆脸。细缝般的小眼睛对着靖子，他面无表情，这点令人毛骨悚然。\n> “呃……请问……有什么事吗？”靖子对他挤出微笑，她知道自己的脸颊僵硬。\n> “因为我听到很大的声音。”石神依旧用难以判读情绪的表情说道，“出了什么事吗？”\n> “不，什么事也没有。”她用力摇头，“对不起，给您添麻烦了。”\n> “没事就好。”\n> 靖子发现石神的小眼睛正朝室内看去，全身顿时一热。\n> “呃，是蟑螂……”她情急之下脱口而出。\n> “蟑螂？”\n> “对。因为有蟑螂，所以……我跟我女儿想打蟑螂……所以才引起骚动。”\n> “杀死了吗？”\n> “啊？……”石神的问题，令靖子的脸颊突然绷紧。\n> “蟑螂消灭了吗？”\n> “啊……对。那当然是解决了。已经没事了，对。”靖子频频点头。\n> “这样吗？如果有什么我能帮忙的尽管说，别客气。”\n> “谢谢。吵到您，真的很不好意思。”靖子鞠个躬，关上门，顺便锁上。听到石神回到住处关门的声音，她呼的吐出一口大气，忍不住当场蹲了下来。\n\n\n\n没想到石神通过室内的物品摆放，聊天对话以及气味，已经判断出发生了什么。在靖子母女考虑要不要自首的时候，石神打电话来了,他直接开门见山的说 “女人是无法处理尸体的”，他说他可以帮忙，一方面被石神的逻辑能力和冷静震惊一方面她也只好让石神帮忙。靖子好奇为什么他会知道，问他原因:\n\n> “刚才我来的时候，府上仍留有烟味，所以我本来以为有客人在，却没有看到客人的鞋子。但暖桌底下却好像有人，暖桌的电线也没插上。如果要躲应该躲进屋里。换句话说，这表示暖桌下的人不是躲起来而是被藏起来。再加上之前打斗的声音，你又罕见的蓬头散发，当然想像得到发生了什么事。还有一点，这栋公寓没有蟑螂，我在这已定居多年可以打包票。”\n\n剧透就到这里了。石神和母女说他会搞定尸体，为靖子母子布置了一个匪夷所思的局，一个完美的不在场证明，把他们保护在安全港中，为了他们的安全，石神不顾一切，不惜把自己塑造成一个杀人犯，跟踪狂，只为让靖子安稳度过余生。如果不是石神的天才校友汤川学洞察了这一切，恐怕剧本真的会朝着石神想的那样走。替靖子顶罪，给世人留下一个变态杀人跟踪狂的骂名。\n\n但靖子最终还是从汤川中获知了惊人的真相。她实在无法理解石神居然会为了自己这么一个毫无长处, 长相平凡的女人毁了一生。她之后在之前交换信封的盒子里翻出了这样一句话。\n\n> “工藤邦明先生似乎是个诚实可靠的人。和他结婚，你和美里获得幸福的几率应该比较高。请把我完全忘记，千万不要有罪恶感。因为如果你过得不幸福，我的行为将会完全成为徒劳。”\n> 她看了又看，再次落泪。\n> 她以前从没遇到过这么深的爱情，不，她连世上有这种深情都不知道。石神面无表情的背后，其实藏着常人难以理解底蕴的爱情。\n\n完\n\n## 感悟\n\n这本书全文几乎没有一句废话，一些不起眼的细节也有可能是伏笔。相比其早年的作品，文笔越加狠辣、细腻。让人读起来过瘾。此外，谜底的设计也惊为天人，整本书逻辑相辅而成，没有太多的剧情bug。\n\n其实几年前就读过这本书，一直都想写篇读后感。为了写这篇读后感，我几乎将整本书重看了一遍。而且正是这本书让我对作者有了全新的认知，之前我只读过他的《解忧杂货店》，没想到他的推理小说 更精彩，之后读了他的相关《白夜行》《恶意》《放学后》等推理小说，觉得特别好，除了巧妙的布局之外还经常描写人性，让人意味深长。\n\n另外东野圭吾曾想几度冲击直木奖，但是都只得到了提名，但是这次《嫌疑人x的献身》终于让他如愿以偿，并且还冲击了当年年度推理小说本格奖和推理小说排行榜第一，这让东野圭吾的知名度得到了很高的提升，我觉得正是这个原因，才有了东野圭吾作品大量翻拍成电影、电视剧的现象。","tags":["生活记事","读后感"],"categories":["生活记事"]},{"title":"v-slot的使用","url":"/haoge744.github.io/2019/08/12/v-slot的使用/","content":"\n## v-slot介绍\n\n`vue2.6.x`开始，vue为具名和范围插槽引入了一个全新的语法,即`v-slot`。目的就是想统一`slot`和`scope-slot`语法，使代码更加规范和清晰。\n\n还在`2.5.x`的小伙伴注意`v-slot`只支持在`vue2.6`以上使用，想用的同学请先升级版本哦。\n\n我们看看v-slot和之前的语法区别吧。\n\n<!-- more -->\n### 局名插槽\n\n``` html\n<!-- base-layout.vue -- >\n<div class=\"container\">\n\t<header>\n\t\t<slot name=\"header\"></slot>\n\t</header>\n\t\n\t<main>\n\t\t<slot></slot>\n\t</main>\n\t<footer>\n\t\t<slot name=\"footer\"></slot>\n\t</footer>\n</div>\n```\n\n使用\n\n``` html\n<!-- 过时语法 -->\n<base-layout>\n\t<template slot=\"header\">\n\t\t<h1>ssss</h1>\n\t</template>\n\t<p>12125125<p>\n\t<p>198248924</p>\n\t<template slot=\"footer\">\n\t\t<p>Some Description</p>\n\t</template>\n</base-layout>\n```\n\n使用v-slot指令改写:\n\n``` vue\n<base-layout>\n\t\t<template v-slot:header>\n\t\t\t<h1>title</h1>\n\t\t</template>\n\t\t<p>some content</p>\n\t\t<p>some content</p>\n\t\tor\n\t\t<template v-slot:default>\n\t\t</template>\n\t\t<template v-slot:footer>\n\t\t\t<p>some content</p>\n\t\t</template>\n\t</base-layout>\n```\n\n### 作用域插槽:\n\n``` vue\n<!-- 首先定义绑定对象 -->\n<span>\n    <slot v-bind:user=\"user\">\n    </slot>\n</span>\n```\n\n\n\n``` vue\n<!-- 过时语法 -->\n<slot-example>\n  <template slot-scope=\"slotProps\">\n    {{ slotProps.user.name }}\n  </template>\n</slot-example>\n```\n\n``` vue\n<!-- v-slot的写法 -->\n<slot-example>\n  <template v-slot=\"slotProps\">\n    {{ slotProps.user.name }}\n  </template>\n</slot-example>\n\n<!-- 可解构赋值改写成以下内容 -->\n<slot-example>\n  <template v-slot=\"{user}\">\n    {{ user.name }}\n  </template>\n</slot-example>\n\n<!-- 可以给结构变量赋默认值,防止未定义 -->\nv-slot=\"{user = {name: 'ghost'} }\"\n```\n\n### 简写形式\n\n事件绑定和数据绑定使用的是@和:，v-slot推出后也有一个简写符号，即使用# 代替v-slot例如\n\n``` vue\n<base-layout>\n\t\t<template #header>\n\t\t\t<h1>title</h1>\n\t\t</template>\n\t\t<p>some content</p>\n\t\t<p>some content</p>\n\t\tor\n\t\t<template #default>\n\t\t</template>\n\t\t<template #footer>\n\t\t\t<p>some content</p>\n\t\t</template>\n</base-layout>\n```\n\n然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n\n``` vue\n<!-- 这样会触发一个警告 -->\n<current-user #=\"{ user }\">\n    {{ user.firstName }}\n</current-user>\n```\n\n如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：\n\n``` html\n<current-user #default=\"{ user }\">\n    {{ user.firstName }}\n</current-user>\n```\n\n## 实际使用\n\n接下来写一个导航组件，每个导航可能会有图标或者badge，这个实际使用要看后台数据。首先先写两个组件\n\n``` vue\n<!-- NavList.vue 导航的父组件 -->\n<template>\n  <nav class=\"nav_wrapper\">\n    <!-- 循环迭代导航列表，默认只显示导航的名称 -->\n    <slot v-for=\"item in navList\" v-bind:item=\"item\">\n      <NavItem>\n        {{ item.name }}\n      </NavItem>\n    </slot>\n  </nav>\n</template>\n\n<script>\nimport NavItem from './NavItem'\nexport default {\n  components: {\n    NavItem\n  },\n  props: {\n    navList: {\n      required: true,\n      type: Array\n    }\n  },\n  name: 'NavList'\n}\n</script>\n\n<style scoped lang=\"stylus\">\n.nav_wrapper\n  background-color #545c64\n  color white\n  display flex\n  flex-flow row nowrap\n  padding 0px 40px\n  height 40px\n  align-items stretch\n  & >>> .nav_item // 让子组件的css生效\n    text-decoration none\n    padding 0 40px\n    cursor: pointer\n    display flex\n    align-items center\n    &:hover\n      background-color black\n  & >>> .nav_item_icon img <!-- 给子组件的导航图标设置的样式 -->\n    width 30px\n    height 30px\n    display flex\n    align-items center\n    margin-right 10px\n\n</style>\n```\n\n``` vue\n<!-- 导航的子组件 NavItem.vue -->\n<template>\n  <a class=\"nav_item\">\n    <!-- 导航的图标,默认没有, 在slot标签上设置class不生效,所以用span包裹一下 -->\n    <span class=\"nav_item_icon\"> \n      <slot name=\"icon\"></slot>\n    </span>\n    <slot></slot>\n    <slot name=\"badge\" class=\"nav_item_badge\"></slot>\n  </a>\n</template>\n\n<script>\nexport default {\n  name: 'NavItem'\n}\n</script>\n\n<style scoped>\n</style>\n```\n\n两个相互搭配的组件写好了，接下来开始使用了:\n\n``` vue\n<!-- index.vue -->\n<template>\n  <div>\n    <NavList :navList=\"navList\">\n      <template v-slot=\"{item}\">\n        <NavItem>\n          <!-- 菜单项中有图标则显示、没有则隐藏 -->\n          <template v-slot:icon v-if=\"item.icon\">  \n            <img :src=\"item.icon\" alt=\"\" >\n          </template>\n          {{ getName(item) }}\n\t\t  <!-- 菜单项中有badge则显示、没有则隐藏 -->\n          <template v-slot:badge v-if=\"item.badge\">\n\t\t\t<!-- badge的样式是在父组件中定义的， -->\n            <span class=\"nav_item_badge\">\n              {{ item.badge }}\n            </span>\n          </template>\n        </NavItem>\n      </template>\n      \n    </NavList>\n  </div>\n</template>\n\n<script>\nimport NavList from '@/components/NavList'\nimport NavItem from '@/components/NavItem'\nexport default {\n  name: 'index',\n  components: {\n    NavList,\n    NavItem\n  },\n  data () {\n    return {\n      navList: [{ // 导航菜单的列表\n        name: 'home',\n        icon: require('../../assets/icon.png')\n      },{\n        name: 'news',\n        badge: 2\n      },{\n        name: 'tags'\n      },{\n        name: 'about',\n        icon: require('../../assets/logo.png'),\n        badge: 3\n      }]\n    }\n  },\n  methods: {\n    getName (item) {\n      return item.name.toUpperCase()\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"stylus\">\n  .nav_item_badge \n    width 10px\n    height 10px\n    padding 5px\n    display flex\n    align-items center\n    justify-content center\n    margin-top -12px\n    margin-left 4px\n    font-size 10px\n    border-radius 50%\n    background-color red\n    color: white\n</style>\n```\n\n效果如下:\n\n![效果](v-slot的使用/slot.png)\n\n\n可能样式不是很完美，但是今天主题还是v-slot, 为什么不在NavItem里设置badge的样式呢？这是因为badge的宽高设定之后，父组件无法控制其隐藏。我目前暂时没有想到好的办法。另外本身badge这个东西也应该封装成一个组件的，如果在子组件里写死了那么久丧失了灵活性。另外这个导航本身实际项目中应该不会这样写，这只是一个v-slot的使用样例，仅供参考。\n","tags":["vue"],"categories":["vue"]},{"title":"echarts地图钻取位置异常的解决办法","url":"/haoge744.github.io/2019/08/08/echarts地图钻取位置异常的解决办法/","content":"因为有需求要做一个中国地图下钻到市的功能，但是在钻取中放大的时候碰到了地图位置显示异常的问题，切换地图的时候偶尔会出现地图找不到的问题，如下图:\n\n![错误图](echarts地图钻取位置异常的解决办法/map1.gif)\n\n<!-- more -->\n地图下钻逻辑，初始化的时候缓存全国的地图，省的多次加载，我这里实现echarts下钻的核心方法是 `registerMap(mapName,geoJson,specialAreas)`作用是向echarts内注册一个地图，这个地图的第一个参数是地图名字，可以自定义，第二个是geoJson，可以自己画geojson的数据也可以在echarts的github地址里找到关于中国省市区的地图数据(echarts官网已经下载不了了),访问这个[链接](https://github.com/apache/incubator-echarts/tree/master/map)可以下载到。第三个是可选参数，具体参考文档。\n\n在官网上看到了地图的series中可以设置`center`参数，然后在地图json中看到了每个城市也有经纬度的数据所以可以每次钻取的时候给series设置当前城市的中心点来避免问题发生。\n![广东省地图geoJSON数据](echarts地图钻取位置异常的解决办法/json1.png)\n\n\n\n### 代码:\n\n``` javascript\nexport default {\n    // ... somecode\n    methods: {\n        // ...somecode\n        init () { // 地图初始化，把画布大小调整为全屏以及注册点击事件\n          const dom = document.getElementById('map-wrapper')\n          dom.style.width = document.body.clientWidth + 'px'\n          dom.style.height = document.body.clientHeight + 'px'\n          this.chartInstance = echarts.init(dom)\n          this.chartInstance.on('click', this.chartClickHandler)\n        },\n        chartClickHandler (params) { // 地图点击事件\n          if (params.name in provinces) { // 点省级或者直辖市\n            if (special.indexOf(params.name) >= 0) {\n              this.$toast('直辖市不支持放大')\n              return\n            }\n            this.isNational = false \n            const key = provinces[params.name]\n            const name = params.name\n            this.$toast.loading({\n              mask: true,\n              duration: 0\n            })\n            // 请求static路径下城市的geoJSON.json数据\n            getMapJson(`./static/map/province/${key}.json`).then(async response => {\n              let cityData = []\n              let cityMap = {}\n              console.log(response.data.features[0].properties.name)\n              const lat = response.data.features[0].properties.cp // 获取json里第一个城市的经纬度\n              response.data.features.forEach(item => { // 没有数据的展示零\n                cityMap[item.properties.name] = 0\n              })\n              try {\n                if (this.provIdKeyMap.get(name)) {\n                    // 根据省的id拿到后台数据展示\n                  let cData = await getCityData(this.provIdKeyMap.get(name).split('_')[0]) // 根据省id 获取市的数据\n                  if (cData.status === 200) {\n                    cData.data.forEach(item => {\n                      cityMap[item.cityname] = item.ftreermb\n                    })\n                  }\n                }\n                this.$toast.clear()\n              } catch (error) {\n                this.$toast('加载地图数据失败')\n              }\n              for (let a in cityMap) { // 遍历组装所有市的数据\n                let showLabel = cityMap[a] ? true : false \n                cityData.push({\n                  name: a,\n                  value: cityMap[a],\n                  label: {\n                    show: showLabel\n                  }\n                })\n              }\n              echarts.registerMap(name, response.data) // 注册地图\n              this.renderMap(name, cityData, lat) // 渲染\n            })\n          } else {\n            this.isNational = true\n            this.renderMap('china', this.nationalData)\n          }\n        },\n        // 渲染地图\n        renderMap (map, data, lat = [103.754, 34.452]) { // 地图名字, 数据, 经纬度\n          this.$set(this.option.title, 'subtext', map)\n          const series = [{\n            name: map,\n            type: 'map',\n            mapType: map,\n            roam: true,\n            zoom: 2,\n            nameMap: {'china': '中国'},\n            left: 20,\n            top: '30%',\n            center: lat, // 设置中心点 默认中国的中心点\n            showLegendSymbol: false,\n            label: {\n              normal: {\n                show: true,\n                textStyle: {color: '#000', fontSize: 14}\n              },\n              emphasis: {\n                show: true,\n                textStyle: {color: '#999', fontSize: 14}\n              }\n            },\n            itemStyle: {\n              normal: {\n                areaColor: '#E6E6FA',\n                borderColor: 'dodgerblue',\n                label: {\n                  show: true,\n                  formatter: '{b}\\n{c} '\n                }},\n              emphasis: {\n                areaColor: 'darkorange'\n              }\n            },\n            data: data\n          }]\n          //设置option\n          this.$set(this.option, 'series', series)\n          this.chartInstance.setOption(this.option)\n        }\n    }\n}\n```\n\n完成后效果如下:\n\n![虽然有点瑕疵,但好歹还是解决了问题](echarts地图钻取位置异常的解决办法/map2.gif)\n\n### 不显示数据为零的地名\n\nseries里的data也可以设置label的样式和隐藏显示,设置标签位置等等等。详细配置请访问[链接](https://echarts.baidu.com/option.html#series-map.map)\n\n``` javascript\n{\n    name: a,\n        value: cityMap[a],\n            label: {\n                show: showLabel // 判断数据是否为空或者零\n            }\n}\n```\n\n\n\n","tags":["echarts","移动开发"],"categories":["echarts"]},{"title":"vue项目使用lottie动画","url":"/haoge744.github.io/2019/08/08/vue项目使用lottie动画/","content":"Lottie是一个开源动画框架，支持Android，IOS，ReactNative以及web开发，这篇文章主要讲Lottie在vue项目中如何使用。[GitHub地址](https://github.com/chenqingspring/vue-lottie),我在官方社区看了一下，交互性非常好，动画支持倍速播放，倒放，暂停等功能，能熟练使用的话，交互性能提升很多。\n\n### 安装\n\n在安装目录执行以下命令:\n\n``` bash\nnpm install --save vue-lottie\n```\n\n<!-- more -->\n\n## 使用\n\n准备好动画json文件。可以让UI处理好:\n\n1. UI使用AE--安装bodymovin插件-将AE中的动画工程文件通过bodymovin转换为.json文件--发给开发-开发集成Lottie框架-直接在项目中使用。\n\n2. 或者是在官方库里找:[链接](https://lottiefiles.com/popular)。\n\n具体代码:\n\n``` javascript\n<template>\n    <div>\n        <Lottie :options=\"defaultOptions\" v-on:animCreated=\"handleAnimation\" />\n    </div>\n</template>\n\n<script>\nimport Lottie from 'vue-lottie'\n// 引用动画json文件，在官网下载的。\nimport * as animeData from '../assets/anime.json'\nexport default {\n  name: 'animate',\n  components: {\n      Lottie\n  },\n  data () {\n    return {\n        // ... some code\n        defaultOptions:{\n            animationData: animeData\n        }\n    }\n  },\n  methods: {\n    handleAnimation: function (anim) {\n        this.anim = anim\n    }\n  }\n}\n</script>\n\n<style scope>\n    ...some code\n</style>\n\n```\n\n效果:\n![使用效果](vue项目使用lottie动画/lottie.gif)\n\n### 常用配置:\n\n以上配置只用到了animationData,下面列出一些常用的，更多配置项请在该[链接](https://github.com/bodymovin/bodymovin)中查看\n\n- animationData:  动画json\n- path: 可直接指定动画json // 路径\n- loop: true / false / number //循环\n- autoplay: true / false // 自动播放\n- name:  // 给动画取名字,方便方法调用\n- renderer: 'svg' / 'canvas' / 'html'  //渲染方式\n- container: the dom element on which to render the animation // 可直接指定dom节点渲染\n\n\n\n","tags":["vue","移动开发"],"categories":["vue"]},{"title":"uni随手笔记一","url":"/haoge744.github.io/2019/08/04/uni随手笔记一/","content":"\n自己看官方文档做的一些笔记，记了一些和vue差异的地方和印象较深的地方。看看就好哈哈。\n\n<!-- more -->\n\n### 编写uni注意事项\n\n用uni-app想兼容多端，不能使用带dom、window操作的库，并且最好是纯flex布局，如果只开发h5端，推荐还是用vue-cli构建项目。\n\n### 新老编译模式:\n\n``` javascript\n在manifast.json中配置{\n\t// ...\n\tapp-plus: { // app h5+相关\n\t\tusingComponents: true // 如果是true则是自定义组件模式/否则不是 \n\t},\n\twp-wexin: { // 微信小程序相关\n\t}\n}\n```\n\n**最新版本的XHbuilder默认是自定义组件模式**\n**不支持v-slot新语法 // vue2.6新增**\n\n### npm支持情况\n\n初始化项目\n\n初始化 package.json文件 npm init -y\n\n安装依赖 npm install packageName --save\n\n使用\n\n``` import package from 'packageName'\nconst package = require('packageName')\n* 注意非H5端不支持使用含有dom、window等操作的vue组件和js模块,安装的模块及其依赖的模块使用的api必须是uni-app已有的api, 说明npm 的插件极其难找\n* 支持安装 mpvue组件，但npm方式不支持小程序自定义组件(如wxml格式的vant-weapp)\n```\n\n## 生命周期:\n\n全局生命周期:\n\n| 属性  | 类型 |\n| ------ | ------------ |\n| onLaunch | 当uni-app 初始化完成时触发（全局只触发一次） |\n| onShow | 当uni-app 启动，或从后台进入前台显示 |\n| onHide | 当uni-app 从前台进入后台 |\n| onUniNViewMessage | 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 |\n\n\t组建中新增 onBackPress(event) -- 返回 event ={form: backbutton | navigateBack}\n\t自定义返回键可以看这篇文章:http://ask.dcloud.net.cn/article/35120\n组件生命周期除了vue的基本生命周期额外增加了一些生命周期\n 建议使用 uni-app 的 onReady代替 vue 的 mounted。\n 建议使用 uni-app 的 onLoad 代替 vue 的 created。\n\n`static` 目录下的 `js` 文件不会被编译，如果里面有 `es6` 的代码，不经过转换直接运行，在手机设备上会报错。\n\n## 条件编译及判断运行环境\n\n判断开发环境和生产环境: (方便切换生产环境和正式环境 后台url)\n\n```\n// uEnvDev\nif(process.env.NODE_ENV === 'development'){\n    console.log('开发环境')\n}else{\n    console.log('生产环境')\n}\n```\n\n平台条件编译 \n\n```\n// #ifdef H5\n    alert(\"只有h5平台才有alert方法\")\n// #endif\n```\n\n**注意在css或scss等其他样式中，要使用/* #ifdef MP-WEIXIN */代替**\nifdef的可取值如下\n\tAPP-PLUS、APP-PLUS-NVUE（Weex）、H5、MP-WEIXIN、MP-ALIPAY、MP-BAIDU、MP-TOUTIAO、MP-QQ(qq小程序目前仅cli版支持)、MP(非h5和app+/weex)\n\n#### 样式导入:\n\n​\t使用@import 语句导入\n​\t@import \"../../common/uni.css\";\n内联样式以及动态样式\n​\t<view :style=\"color: color\" />\n​\t注意:\n​\t\tpage相当于body节点，例如:\n​\t\tpage {  background-color: #ccc }\n\n#### css 内置变量 快捷键`hei`\n\n\tvar(--status-bar-height)  //系统状态栏高度\n\tvar(--window-top) //内容区域距离顶部的距离 -- NavagationBar的高度\n\tvar(--window-bottom) // 内容区域距离底部的距离 -- tabBar的高度\n注意导航栏和底部选项卡最好用px作为单位\n\t##注意:背景图片仅支持以 ~@ 开头的绝对路径(不支持相对路径!)\n#### 字体图标\n\n\t支持网络路径图标，网络路径必须加协议头https\n\n### vue 使用注意\n\n\t1.1建议使用 uni-app 的 onReady代替 vue 的 mounted。\n\t1.2建议使用 uni-app 的 onLoad 代替 vue 的 created。\n\n事件处理:\n\t// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件\n\n```javascript\n{\n    click: 'tap',\n    touchstart: 'touchstart',\n    touchmove: 'touchmove',\n    touchcancel: 'touchcancel',\n    touchend: 'touchend',\n    tap: 'tap',\n    longtap: 'longtap',\n    input: 'input',\n    change: 'change',\n    submit: 'submit',\n    blur: 'blur',\n    focus: 'focus',\n    reset: 'reset',\n    confirm: 'confirm',\n    columnchange: 'columnchange',\n    linechange: 'linechange',\n    error: 'error',\n    scrolltoupper: 'scrolltoupper',\n    scrolltolower: 'scrolltolower',\n    scroll: 'scroll'\n}\n```\n\n### 基本元素:\nuni-app推荐使用`view`、`text`等元素替代原来的html元素 用`navigator`替代 `a` ,虽然写`div`或者`a`之类的h5标签也不影响使用但是推荐按照官方的来\n\n元素 共同属性类型\n\n| 属性   | 类型         | 说明                                                      |\n| ------ | ------------ | --------------------------------------------------------- |\n| id     | String       | 组件的唯一标示\t保持整个页面唯一                        |\n| class  | String       | 组件的样式类\t在对应的 css 中定义的样式类               |\n| style  | String       | 组件的内联样式\t可以动态设置的内联样式                  |\n| hidden | Boolean      | 组件是否隐藏\t所有组件默认是显示的                      |\n| data-* | Any          | 自定义属性\t组件上触发的事件时，会发送给事件处理函数    |\n| @*     | EventHandler | 组件的事件\t详见各组件详细文档，事件绑定参考 事件处理器 |\n\n","tags":["移动开发","uni-app"],"categories":["uni-app"]},{"title":"vue3.0 新特性","url":"/haoge744.github.io/2019/08/01/vue3-0-新特性/","content":"\n目前vue最新的版本是19年2月份发布的2.6.x,更新了一些插槽、动态参数等，据说3.0也会在下半年发布，下面根据尤大的视频分享总结3.0的新特性。\n<!-- more -->\n\n## Vue3.0即将带来哪些新东西:\n\n- 更快\n- 更小\n- 更易于维护\n- 更好的多端渲染支持\n- 新功能\n\n判断元素是html原生还是组件的时候把这个动作放到了编译时，提高了运行时的性能。跳过不需要的条件判断，生成更易于被JS引擎优化的代码。\n\n#### 优化Slots生成\n\nVue2.0存在父组件更新时，子组件也关联着也更新了。在vue3.0中优化了这一问题。避免不必要的组件渲染。检测组件更新变得更精确。\n\n#### 静态属性提取\n\n跳过整块静态内容的更新\n及时静态内容在列表中被重复也可以生效。\n跳过单个元素的patch，但依然处理子元素。\n\n主要意思是避免元素不必要的更新。\n\n#### 内联时间函数提取\n\n解决组件重新渲染后 再重新创建函数的问题，3.0中第一次创建后会缓存，那么每次重新渲染之后可以避免这个问题。\n\n#### 数据监听改为Proxy\n\n之前的数据监听系统是由Object.definedProperty的，3.0中会修改为Proxy提高了性能。再大规模数据监听的情况下，性能提升明显。\n\n据说提升后组件实例初始化效率加倍，内存占用减半\n\n## 更小\n\n### 代码结构优化\n\n和Tree-shaking(把没有用到的代码，在最后编译时给优化掉)配合，减小包的体积。\n3.0中内置的模块可以按需引入。只引入最基本模块的情况下,依赖包只有10kb左右。\n\n## 更易于维护\n\n对于vue开发团队而言，更易于维护。用TypeScript完全重写vue的源码。并且不影响用户使用。\n\n源码的各个模块更加解耦。更加利于对阅读源码的理解。\n\n#### 编译器重构\n\n使用插件化设计\n带位置信息的parser(source maps!)\n为更好的IDE供给链铺路\n\nruntime时出错提示优化\n\n## 更好的多端渲染支持\n\nvue衍生出Wexx、NativeVue、wePy 等小程序终端。\nvue3会进行更好的优化。\n推出Custom Renderer API，为多端提供更好的渲染。\n\n``` javascript\nimport { createRenderer } from '@vue/runtime-core'\nconst {render} = createRenderer({\n    nodeOps,\n    patchData\n})\n```\n\n## 新功能\n\n#### 响应式数据监听API\n\n``` javascript\nimport {observable, effect} from 'vue'\nconst state = observable({\n    count: 0\n})\neffect(() => {\n    console.log(`count is: ${state.count} `) //每次更改状态时触发的函数\n})// count is: 0\nstate.count ++ //count is : 1\n```\n\n可以很简单的在多组件中实现状态共享\n\n#### 轻松排查组件更新的触发原因\n\n``` javascript\nconst Comp = {\n    render(props) {\n        return h('div', props.count)\n    },\n    renderTriggered(event){\n        debugger // 可在此检查是在哪触发的组件更新\n        //event可查看更多信息，更改了那个key，哪行代码做的更改..等\n    }\n}\n```\n\n#### 更好的TypeScript支持\n\n提升了性能。支持tsx\n\n#### 更好的警告信息\n\n- 组件堆栈包含函数式组件\n- 可以直接在警告信息中查看组件的props\n- 在更多的警告中提供组件堆栈信息\n\n#### 新加Experimental HooksAPI\n\n类似React Hooks,大概率取代mixins。逻辑重用机制。\n\ngithub上已有Vue Hooks这个项目\n\n#### Experimental Time Slicing Support\n\n把js中复杂的计算切成一帧一帧(每16毫秒)，解决用户界面卡顿的问题。\n\n开启Time Slicing，在js计算的时候每次只占用16毫秒左右的工作量，之后把主动权交还给浏览器，这样浏览器有时间去相应用户的操作\n\n## 关于IE\n\n会有一个专门的版本在IE11中自动降级为旧的getter/setter机制。并对IE中不支持的用法给出警告。但在ie中可能享受不到vue的一些新功能。\n\n> 整理的比较乱，具体功能以及使用需要参考相关官方文档。","tags":["vue"],"categories":["vue"]},{"title":"uni-app 入坑系列一","url":"/haoge744.github.io/2019/07/31/uni-app-入坑系列一/","content":"\n# uni的简介和优点\n\n> `uni-app`是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可编译到iOS、Android、H5、以及各种小程序等多个平台。\n\nuni-app的特点和优势在于，跨平台数量多、性能体验好、生态环境好、开发效率高等特点，确实值得现在开发者学习，学习成本也不高。\n\n<!-- more -->\n\n# 项目目录结构\n\n一个uni-app工程，默认包含如下目录及文件：\n```\n    ┌─components            uni-app组件目录\n    │  └─comp-a.vue         可复用的a组件\n    ├─hybrid                存放本地网页的目录，详见\n    ├─platforms             存放各平台专用页面的目录，详见\n    ├─pages                 业务页面文件存放的目录\n    │  ├─index\n    │  │  └─index.vue       index页面\n    │  └─list\n    │     └─list.vue        list页面\n    ├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此\n    ├─wxcomponents          存放小程序组件的目录，详见\n    ├─main.js               Vue初始化入口文件\n    ├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期\n    ├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见\n    └─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见\n```\n# uni-app 和普通Vue项目开发上有什么区别\n\n## 路由\n\nvue项目配置路由页面在`src/router/index.js`文件下配置\nuni-app在项目根目录下的`pages.json`文件配置，并且结构和vue不一样。`pages.json`具体配置项可见[详情](https://uniapp.dcloud.io/collocation/pages)。\n\n路由跳转\nvue使用vue-router的`router-view`和`vue-router`的api进行页面跳转\nuni-app使用[navigator](https://uniapp.dcloud.io/component/navigator)组件跳转、或者调用[API](https://uniapp.dcloud.io/api/router)跳转。\n\n## 组件开发\n\nuni-app和vue一样也使用`.vue`文件来编写组件\n\n但是uni-app的tmeplate层内的标签是使用类似微信小程序的标签元素来编写的，例如用`<view>`和`<text>`来替代html中的`<div>`和`<span>`标签。\n\n## 第三方组件引入\n\n可以[访问](https://ask.dcloud.net.cn/article/35489)进行查看区别。\n\n## 配置文件\n\nuni-app使用manifast.json配置各平台相关信息，\nvue使用package.json webpack.*.conf.js 等配置文件配置\n\n## 状态管理\n\nuni-app也可以使用vuex来管理生命周期，但是nvue模式下不支持。\n\n## 生命周期\n\nuni-app给app环境下添加了几个全局的生命周期\n    onLaunch 当uni-app 初始化完成时触发（全局只触发一次）\n\tonShow\t当 uni-app 启动，或从后台进入前台显示\n\tonHide\t当 uni-app 从前台进入后台\n\tonUniNViewMessage\t对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯\n\n## webpack 配置\n    uni-app也支持使用webpack安装插件，但是只推荐h5平台使用，其他只支持flex布局和不操作dom的库，制作APP个人不推荐使用webpack安装第三方组件。\n","tags":["移动开发","uni-app"],"categories":["uni-app"]},{"title":"hexo项目搭建","url":"/haoge744.github.io/2019/07/21/hexo项目搭建/","content":"\n## 安装\n\n1. 安装Node.js和git 此处不再阐述\n\n2. 执行一下命令全局安装hexo\n\n   ```\n   $ npm install -g hexo-cli\n   或者\n   $ cnpm install -g hexo-cli\n   ```\n<!-- more -->\n\n### 建站\n\n安装完成后执行以下命令\n\n```\nhexo init <folder>\ncd <folder>\nnpm install\n```\n\n### 目录结构\n\n#### 安装完成之后会生成以下目录\n\n```\n.\n├── _config.yml // 网站的配置信息\n├── package.json // package.json 依赖信息，可查看安装了哪些依赖包\n├── scaffolds // \n├── source // 资源文件夹\n|   ├── _drafts\n|   └── _posts\n└── themes // 主题文件夹\n```\n\n## 写作\n\n在hexo目录下 执行以下命令:\n\n``` \nhexo new \"post title\" \n//写完之后执行 hexo g 生成页面\nhexo s \n\n//生成草稿、 草稿不会生成页面\nhexo new draft \"draft title\"\n\n//生成纯页面\nhexo new page \"page title\"\n\n// 发布草稿\nhexp pulic [layout] <filename>\n```\n\n## 命令\n\n部署:\n\n启动本地服务:\n``` bash\nhexo s -g\n```\n\n```bash\nhexo g -d\n```\n","tags":["hexo"],"categories":["hexo"]}]